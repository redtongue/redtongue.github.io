<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[nowcoder]复杂链表的复制]]></title>
    <url>%2F2018%2F08%2F31%2Fnowcoder-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 题目链接： https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba 分析 参考代码 class RandomListNode: def init(self, x): self.label = x self.next = None self.random = None class Solution: 返回 RandomListNode def Clone(self, pHead): # write code here head=pHead p_Head=None new_Head=None dict1={} dict2={} while(head): node=RandomListNode(head.label) node.random=head.random dict1[id(head)]=id(node) dict2[id(node)]=node head=head.next if(p_Head): new_Head.next=node new_Head=node else: new_Head=node p_Head=node new_Head=p_Head while(new_Head): if(new_Head.random!=None): new_Head.random=dict2[dict1[id(new_Head.random)]] new_Head=new_Head.next return p_Head 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树中和为某一值的路径]]></title>
    <url>%2F2018%2F08%2F31%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 题目链接： https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca 分析 参考代码 class TreeNode: def init(self, x): self.val = x self.left = None self.right = None class Solution: 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here li=[] if(not root): return [] if(root and not root.left and not root.right and root.val==expectNumber): return [[root.val]] left=self.FindPath(root.left,expectNumber-root.val) right=self.FindPath(root.right,expectNumber-root.val) for index in left+right: li.append([root.val]+index) return li 运行时间： 31ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉搜索树的后序遍历序列]]></title>
    <url>%2F2018%2F08%2F31%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 题目链接： https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd 分析 二叉搜索树是根结点大于左子树的所有结点，小于右子树的所有结点； 根据后续遍历序列，根结点为最后一个数字，去除前面小于根结点的序列，如果后面都大于根结点，则继续下一层，否则返回False； 最后返回True 参考代码class Solution: def VerifySquenceOfBST(self, sequence): # write code here def _inter(se): if(len(se)&lt;=2): return 1 else: index=se[-1] i=0 while(se[i]&lt;index): i+=1 judge=i while(judge&lt;len(se)-1): if(se[judge]&lt;index): return 0 judge+=1 print(se[:i]) print(se[i:-1]) return _inter(se[:i])*_inter(se[i:-1]) if(not sequence): return False if(_inter(sequence)): return True else: return False 运行时间： 33ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]从上往下打印二叉树]]></title>
    <url>%2F2018%2F08%2F31%2Fnowcoder-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 题目链接： https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701 分析 将根节点压入list，每次取出list第一个TreeNode，将该TreeNode的非空左/右结点压入list； li存储所有压入过list的TreeNode，li即是二叉树的层次遍历序列。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if(not root): return [] lay=[root] li=[root.val] while(len(lay)): ro=lay[0] lay=lay[1:] if(ro.left): li.append(ro.left.val) lay.append(ro.left) if(ro.right): li.append(ro.right.val) lay.append(ro.right) return li 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]栈的的压入、弹出序列]]></title>
    <url>%2F2018%2F08%2F31%2Fnowcoder-%E6%A0%88%E7%9A%84%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 题目链接： https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106 分析 用list存储栈中的数字，遍历压栈序列，记录压栈序列和出栈序列遍历位置； 如果当前压栈数字等于出栈数字，压栈出栈位置后移；否则：如果list最后一个等于出栈数字，list pop出最后一个数字，出栈位置后移，反之，出栈数字压入list，出栈位置后移； 直到遍历完压栈序列，判断list的逆序与出栈剩余序列是否一致，是则返回True，反之False。 参考代码class Solution: def IsPopOrder(self, pushV, popV): # write code here index=0 li=[] length=len(pushV) i=0 while(index &lt; length): if(pushV[index]==popV[i]): index+=1 i+=1 else: if(len(li) and li[-1] == popV[i]): i+=1 li.pop() else: li.append(pushV[index]) index+=1 while(i&lt;length): if(li[-1] == popV[i]): li.pop() i+=1 else: return False return True 运行时间： 25ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]包含min函数的栈]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 题目链接： https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49 分析 用list代替栈，append代替栈的push操作，pop代替栈的pop操作，定义m为最小值 push：将m更新为m和node之间的最小值 pop：pop出最后一个数，如果pop出的是最小值，则重新更新m top：返回list最后一个数 min：返回m note要求时间复杂度应为O（1），但其实测试用例没有这么大，leetcode上有一题上是要返回频率最大的数字，可以借鉴上面的方法，参考代码：https://redtongue.coding.me/2018/08/27/895-Maximum-Frequency-Stack/ 参考代码class Solution: def __init__(self): self.stack=[] self.m=None def push(self, node): # write code here self.stack.append(node) if(self.m==None): self.m=node else: self.m=min(self.m,node) def pop(self): # write code here self.stack.pop() if(self.stack): self.m=min(self.stack) else: self.m=None def top(self): return self.stack[-1] # write code here def min(self): # write code here return self.m 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]顺时针打印矩阵]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 题目链接： https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a 分析 定义y_i,y_j,x_i,x_j为左右上下的边界，没输出一条边，便更新边界值，直到不满足{x_i&lt;=x_j and y_i&lt;=y_j}； 定义index为方向，0为向左，1为向下，2为向右，3为向上。 返回遍历值。 note递归应该也是可以做的 输入 ‘a’ ‘b’ ‘c’ ‘d’ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输出 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 参考代码class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here y_i,y_j,x_i,x_j=0,len(matrix[0])-1,0,len(matrix)-1 index=0 x,y=0,0 li=[] li.append(matrix[x][y]) while(x_i&lt;=x_j and y_i&lt;=y_j): if(index==0): while(y+1&lt;=y_j): y+=1 li.append(matrix[x][y]) x_i+=1 elif(index==1): while(x+1&lt;=x_j): x+=1 li.append(matrix[x][y]) y_j-=1 elif(index==2): while(y-1&gt;=y_i): y-=1 li.append(matrix[x][y]) x_j-=1 else: while(x-1&gt;=x_i): x-=1 li.append(matrix[x][y]) y_i+=1 index=(index+1)%4 return li 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树的镜像]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 题目链接： https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011 分析 二叉树镜像，即把每个结点的左右子树互换； 递归最方便，每次递归过程如下：如果当前结点不为空，左右子树互换，左右子结点进入下一轮递归。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if(root): index=root.left root.left=root.right root.right=index self.Mirror(root.left) self.Mirror(root.right) return root 运行时间： 27ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]树的子结构]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 题目链接： https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88 分析 首先定义一个函数judge判断两颗树是否为包含关系，递归的每一步，判断当前结点是否都不为空且值相同，否则不是包含关系， 判断两个子结点是否为空，空则返回true，反之进入下一轮迭代； 最后，遍历pRoot1，比较每个结点和pRoot2是否为包含关系，是返回true，否则，遍历结束，返回False。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here def judge(p1,p2): if(p1 and p2 and p1.val==p2.val): index=1 else: return 0 if(p2.left): a=judge(p1.left,p2.left) else: a=1 if(p2.right): b=judge(p1.right,p2.right) else: b=1 return index*a*b if(not pRoot2): return False l=[pRoot1] if(not pRoot1): return False while(len(l)!=0): p=pRoot2 if(judge(l[0],pRoot2)): return True else: if(l[0].left): l.append(l[0].left) if(l[0].right): l.append(l[0].right) l=l[1:] return False 运行时间： 28ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]合并两个排序的链表]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 题目链接： https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337 分析 首先比较两个链表的表头，较小的当作新链表的表头； 同时遍历两个链表，一次将较小的结点加入到新链表中，知道有一个链表遍历结束； 将另外一个没有遍历完的链表的剩余部分直接加入到新链表的尾部。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here head=None if(pHead1!=None and pHead2!=None): if(pHead1.val &lt; pHead2.val): head=pHead1 pHead1=pHead1.next else: head=pHead2 pHead2=pHead2.next elif(pHead1!=None): head=pHead1 pHead1=pHead1.next elif(pHead2!=None): head=pHead2 pHead2=pHead2.next h=head while(pHead1!=None and pHead2!=None): if(pHead1.val &lt; pHead2.val): h.next=pHead1 h=pHead1 pHead1=pHead1.next else: h.next=pHead2 h=pHead2 pHead2=pHead2.next if(pHead1!=None): h.next=pHead1 if(pHead2!=None): h.next=pHead2 return head 运行时间： 22ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]反转链表]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，反转链表后，输出新链表的表头。 题目链接： https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca 分析 遍历每个结点，首先保存该结点的next，再将该结点指向前一个结点； 知道遍历到最后一个结点（next为None），将该结点指向前一个结点，并返回该结点。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if(pHead==None or pHead.next==None): return pHead ne=None p=pHead while(p): index=p.next p.next=ne ne=p p=index return ne 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]链表中倒数第k个结点]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，输出该链表中倒数第k个结点。 题目链接： https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a 分析 遍历链表，将所有结点放在list中； 返回list[-k]。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def FindKthToTail(self, head, k): # write code here h=head l=[] while(h): l.append(h) h=h.next if(k&gt;len(l) or k&lt;=0): return return l[-k] 运行时间： 24ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]调整数组顺序使得奇数在偶数前面]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%BE%97%E5%A5%87%E6%95%B0%E5%9C%A8%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 题目链接： https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593 分析 因为需要保持相对位置不变，遍历将奇数和偶数分别放在list中； 组合返回即可。 参考代码class Solution: def reOrderArray(self, array): # write code here s1=[] s2=[] for index in array: if(index%2==0): s2.append(index) else: s1.append(index) return s1+s2 运行时间： 25ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数值的整数次方]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 题目链接： https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00 分析 如果指数exponent是负数，只是将正数次幂的结果取倒数； 结果为result=1乘以base指数exponent次。 参考代码class Solution: def Power(self, base, exponent): # write code here judge=0 if(exponent&lt;0): judge=1 exponent*=(-1) result=1 while(exponent): result*=base exponent-=1 if(judge): return 1/result else: return result 运行时间： 21ms 占用内存： 5852k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二进制中1的个数]]></title>
    <url>%2F2018%2F08%2F29%2Fnowcoder-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 题目链接： https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8 分析 首先用list存储整数的二进制形式； 如果为正数，返回list的和； 否则，list中{0，1}取反，再加一。 参考代码class Solution: def NumberOf1(self, n): # write code here index=abs(n) li=[0]*32 i=-1 while(index&gt;0): li[i]=index%2 index//=2 i-=1 if(n&gt;0): return sum(li) else: l=[0 if ii else 1 for ii in li] left=1 for i in range(len(l)-1,-1,-1): if(not left): break if(l[i]): if(left): l[i]=0 else: if(left): l[i] = 1 left=0 return sum(l) 运行时间： 21ms 占用内存： 5736k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]矩形覆盖]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 题目链接： https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6 分析 这几题可能是跟斐波那契数列杠上了，同样的分治思想，设F(n)为覆盖2n的大矩形的方法总数，因为都是21的小矩形，所以F(n-1)和F(n-2)可以把F(n)的所有可能性覆盖，虽然F(n-2)到F(n)之间的2*2的剩余有两种覆盖方法，但是其中一种是F(n-1)中已经包含的； 代码也就显而易见了。 参考代码class Solution: def rectCover(self, number): # write code here if(number==0): return 0 a,b=1,1 while(number): a,b=b,a+b number-=1 return a 运行时间： 21ms 占用内存： 5732k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]变态跳台阶]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题目链接： https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387 在跳台阶中的错误代码中考虑可能会有比较厉害的青蛙，万万没想到，来了个变态。 分析 在跳台阶中，青蛙一次只能跳一级或跳两级,用分治的思想的来想，那么青蛙的最后一跳也只能是一个台阶或两个台阶，设F(n)为n级的台阶总共的跳法总数，那么F(n)=F(n-1)+F(n-2)； 同理，虽然变态，但是$F(n) = \sum_{i=0}^{n-1}{F(i)}$，其中F(0)=1 这个规律是显而易见的，但是我们列出来几项方便看的更清楚，{1，2，4，8，16，……} 虽然变态，但是代码很溜。 参考代码class Solution: def jumpFloorII(self, number): # write code here return 2**(number-1) 运行时间： 22ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]跳台阶]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目链接： https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4 分析 刚看到这个题目我想的是用递归来做，可惜失败了，时间超限； 后来想一想青蛙一次只能跳一级或跳两级，他每一步选择只有两个，用递归确实浪费了； 用分治的思想的来想，那么青蛙的最后一跳也只能是一个台阶或两个台阶，设F(n)为n级的台阶总共的跳法总数，那么F(n)=F(n-1)+F(n-2)。 参考代码class Solution: def jumpFloor(self, number): # write code here a,b=1,1 while(number): a,b=b,a+b number-=1 return a 运行时间： 21ms 占用内存： 5732k 递归代码好吧，这是错误代码，但是万一下一次青蛙比较厉害，可以很多台阶，就可以借鉴了。 class Solution: def jumpFloor(self, number): if(n==0): return 1 else: #如果青蛙比较厉害，下面就需要相应修改了 if(n&gt;1): a=self.jumpFloor(n-1) a+=self.jumpFloor(n-2) else: a=self.jumpFloor(n-1) return a return _inter(number)]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]斐波那契数列]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 题目链接： https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3 分析 斐波那契数列如：1，1，2，3，5，8…… ，即F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2） 额外增加一个0，a=0,b=1代表前两个数字，每次只需将b赋值给a，a+b赋值给b，循环次数即斐波那契数列项数。 参考代码class Solution: def Fibonacci(self, n): # write code here a,b=0,1 while(n): a,b=b,a+b n-=1 return a 运行时间： 30ms 占用内存： 5644k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]旋转数组的最小数字]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 题目链接： https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba 分析 输入是一个非减排序的数组，如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，所以最小数字就是第一个小于前面数字的数字。 如果数组长度为0，返回0。 参考代码class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if(len(rotateArray)==0): return 0 index=rotateArray[0] for i in rotateArray: if i &lt; index: return i 运行时间： 549ms 占用内存： 5860k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]用两个栈实现队列]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题目链接： https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6 分析 栈是先进后出，队列是先进先出，用list的append代表栈的push操作，list的pop代表栈的pop操作； 用s1存储队列push的数据，s2存储队列需要pop的数据； 如果s2为空则将s1的所有数据pop出来后append到s2中，以此将数据反转； 用s2的pop替代队列的pop操作。 参考代码class Solution: def __init__(self): self.s1=[] self.s2=[] def push(self, node): # write code here self.s1.append(node) def pop(self): # return xx if(not self.s2): while(self.s1): self.s2.append(self.s1.pop()) return self.s2.pop() 运行时间： 28ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]重建二叉树]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目链接： https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6 分析 如题目中所给的例子，前序：{1,2,4,7,3,5,6,8}，中序：{4,7,2,1,5,3,8,6}； 前序是“根左右”，中序是“左根右”，所以{1}是根节点，左子树的前序是{2,4,7}，左子树的中序是{4,7,2}，右子树的前序{3,5,6,8}，右子树的中序是{5,3,8,6}，这是一次迭代过程； 以此类推，返回根节点。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): root=None if(len(pre) != 0 and len(tin)!=0): root=TreeNode(pre[0]) index=tin.index(pre[0]) root.left=self.reConstructBinaryTree(pre[1:index+1],tin[:index]) root.right=self.reConstructBinaryTree(pre[index+1:],tin[index+1:]) return root 运行时间： 45ms 占用内存： 5856k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]从尾到头打印链表]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 题目链接： https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035 分析 从头指针开支遍历链表，将每个节点的值（ListNode.val）存储到list中，要求是从尾到头，所以每次添加到list中时用list=[ListNode.val]+list。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here li=[] node=listNode while(node!=None): li=[node.val]+li node=node.next return li 运行时间： 22ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]替换空格]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 题目链接： https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423 分析 用一个新变量存储需返回的字符串newStr，逐个遍历源字符串，遇到空格newStr+=’%20’。 参考代码class Solution: # s 源字符串 def replaceSpace(self, s): newStr=&apos;&apos; for i in s: if(i==&apos; &apos;): newStr+=&apos;%20&apos; else: newStr+=i return newStr 运行时间： 23ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二维数组中的查找]]></title>
    <url>%2F2018%2F08%2F28%2Fnowcoder-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目链接： https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e 分析 每一行都按照从左到右递增，每一列都按照从上到下递增，所以每一行最大数是最后一个 比较每一行的最后一个数字与target的大小，如果target大，则目标在下一行，否则，目标在这一行中，将这一行的数字逐个与target比较。 如果到最后一行也没有与target相等的数，返回False 参考代码class Solution: # array 二维列表 def Find(self, target, array): for row in array: if(len(row)&gt;0 and target&gt;row[-1]): continue else: for i in row: if(i==target): return True return False 运行时间： 184ms 占用内存： 5724k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[895.Maximum Frequency Stack]]></title>
    <url>%2F2018%2F08%2F27%2F895-Maximum-Frequency-Stack%2F</url>
    <content type="text"><![CDATA[DescriptionImplement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions: push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack.If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned. 题目链接：https://leetcode.com/problems/maximum-frequency-stack/description/ Difficulty: hard Example 1:Input: [&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation:After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then: pop() -&gt; returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. pop() -&gt; returns 5. The stack becomes [5,7,4]. pop() -&gt; returns 4. The stack becomes [5,7]. Note: Calls to FreqStack.push(int x) will be such that 0 &lt;= x &lt;= 10^9. It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases. 分析 因为每次pop都是返回一个出现频率最大的数字，首先想到的是每次push保存下频率最大的数字，但是pop之后可能就会变化，这是如果去遍历所有push的数字时间会超限； 考虑把所有出现相同次数的数字放在同一个list中，然后把所有的list放入字典中，形如{1: [7, 5, 4], 2: [7, 5]}，代表至少出现一次的是：7，4，5，至少出现两次的是：7，5，题目要求需要在频率相同的情况下pop出最后push进去的，在构建的时候按照push顺序加入到字典中； 在构建一个字典存储每个数字出现的次数，形如：{7: 2, 5: 2, 4: 1} 代码如下 参考代码class FreqStack: def __init__(self): self.count = {} self.group = {} self.max = 0 def push(self, x): if(x in self.count): self.count[x]+=1 else: self.count[x]=1 f=self.count[x] if(f in self.group): self.group[f].append(x) else: self.group[f]=[x] if(f&gt;self.max): self.max=f def pop(self): x=self.group[self.max].pop() self.count[x]-=1 if(not self.group[self.max]): self.max-=1 return x]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>hash table</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[894.All Possible Full Binary Trees]]></title>
    <url>%2F2018%2F08%2F27%2F894-All-Possible-Full-Binary-Trees%2F</url>
    <content type="text"><![CDATA[DescriptionA full binary tree is a binary tree where each node has exactly 0 or 2 children. Return a list of all possible full binary trees with N nodes. Each element of the answer is the root node of one possible tree. Each node of each tree in the answer must have node.val = 0. You may return the final list of trees in any order. 题目链接：https://leetcode.com/problems/all-possible-full-binary-trees/description/ Difficulty: medium Example 1:Input: 7 Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Explanation: Note: 1 &lt;= N &lt;= 20 分析 对任意一个节点只有两个子节点或者0个，那么每个节点的左右子树的节点个数只能为奇数； 依据1，对于每个节点，其左右子树是剩余分成的两份（两份奇数个节点）； 2便是递归的步骤，以此递推。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def allPossibleFBT(self, N): if(N==0): return [None] if(N==1): return [TreeNode(0)] left=[] right=[] root=[] for i in range(1,N-1,2): print(i,N-1-i) left=self.allPossibleFBT(i) right=self.allPossibleFBT(N-1-i) for l in left: for r in right: ro=TreeNode(0) ro.left=l ro.right=r root.append(ro) return root 20 / 20 test cases passed. Runtime: 284 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>tree</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[893.Groups of Special-Equivalent Strings]]></title>
    <url>%2F2018%2F08%2F27%2F893-Groups-of-Special-Equivalent-Strings%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A. 题目链接：https://leetcode.com/problems/groups-of-special-equivalent-strings/description/ Difficulty: easy Example 1:Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;] Output: 3 Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;] Example 2:Input: [&quot;aa&quot;,&quot;bb&quot;,&quot;ab&quot;,&quot;ba&quot;] Output: 4 Explanation: 4 groups [&quot;aa&quot;], [&quot;bb&quot;], [&quot;ab&quot;], [&quot;ba&quot;] Example 3:Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] Output: 3 Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;] Example 4:Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] Output: 1 Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] Note 1 &lt;= A.length &lt;= 1000 1 &lt;= A[i].length &lt;= 20 All A[i] have the same length. All A[i] consist of only lowercase letters. 分析 两个字符串special-equivalent，代表着一个字符串的奇数位置的字符经过任意次换位置和偶数位置的字符经过任意次换位置，两个字符串相等 经过任意次变换相等，也就是在奇数和偶数位置上的字符总和一直，那么一定可以经过任意次互换位置便可以字符串相等。 考虑包含奇数和偶数位置上的字符的特殊编码，即相应字符的个数（a-z,A-Z）,编码个数即groups数 参考代码def count(A): ans = [0] * 52 for i, letter in enumerate(A): ans[ord(letter) - ord(&apos;a&apos;) + 26 * (i%2)] += 1 return tuple(ans) return len({count(word) for word in A}) 34 / 34 test cases passed. Runtime: 52 ms 错误分析刚开始做这道题的时候，也是类似于编码，但是返回的是两个set def judge(s1): a1=set() a2=set() for i in range(len(s1)): if(i%2==0): a1.add(s1[i]) else: a2.add(s1[i]) return [a1,a2] 但是没有像Solution中的那样返回一个元祖，可以在后面把结果放在dict中，导致的结果就是时间超限。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[892.Surface Area of 3D Shapes]]></title>
    <url>%2F2018%2F08%2F27%2F892-Surface-Area-of-3D-Shapes%2F</url>
    <content type="text"><![CDATA[DescriptionOn a N N grid, we place some 1 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes. 题目链接：https://leetcode.com/problems/surface-area-of-3d-shapes/description/ Difficulty: easy Example 1:Input: [[2]] Output: 10 Example 2:Input: [[1,2],[3,4]] Output: 34 Example 3:Input: [[1,0],[0,2]] Output: 16 Example 4:Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 5:Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 分析 对于每一个立方体，由六个面，在整个立方体集合中贡献最大表面积为6； 如果上面有立方体则减一，如果下面有立方体则减一，以此类推（包含上下左右前后六个面）； 因为N和grid[i][j]都不是很大，所以便利所以立方体便可以得到表面积 参考代码def surfaceArea(self, grid): row=len(grid) s=0 for i in range(row): for j in range(len(grid[i])): for index in range(grid[i][j]): current=6 if(i-1&gt;=0): if(grid[i-1][j]&gt;=index+1): current-=1 if(i+1&lt;row): if(grid[i+1][j]&gt;=index+1): current-=1 if(j-1&gt;=0): if(grid[i][j-1]&gt;=index+1): current-=1 if(j+1&lt;len(grid[i])): if(grid[i][j+1]&gt;=index+1): current-=1 if(index&gt;0): current-=1 if(index &lt; grid[i][j]-1): current-=1 s+=current return s 90 / 90 test cases passed. Runtime: 496 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>math</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lda2vev:Mixing Dirichlet Topic Models and Word Embeddings to Make lda2vec]]></title>
    <url>%2F2018%2F08%2F27%2Flda2vev-Mixing-Dirichlet-Topic-Models-and-Word-Embeddings-to-Make-lda2vec%2F</url>
    <content type="text"><![CDATA[结合主题信息和词潜入，生成包含主题信息的向量化表示lda2vec. 论文地址:https://arxiv.org/abs/1605.02019 ABSTRACT 已经证明分布式密集词向量在捕捉语言中的标记级语义和句法规则方面是有效的，而主题模型可以在文档上形成可解释的表示。在这项工作中，我们描述了lda2vec，它是一个与Dirichlet分布的主题向量的潜在文档级别混合学习密集词向量的模型。与连续密集的文档表示形式相反，该表达式通过非负单纯形约束产生稀疏的，可解释的文档混合。我们的方法很容易整合到现有的自动分化框架中，并允许无人监督的文档表示适合科学家使用，同时学习单词向量及它们之间的线性关系。 Introduction主题模型因其能够将文档集合组织为一组较小的突出主题而受到欢迎。 与密集的分布式表示形式相反，这些文档和主题表示通常可以被人类访问，并且更容易被解释。 这种解释性提供了额外的选项来突出我们的文档系统中的模式和结构。 例如，使用潜在狄利克雷分配（LDA）主题模型可以揭示文档中的词汇集合（Blei et al。，2003），强调时间趋势（Charlin et al。，2015），并推断补充产品的网络（McAuley et al。 。，2015）。 见Blei等人。 （2010年），概述计算机视觉，遗传标记，调查数据和社交网络数据等领域的主题建模。 图1：lda2vec通过将word2vec的skip gram体系结构与Dirichlet优化的稀疏主题混合体相结合，在单词和文档上构建表示。 文中描述了图中出现的各种组件和转换。 对于构建文档表示的密集向量方法也存在：Le和Mikolov（2014）提出了可以预测段落中词袋的段落向量，Kiros et al（2015）构建了在给定句子之前和之后重构句子序列的向量，并且Ghosh等人 （2016）构建了预测后续句子特征的语境LSTMs。 概率主题模型倾向于将文档形成为主题的稀疏混合成员，而神经网络模型倾向于将文档建模为密集向量。 由于其稀疏性和低维性，来自前者的陈述更容易检查，并且更直接地产生关于基础系统的高层次直觉（尽管不是没有危害，参见Chang等人（2009））。 本文探讨混合稀疏文档表示密集词和主题向量的混合方法。 不幸的是，制定一个新的概率主题模型需要得到一个新的近似值，这个过程需要大量的专业知识，并且必须根据每个模型进行定制。 因此，原型开发非常耗时，必须仔细考虑对模型体系结构的更改。 但是，使用现代自动分化框架，从业者可以将开发时间集中在模型设计上，而不是模型近似值。 这加快了评估哪些模型特征相关的过程。 这项工作利用Chainer（Tokui等，2015）框架来快速开发模型，同时使我们能够利用GPU来显着提高计算速度。 最后，文本上的传统主题模型没有利用分布式词语表示方面的最新进展，它可以捕捉令牌之间语义上有意义的规则。对词语共现的考察已被证明是一个富有成效的研究范式。例如，Mikolov等人（2013）利用Skipgram负抽样（Skipgram NegativeSampling，SGNS）利用跨越文本语料库的窗口形成的单词上下文对来训练单词嵌入。这些向量表示最终编码显着的线性，如king-man+woman=queen。事实上，Levy和Goldberg（2014c）证明，这隐含地分解了点阵互信息（PMI）矩阵的变体，该矩阵强调预测罕见群体的频繁共现。与PMI矩阵密切相关，Pennington 等人（2014）将大型全球字数共生矩阵分解以产生比SGNS更高效且性能稍高的计算嵌入。一旦创建，这些表示就可用于信息检索（Manning等，2009）和解析任务（Levy和Goldberg，2014a）。在这项工作中，我们将利用word级表示来建立文档级抽象。 本文通过包含可解释文档表示来扩展分布式词语表示，并证明模型推理可以在自动分化框架内执行和扩展。 Model本节介绍lda2vec的模型。 我们有兴趣修改（Mikolov et al。，2013）中的Skipgram负采样（SGNS）目标，以利用文档范围的特征向量，同时学习连续的文档权重加载到主题向量。 网络架构如图1所示。在（1）中的总损失项$\iota$是Skiggram负采样损失（SGNs）$\iota_{ij}^{neg}$的总和，并且在文档权重上增加了Dirichlet似然项，$\iota^d$将在后面讨论。使用上下文向量($\overrightarrow{c_j}$)、支点字向量($\overrightarrow{w_j}$)、目标词向量($\overrightarrow{w_i}$)和负采样词向量($\overrightarrow{w_l}$)进行损失。 $$ \iota =\iota^d +\sum_{ij}\iota_{ij}^{neg} \tag{1}$$ $$\iota_{ij}^{neg} = \log_\sigma(\overrightarrow{c_j}\cdot\overrightarrow{w_l})+\sum_{l=0}^n\log_\sigma(-\overrightarrow{c_j}\cdot\overrightarrow{w_l}) \tag{2}$$ Word Representation如在Mikolov等人（2013），当它们在移动的窗口中共同出现在整个语料库中时，提取枢轴词和目标词对（j，i）。在我们的实验中，窗口在枢轴标记之前和之后包含5个标记。对于每个枢轴目标字对，枢轴字用于预测附近的目标字。每个单词用固定长度的密集分布表示向量表示，但与Mikolov等人（2013年）不同，相同的单词向量用于枢轴和目标表示。2）中所示的SGNS损失试图区分出出现在语料库中的上下文词对，从而随机抽取 “negative”词汇池。当观察到的词与边缘分布完全分离时，该损失最小化。从中得出令牌的分布是$u^β$，其中u表示由总语料库大小归一化的整体词频。除非另有说明，否则，如Mikolov等人(2013)所述，负采样功率β设为3/4，负样本数固定为n = 15。请注意，$u^0.0$的分布会从词汇中绘制负标记而没有受欢迎的概念，而与$u^1.0$成比例的分布则取自经验单字分布。与单字分布相比，$u^{3/4}$的选择稍微强调为负样本选择不常用单词。与优化softmax交叉熵（其需要对每个令牌的总体流行度进行建模）相反，负面抽样侧重于通过从语料库中的每个令牌的边际流行度中抽取负样本来有条件地学习词向量。 Document Representationslda2vec将单词和文档向量嵌入同一个空间并同时训练两个表示。通过将枢轴和文档向量相加，两个空间都可以有效地结合在一起。 Mikolov等人（2013）提供了直觉，词向量可以汇总在一起形成两个词的语义上有意义的组合。例如，Germany+airline的载体表示与Lufthansa的载体相似。我们想利用单词向量的加性来构造一个有意义的单词和文档向量。例如，如果lda2vec正在扫描文档，第j个单词是德国，则预测相邻单词如法国，西班牙和奥地利相似。但是，如果文档特别是关于航空公司，那么我们希望构建一个类似于航空公司的单词向量的文档向量。然后，不是单独预测类似于德国的令牌，而是可以对文档和主要词汇进行类似的预测，例如：Lufthansa，Condor Flugdienst和Aero Lloyd。由有意义的词向量的总和驱动，在LDA2VEC中，上下文向量被明确地设计为文档向量和词向量的总和，如（3）： $$\overrightarrow{c_j}=\overrightarrow{w_j}+\overrightarrow{d_j} \tag{3}$$ 这通过保留文档中所有单词上下文对的($\overrightarrow{d_j}$)来模拟文档范围的关系，同时仍然利用由枢轴词向量($\overrightarrow{w_j}$)和目标词($\overrightarrow{w_i}$)之间的相互作用产生的局部词间关系。文档和单词向量被汇总在一起形成一个上下文向量，分别直观地捕捉长期和短期主题。为了防止共同适应，我们也对非规范化文档向量($\overrightarrow{d_j}$)和枢轴词向量($\overrightarrow{w_j}$)进行dropout（Hinton et al。，2012）。 Document Mixtures如果我们只包含到目前为止的结构，模型将为每个文档生成一个密集的向量。 然而，lda2vec致力于形成可解释的表示，并且这样做会施加额外的约束，使得文档表示与传统的LDA模型中的相似。我们的目标是从混合主题向量生成一个文档向量，为此，我们首先约束文档向量($d_j$),投影到一组潜在的主题向量($\overrightarrow{t_0}$),($\overrightarrow{t_1}),⋯,($\overrightarrow{t_k}$): $$\overrightarrow{d_j}=p_{j0}\cdot\overrightarrow{t_0}+p_{j2}\cdot\overrightarrow{t_2}+\cdots+p_{jk}\cdot\overrightarrow{t_k}+\cdots+p_{jn}\cdot\overrightarrow{t_n} \tag{4}$$ 每个权重0≤$p_{jk}$≤1是表示主题k中文档j的隶属度的分数。 例如，稍后描述的Twenty Newsgroups 模型具有11313个文档并且k = 20个主题，所以j = 0 … 11312，k = 0 … 19。 当单词向量维数设置为300时，假设文档向量($\overrightarrow{d_j}$)，单词向量($\overrightarrow{w_i}$)和主题向量($\overrightarrow{t_k}$)都具有维度300.注意，主题向量($\overrightarrow{t_k}$)是共享的 并且是所有文档的共同组成部分，但其强度由文档权重p_jk调整。为了有助于可解释性，文档成员资格被设计为非负面的，并且归结为统一。 为了实现这个约束，softmax变换将在R^300中初始化的潜在向量映射到由$p_{jk}$定义的单纯形中。softmax变换自然会强制约束$\sum_k p_{jk} = 1$，并允许我们将成員資格解釋为百分比而非无限权重。 将（4）中的混合作为总和来保证主题向量($\overrightarrow{t_k}$)，文档向量($\overrightarrow{d_j}$)和词向量($\overrightarrow{w_i}$)在相同的空间中操作。因此，可以直接计算哪些字($\overrightarrow{w_i}$)最类似于任何给定的主题向量($\overrightarrow{t_k}$)。尽管每个主题不是字面上語料庫中存在的标记，但与其他标记的相似性是有意义的并且可以被测量。此外，通过检查最相似的单词列表，可以尝试解释该主题所代表的内容。例如，通过计算与任何主题向量（例如argma$x_i(\overrightarrow{t_0}\cdot\overrightarrow{w_i})$最相似的标记，人们可以发现第一个主题向量($\overrightarrow{t_0}$)与标记pitching，catcher和Braves相似，而第二个主题向量($\overrightarrow{t_1}$)可能与Jesus，God和faith相似。这为我们提供了将第一个主题解释为baseball主题的选项，因此每个文档比例$p_{j0}$中的第一个分量指示文档j在棒球主题中的数量。同样，第二个主题可能被解释为基督教，任何文档比例的第二个组成部分$p_{j1}$表示该文件在基督教主题中的成员身份。 Sparse Memberships最后，通过对具有低浓度参数α的Dirichlet似然优化文档权重，使文档权重$p_{ij}$被稀疏化： $$\iota^d=\lambda\sum_{jk}(\alpha-1)\log p_{jk} \tag{5}$$ 5）中的总体目标衡量文档j在主题k中概括所有可用文档的可能性。该项的强度由调整参数λ调整。当α＜1时，每一个主题中的文档比例耦合都是稀疏的，当α＞1时，这种简单的可能性会促使文档的比例耦合。为了提高可解释性，我们有兴趣寻找稀疏成员，并设置α=n^(-1)，其中n是主题。我们还发现将Dirichlet优化的整体强度设置为λ= 200的效果很好。文档比例被初始化为相对均匀，但随着时间的推移，$\iota^d$鼓励文档比例向量随着时间的推移变得更加集中（例如稀疏）。在没有这个稀疏诱导项的实验中（或者当α= 1时），文档权重$p_{ij}$倾向于在所有元素之间展开概率质量。如果没有任何稀疏性引入术语，那么许多非零权重的存在使解释文档向量变得困难。此外，我们发现话题基础也受到强烈影响，话题变得不連貫。 # of topics β Topic Coherences 20 0.75 0.567 30 0.75 0.555 40 0.75 0.553 50 0.75 0.547 20 1.00 0.563 30 1.00 0.564 40 1.00 0.552 50 1.00 0.558 图2：给出了在Twenty Newsgroups数据集中由lda2vec发现的平均主题一致性。 主题一致性已被证明与主题模型的人类评估相关（Roder等，2015）。 给出了所选主题的数量，以及负抽样指数参数β。 与β= 1.00相比，β= 0.75将更多的稀有词作为负样本。 在模型n = 20个主题和β= 0.75中找到最好的主题相关性。 Preprocessing and Training1）中的目标是一次在单独的小批量中进行训练，同时使用Adam优化器（Kingma和Ba，2014）在整个数据集中处理两百个时期。Dirichlet似然项$\iota^d$通常是在所有文档上计算的，因此在将目标修改为小批量时，我们调整术语的损失与小批量大小除以总语料库的大小成比例。我们的软件是开源的，可在线获得，记录和单元测试。最后，将给定主题中前十个最有可能的单词提交给在线Palmetto主题质量测量工具，并记录相干性测量$C_v$。在评估多个替代方案后，$C_v$是Roder等人（2015）推荐的一致性度量。此度量对外部语料库上大小为110的滑动窗口内的每对单词的归一化点互信息（NPMI）进行平均，并返回提交的单词集的NPMI平均值。使用3COSMUL度量来评估令牌到词的相似度（Levy和Goldberg，2014b）。 Topic Label “Space” “Encryption” “X Windows” “Middle East” Top tokens Astronomical Astronomy Satellite Planetary telescope Encryption Wiretap Encrypt Escrow Clipper Mydisplay Xlib,Window Cursor pixmap Armenian Lebanese Muslim Turk sy Topic Coherence 0.712 0.675 0.472 0.615 图3：由Twenty Newsgroups数据集中的lda2vec发现的主题。 推断的主题标签显示在第一行。 与该主题相似度最高的令牌将在下面显示。请注意,Twenty Newsgroups语料库包含相应的新闻组，如sci.space，sci.crypt，comp.windows.x和talk.politics.mideast。 ExperimentsTwenty Newsgroups本节详细介绍了发现二十新闻组数据集中显着主题的实验，这是一种流行的文本机器学习语料库。语料库中的每个文档都发布到二十个可能的新闻组中的一个。尽管每篇文章的文本都可用于lda2vec, 但每个新闻组分区并未显示给算法，但对于发现的主题的事后定性评估仍然有用。使用Scikit-learn（Pedregosaetal，2012）中提供的数据加载器预处理语料库，使用SpaCy解析器（Honnibal and Johnson，2015）识别令牌。单词被词组化以将多个入口组合为单个令牌。在语料库中发生少于十次的令牌被删除，标记看起来像是URL，数字或在其正文形式中包含特殊符号。预处理之后，数据集包含11,313个文档中的8946个独特标记的180万个观察值。字向量被初始化为Mikolov等人（2013）的预训练值，但在训练时允许更新这些向量。 通过改变主题数量n∈20,30,40,50和负取样指数β∈0.75,1.0来评估一系列lda2vec参数。 图2总结了n = 20个话题和负抽样功率β= 0.75的最佳话题相关性。我们简要地试验了dropout率的变化，但我们没有观察到任何实质性差异。 图3列出了在Twenty Newsgroups数据集中发现的四个示例主题。每个主题与与训练的单词向量相同的空间中存在的主题向量相关联，并且列出的是与每个主题向量最相似的词。所显示的第一个主题与令牌astronomical, Astronomy, satellite, planetary, and telescope有很高的相似性，因此可能是与’sci.space’新闻组类似的’Space’相关主题。第二个示例主题类似于语义上与’Encryption’相关的单词，例如Clipper和encrypt，并且可能与’sci.crypt’新闻组相关。第三和四个示例主题是“X Windows”和“Middle East”，可能属于“comp.windows.x”和“talk.politics.mideast”新闻组。 Hacker News Comments corpus这部分评估lda2vec在一个非常大的黑客新闻评论语料库上。黑客新闻是社交内容投票网站和社区，主要关注技术和创业。在这个语料库中，单个文档由发布到单个文章的所有评论中的所有单词组成。只包含超过10条评论的报道，并且仅包含评论超过10条的用户的评论。我们忽略其他元数据，如投票，时间戳和作者身份。原始数据集4可在线下载。语料库几乎是二十新闻组语料库的大小，足以学习专业词汇。为了利用这个丰富的语料库，我们使用SpaCy来一次标记整个名词短语和实体（Honnibal and Johnson，2015）。特定的标记过程也可以在线获得，预处理的数据集结果也是如此。这使我们能够捕捉诸如community policing measure等短语以及像Steve Jobs这样的突出数据作为单一的令牌。然而，这种标记化过程会生成一个与Palmetto主题一致性工具中可用的词汇完全不同的词汇，因此我们不会在此语料库上报告主题一致性。经过预处理，该语料库包含75万个令牌，在66万个文档中有11万个独特的令牌。与Twenty Newsgroups分析不同，词向量是随机初始化的，而不是使用预训练向量库。 “Housing Issues” “Internet Portals” “Bitcoin” “Compensation” “Gadget Hardware” more housing basic income new housing house prices short-term rentals DDG. Bing Google+ DDG iGoogle Btc Bitcoins Mt. Gox MtGox Gox current salary more equity vesting equity vesting schedule the Surface Pro HDMI glossy screens Mac Pro Thunderbolt 图4：Hacker News评论数据集中由lda2vec发现的主题。 推断的主题标签显示在第一行。 我们从名词短语中形成令牌，以捕捉这个专用语料库的独特词汇。 Artiﬁcial sweeteners Black holes Comic Sans Functional Programming San Francisco Glucose Fructose sugars sugar Soylent Paleo diet diet carbohydrates Particles Consciousness quantum mechanics universe dark matter Big Bang Planets entanglement Typeface Arial Times New Roman Font new logo Anonymous Pro Baskerville serif font FP Haskell functional languages monads Lisp Clojure category theory OO New York Palo Alto New York City SF Mountain View Seattle Los Angeles Boston 图5：给出顶行中的示例标记，报告Hacker News评论语料库中最相似的单词。 我们使用40个主题和256个隐藏单元来训练lda2vec模型，并报告学习的主题，以演示语料库中存在的主题。 此外，我们证明了向这个语料库指定的词向量和语义关系是学习到的。 在图4中列出了Hacker News语料库中lda2vec发现的示例主题。这些主题表明，语料库的主要主题以与LDA类似的方式在学习的主题向量中得以再现和表示（Blei et al。，2003）。第一个是我们对Housing Issues(房屋问题)的标签，其中涉及到住房政策问题，如住房供应（例如more housing）和成本（如basic income 和 house prices）。另一个主题列出了主要的internet portals（互联网门户），例如隐私意识搜索引擎“Duck Duck Go”（在语料库中缩写为DDG），以及其他主要搜索引擎（例如Bing）和主页（例如Google+和iGoogle）。第三个话题是流行的在线货币和支付系统Bitcoin（比特币），货币btc的缩写形式以及现已解散的比特币交易平台Mt. GOX。第四个主题是考虑薪酬和compensation，包括current salary(当前的薪水)，more equity(更多的股权)和vesting(归属)，以及雇员从其雇主那里获得股票的过程。第五个示例主题是HDMI和glossy screens等技术硬件(hardware)，并且包含诸如Surface Pro和Mac Pro等设备。 图5表明，标记的相似性以与SGNS类似的方式学习（Mikolov et al。，2013），但专门用于Hacker News语料库。与令牌人Artiﬁcial sweeteners类似的令牌包括其他与sugar有关的令牌，如fructose和与食物相关的令牌，如古饮食。与Black holes相似的标记包括物理相关的概念，如星系和暗物质。黑客新闻语料库将大量文本用于字体和设计，最类似于comic Sans的单词是其他流行字体（例如Times New Roman和Helvetica）以及与字体相关的概念，如Typeface和serif font。与Functional Programming类似的令牌与其他计算机科学相关的令牌相似，而类似于San Francisco的令牌包括其他大型美国城市以及位于旧金山(San Francisco)湾区的小城市。 Query Result California + technology Silicon Valley digital + currency Bitcoin Javascript - browser + server Node.js Mark Zuckerberg - Facebook + Amazon Jeff Bezos NLP - text + image computer vision Snowden - United States + Sweden Assange Surface Pro - Microsoft + Amazon Kindle 图6：Hacker News评论数据集中由lda2vec发现的示例线性关系。 第一列表示示例输入查询，第二列表示与输入最相似的标记。 图6表明，除了学习文档的主题以及与词语标记的相似之外，词汇之间的线性规律也被学习到。 “Query”列列出了一系列令牌，这些令牌在组合时会产生与“Result”列中显示的令牌最接近的令牌向量。字面上对矢量的减法和增加进行评估，而是利用3COSMUL目标（Levy和Goldberg，2014b）。结果表明，令牌向量之间存在与黑客新闻社区重要的令牌之间的关系。例如，Silicon Valley(硅谷)的向量与California（加利福尼亚）和Technical（技术）类似，Bitcoin（比特币）确实是一种digital currency（数字货币），Node.js是一种能够在server（服务器）上运行Javascript而不是在客户端browsers（浏览器）上运行Javascript的技术，Jeff Bezos和Mark Zuckerber分别是Amazon（亚马逊）和Facebook的首席执行官，NLP和compute vision（计算机视觉）分别是机器学习研究领域，主要分别处理Text(文本)和Images(图像)，Edward Snowden(爱德华斯诺登)和Julian Assange(朱利安阿桑奇)都是举报者，他们主要位于United states(美国)和Sweden(瑞典)，最终Kindle和Surface Pro都是平板电脑分别由Amazon(亚马逊)和Microsoft(微软)制造。在上述示例中，令牌之间的语义关系对属性和特征进行编码，包括：位置，货币，服务器v.s.客户，领导力数据，机器学习领域，政治数据，国籍，公司和硬件。 Conclusion这项工作演示了一个简单的模型lda2vec，它扩展了SGNS（Mikolov et al。，2013），以构建无监督的文档表示，从而产生连贯的主题。将词，主题和文档向量联合训练并嵌入到共同表示空间中，该空间保留学习词向量之间的语义规则性，同时仍然以LDA的风格产生稀疏且可解释的文档 - 主题比例（Blei等，2003 ）。。在Twenty Newsgroups语料库中形成的主题产生了高度的平均主题一致性，这些主题一致性已被证明与人类主题评估相关（Roder等，2015）。当应用到Hacker News comments语料库时，lda2vec发现了该社区内的显着话题，并且学习了单词之间的线性关系，从而可以在该语料库的专业词汇表中解决单词类比问题。最后，我们注意到，我们的方法在自动微分框架中实现是简单的，并且可以导致更容易解释的无监督表示。]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>recommendation</tag>
        <tag>clustering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DKN:Deep Knowledge-Aware Network for News Recommendation]]></title>
    <url>%2F2018%2F08%2F27%2FDKN-Deep-Knowledge-Aware-Network-for-News-Recommendation%2F</url>
    <content type="text"><![CDATA[用知识图谱表示，结合CNN，利用attention module帮助识别用户的多兴趣，进行新闻推荐 论文地址:https://arxiv.org/abs/1801.08284 参考：Qiu Fengyu ABSTRACT在线新闻推荐系统主要解决新闻信息过载的问题，同时尽可能提升用户的使用体验，注重个性化。一般来说，新闻的语言是高度凝练的，有许多命名实体，并且包含了很多的常识。目前现有的一些推荐算法不关注、或者说无法理解新闻中的一些“知识”以及我们所了解的常识，仅仅通过一些简单的模式匹配、主题相关进行机械的推荐，不具有理论上的扩展性。此外，新闻具有时效性的特征，用户的口味也会 随着时间变化，为解决这些问题，本文提出了 DKN 模型，将知识图谱表示融入新闻推荐中。DKN 是一个预测点击率的基于内容的深度推荐模型。DKN 的核心是一个多通道、命名实体对齐的、融合了知识的卷积神经网络（KCNN），从语义和知识层面上来表示新闻。KCNN 把新闻中的词和实体作为通道（channel），并且在卷积过程中显式地监督两者的对齐关系。为了处理用户喜好的多样性，加入了 Attention 动态地对用户阅读历史进行加权，选择候选新闻。在大量的相关实验中，取得了最好的结果。 KEYWORDS新闻推荐，知识图谱表示，深度神经网络，注意力模型 INTRODUCTION随着网络的发展，现在人们阅读新闻的习惯已经从传统的纸媒、电视转向网络，如Google News和Bing News在线新闻网站，收集各种各样的新闻资源提供给读者。网络新闻平台的一个常见问题是，文章的数量可能会被淹没，从而减轻信息过载的影响，从而帮助读者获取阅读兴趣并提出个性化建议。 总的来说，新闻推荐更为突出的主要有以下三个挑战： 跟电影和酒店相比，新闻具有很强的时间敏感性，容易过期，过时的新闻很快就会被更新的新闻所取代。从而传统基于 ID 的协同过滤方法就很有限了； 用户在阅读新闻的时候是话题敏感的，通常对多个话题都具有倾向性。如何从多种多样的阅读记录中，对用户的多种主题偏好信息进行动态表示，是新闻推荐系统做好的关键； 新闻文本语言高度凝练，还包含了大量的知识实体和常识。 如图1所示，一个用户点击一个标题为“Boris Johnson Has Warned Donald Trump To Stick To The Iran Nuclear Deal”的新闻，其中包含四个实体：“Boris Johnson”,“Donald Trump”, “Iran” and “Nuclear”，事实上，该用户对另外一个新闻（“North Korean EMP Attack Would Cause Mass U.S. Starvation, Says Congressional Report”）也感兴趣，跟上一个联系跟紧密是因为常识。经典的语义模型或者主题模型，都是从词的共现信息或词聚类结构上挖掘新闻之间的关系，仅仅抓住了语义信息，从而给用户的新闻推荐就会变窄，局限在一个话题中。而本文提出的 DKN 能够从中挖掘新闻之间的潜在知识层面上的联系，引入知识图谱中的信息，是一种十分合理的扩展。 为了提取新闻之间深度逻辑关系，将知识图谱引入新闻推荐很有必要。知识图是一种有向异构图，其中节点对应于实体，边对应于关系。 最近，研究人员已经提出了一些学术知识图谱，如NELL,DBpedia,Google Knowledge Graph 和Microsoft Satori.这些知识图谱都成功的应用于机器阅读，文本分类和词嵌入。 考虑到之前提到的新闻推荐的挑战以及知识图谱的广泛成功应用，本文我们提出利用知识图谱做新闻推荐的新的框架（deep knowledge-awarenetwork， DKN）与传统的协同过滤方法不同的是，DKN 是一种基于内容的 CTR（点击率）预测模型：给定一个候选新闻和用户之前的浏览历史，预测用户点击候选新闻的概率。在 DKN 中的主要步骤： 对新闻中的每个词都在知识图谱中找到对应的实体来扩展它的信息，使用他的邻居实体来增强新闻的知识层面的信息。 设计DKN的关键部分knowledge-aware convolutional neural networks (KCNN), 把新闻词和知识层次的信息表示为知识感知嵌入向量。 KCNN 是多个通道的，新闻输入与图像的 RGB 通道类似，这里的通道包含了新闻中词的嵌入（embedding），实体的嵌入及相关实体的嵌入； 词语-实体对齐信息，把一个词和对应的实体在多个通道内进行对齐，通过某种转换函数（映射）来消除词向量和实体向量空间的异构性。或者可以这样理解，KCNN 保证了多个通道内词语的表示的一致性，并且显式地减少不同 embedding 空间的隔阂。 通过 KCNN，得到的新闻知识感知表示向量，候选新闻与用户点击过的新闻通过 attention，加权一个用户的历史新闻得到用户的嵌入表示。用户的嵌入表示和候选新闻的嵌入表示最后通过 DNN 来计算候选新闻被用户点击的概率。 最终，本文提出的 DKN 模型在 Bing News 推荐上得到了显著的性能提升。DKN显著优于基线在F1上的2.8%到17%和AUC的2.6%到16.1%，显著水平为0.1。 提出的注意力机制也可以带来3.5%和1.4%的提高。 PRELIMINARIES这部分介绍本文相关的概念和模型，包括知识图谱嵌入和句子表示的卷积神经网络。 Konowledge Graph Embedding]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>recommendation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[891.Sum of Subsequence Widths]]></title>
    <url>%2F2018%2F08%2F20%2F891-Sum-of-Subsequence-Widths%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between themaximum and minimum element of S. Return the sum of the widths of all subsequences of A. As the answer may be very large, return the answer modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/sum-of-subsequence-widths/description/ Difficulty: hard Example 1:Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6. Note: 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= 20000 分析 将integers A排序 n=3时，形如A=[1,2,3],index=(4-1)*(3-1)=6 n=4时，形如A=[1,2,3,4],index=(8-1)(4-1)+(4-2)(3-2)=23 n=5时，形如A=[1,2,3,4,5],index=(16-1)(5-1)+(8-2)(4-2)=72 总结规律如下 $$index=\sum_{i=0}^{length/2}{(2^{length-1-i}-2^i)*(A[length-1]-A[i])}$$ 参考代码class Solution: def sumSubseqWidths(self, A): length=len(A) if(length==1): return 0 if(length==2): return abs(A[0]-A[1]) p1=length-1 p2=0 P1=2**(length-1) P2=2**0 index=0 A.sort() mod=10**9+7 while(p1&gt;p2): index+=((P1-P2)*(A[p1]-A[p2])) index%=mod p1-=1 p2+=1 P1//=2 P2*=2 return index 64 / 64 test cases passed. Runtime: 1224 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[890.Find and Replace Pattern]]></title>
    <url>%2F2018%2F08%2F20%2F890-Find-and-Replace-Pattern%2F</url>
    <content type="text"><![CDATA[DescriptionYou have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern. You may return the answer in any order. 题目链接：https://leetcode.com/problems/find-and-replace-pattern/description/ Difficulty: medium Example 1:Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot; Output: [&quot;mee&quot;,&quot;aqq&quot;] Explanation: &quot;mee&quot; matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}. &quot;ccc&quot; does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation, since a and b map to the same letter. Note: 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 分析 word与pattern匹配就是一种特殊的相等关系，每个字母是唯一的对应关系； 注意，每个字母只能对应一个，所以，定义两个字典，分别存储key-value和value-key的对应； 定义比较函数judge(a,b)，a=’mee’,b=’aqq’,生成两个字典，{m:a,e:q}和{a:m,q:e},如果相等返回True，反之False。 参考代码class Solution: def findAndReplacePattern(self, words, pattern): def judge(a,b): db={} da={} for i in range(len(a)): if(b[i] in db): if(db[b[i]]!=a[i]): return False else: db[b[i]] = a[i] if(a[i] in da): if(da[a[i]]!=b[i]): return False else: da[a[i]]=b[i] return True li=[] for word in words: if(judge(word,pattern)): li.append(word) return li 46 / 46 test cases passed. Runtime: 60 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[889.Construct Binary Tree from Preorder and Postorder Traversal]]></title>
    <url>%2F2018%2F08%2F20%2F889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[DescriptionReturn any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. 题目链接：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/ Difficulty: medium Example 1:Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note: 1 &lt;= pre.length == post.length &lt;= 30 pre[] and post[] are both permutations of 1, 2, …, pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. 分析 根据先序遍历pre和后续遍历post构建二叉树，常规递归方法； 递归的结束条件是：pre长度为0返回None，长度为1，返回TreeNode(pre[0]) pre[0]作为当前过程的根节点，pre[1:indexof(pre[1])+2]作为左子树先序，post[:indexof(pre[1])+1]作为左子树后序，pre[indexof(pre[1])+2:]作为右子树先序，post[indexof(pre[1])+1：-1]作为右子树后序； 如例：{[2,4,5],[4,5,2]}为左子树，{[3，6，7],[6,7,3]}为右子树，indexof(pre[1])为pre[1] (2)在post中的位置，为：2 以此类推 参考代码#Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def constructFromPrePost(self, pre, post): if(len(pre)==0): return None if(len(pre)==1): return TreeNode(pre[0]) head=TreeNode(pre[0]) index=post.index(pre[1]) left=self.constructFromPrePost(pre[1:2+index], post[:index+1]) right=self.constructFromPrePost(pre[2+index:], post[index+1:-1]) head.left=left head.right=right return head 306 / 306 test cases passed. Runtime: 56 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[888.Fair candy Swap]]></title>
    <url>%2F2018%2F08%2F20%2F888-Fair-candy-Swap%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed an answer exists. 题目链接：https://leetcode.com/problems/fair-candy-swap/description/ Difficulty: easy Example 1:Input: A = [1,1], B = [2,2] Output: [1,2] Example 2:Input: A = [1,2], B = [2,3] Output: [1,2] Example 3:Input: A = [2], B = [1,3] Output: [2,3] Example 4:Input: A = [1,2,5], B = [2,4] Output: [5,4] Note: 1 &lt;= A.length &lt;= 10000 1 &lt;= B.length &lt;= 10000 1 &lt;= A[i] &lt;= 100000 1 &lt;= B[i] &lt;= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer. 分析 交换一个candy使得两个人的candy总数相等，只需要交换的两个candy的差值为两个人的candy的总和的差值的一半（index）即可； 遍历A，存入set，为了搜索快； 遍历B，每一项加上index在set中，即使所需交换的两个candy。 参考代码class Solution: def fairCandySwap(self, A, B): sumA=sum(A) sumB=sum(B) index=(sumB-sumA)//2 bSet=set() for b in B: bSet.add(b) for i in A: if(i+index in bSet): return [i,i+index] return [0,0] 75 / 75 test cases passed. Runtime: 76 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
</search>
