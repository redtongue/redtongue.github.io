<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四则运算表达式求值（利用前缀后缀表达式）]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%EF%BC%88%E5%88%A9%E7%94%A8%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[中缀表达式中缀表达式就是常见的运算表达式，如(3+4)*5-6 前缀表达式前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前 比如:- * + 3 4 5 6 前缀表达式的计算机求值从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时， 弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素）， 并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例子（- * + 3 4 5 6） 从右至左扫描，将6、5、4、3压入堆栈 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈 接下来是*运算符，因此弹出7和5，计算出7×5=35，将35入栈 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 将中缀表达式转换为前缀表达式 初始化两个栈:运算符栈s1，储存中间结果的栈s2 从右至左扫描中缀表达式 遇到操作数时，将其压入s2 遇到运算符时，比较其与s1栈顶运算符的优先级 如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较 遇到括号时 如果是右括号“)”，则直接压入s1 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最左边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式 具体过程例如:1+((2+3)*4)-5具体过程，如下表 扫描到的元素 S2 S1 说明 5 5 空 数字，直接入栈 - 5 - s1为空，运算符直接入栈 ) 5 -) 右括号直接入栈 4 54 -) 数字，直接入栈 * 54 -)* s1栈顶是右括号，直接入栈 ) 54 -)*) 右括号直接入栈 ) 5 4 -)x) 右括号直接入栈 3 5 4 3 -)x) 数字 + 5 4 3 -)x)+ s1栈顶是右括号，直接入栈 2 5 4 3 2 -)x)+ 数字 ( 5 4 3 2 + -)x 左括号，弹出运算符直至遇到右括号 ( 5 4 3 2 + * - 同上 + 5 4 3 2 + * -+ 优先级与-相同，入栈 1 5 4 3 2 + * 1 -+ 数字 到达最左端 5 4 3 2 + * 1 + - 空 s1剩余运算符 结果是:- + 1 × + 2 3 4 5后缀表达式后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 后缀表达式计算机求值与前缀表达式类似，只是顺序是从左至右： 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数， 用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈； 重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例子（3 4 + 5 * 6 -） 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 将中缀表达式转换为后缀表达式 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）； 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1； 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃； 重复步骤2至5，直到表达式的最右边； 将s1中剩余的运算符依次弹出并压入s2； 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序） 具体过程例如，将中缀表达式“1+((2+3)*4)-5”转换为后缀表达式的过程如下： 扫描到的元素 S2 S1 说明 1 1 空 数字，直接入栈 + 1 + s1为空，运算符直接入栈 ( 1 + ( 左括号，直接入栈 ( 1 + ( ( 同上 2 1 2 + ( ( 数字 + 1 2 + ( ( + s1栈顶为左括号，运算符直接入栈 3 1 2 3 + ( ( + 数字 ) 1 2 3 + + ( 右括号，弹出运算符直至遇到左括号 * 1 2 3 + + ( * s1栈顶为左括号，运算符直接入栈 4 1 2 3 + 4 + ( * 数字 ) 1 2 3 + 4 * + 右括号，弹出运算符直至遇到左括号 - 1 2 3 + 4 * + - -与+优先级相同，因此弹出+，再压入- 5 1 2 3 + 4 * + 5 - 数字 到达最右端 1 2 3 + 4 * + 5 - 空 s1中剩余的运算符 因此结果为“1 2 3 + 4 × + 5 -”备注参考 https://www.cnblogs.com/chensongxian/p/7059802.html 代码是自己有python搞得，transform可以去除空格，一般题目里面有这样的需求。 源代码class Solution: def calculator(self,s): li=self.transform(s) print(&apos;li&apos;,li) forward=self.forward(li) print(&quot;forward&quot;,forward) result1=self.calForward(forward) print(&quot;result1:&quot;,result1) back=self.back(li) print(&quot;back&quot;,back) result2=self.calBack(back) print(&quot;result2:&quot;,result2) def calBack(self,back):#计算后缀表达式 s=[] for i in range(len(back)): if(isinstance(back[i],int)): s.append(back[i]) else: b=s.pop() a=s.pop() s.append(self.cal(a,b,back[i])) if(len(s)==0): return None return s[-1] def back(self,li):#得到后缀表达式 s1=[] s2=[] for i in range(len(li)): if(isinstance(li[i],int)):#li[i]是数字 s2.append(li[i]) elif(li[i] in &apos;+-*/&apos;):#li[i]是运算符 while(True): if(len(s1)==0 or s1[-1]==&apos;(&apos;):#s1为空或栈顶为‘(’，压栈 s1.append(li[i]) break elif(self.get(li[i])&gt;self.get(s1[-1])):#优先级大于等于栈顶，压栈 s1.append(li[i]) break else:#s1的栈顶元素压入s2，重复上述步骤 s2.append(s1.pop()) else: if(li[i]==&apos;(&apos;):#右括号压栈 s1.append(li[i]) else:#左括号，将s1栈顶元素压入s2，直至遇到右括号 tar=s1.pop() while(tar!=&apos;(&apos;): s2.append(tar) tar=s1.pop() while(s1): s2.append(s1.pop()) return s2 def calForward(self,forward):#计算前缀表达式 s=[] for i in range(len(forward)): if(isinstance(forward[i],int)): s.append(forward[i]) else: a=s.pop() b=s.pop() s.append(self.cal(a,b,forward[i])) if(len(s)==0): return None return s[-1] def forward(self,li):#得到前缀表达式 s1=[] s2=[] for i in range(len(li)-1,-1,-1): if(isinstance(li[i],int)):#li[i]是数字 s2.append(li[i]) elif(li[i] in &apos;+-*/&apos;):#li[i]是运算符 while(True): if(len(s1)==0 or s1[-1]==&apos;)&apos;):#s1为空或栈顶为‘）’，压栈 s1.append(li[i]) break elif(self.get(li[i])&gt;=self.get(s1[-1])):#优先级大于等于栈顶，压栈 s1.append(li[i]) break else:#s1的栈顶元素压入s2，重复上述步骤 s2.append(s1.pop()) else: if(li[i]==&apos;)&apos;):#右括号压栈 s1.append(li[i]) else:#左括号，将s1栈顶元素压入s2，直至遇到右括号 tar=s1.pop() while(tar!=&apos;)&apos;): s2.append(tar) tar=s1.pop() while(s1): s2.append(s1.pop()) return s2 def transform(self,s):#转换字符串，得到数字和运算符的链表形式 li=[] judge=False index=0 for tar in s: if(tar==&apos; &apos;): continue elif(tar in &apos;+-*/()&apos;): if(judge): li.append(index) judge=False index=0 li.append(tar) else: index=index*10+int(tar) judge=True if(judge): li.append(index) return li def cal(self,a,b,ch):#计算 if(ch==&apos;+&apos;): return a+b elif(ch==&apos;-&apos;): return a-b elif(ch==&apos;*&apos;): return a*b elif(ch==&apos;/&apos;): return a/b else: return 0 def get(self,ch):#得到优先级 if(ch in &apos;+-&apos;): return 1 elif(ch in &apos;*/&apos;): return 3 else: return 0]]></content>
      <categories>
        <category>whatever</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[928.Minmize Malware Spread II]]></title>
    <url>%2F2018%2F10%2F23%2F928-Minmize-Malware-Spread-II%2F</url>
    <content type="text"><![CDATA[Description(This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. 题目链接：https://leetcode.com/problems/minimize-malware-spread-ii/ Difficulty: hard Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0 Example 2:Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1 Example 3:Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1 Note: 1 &lt; graph.length = graph[0].length &lt;= 300 0 &lt;= graph[i][j] == graph[j][i] &lt;= 1 graph[i][i] = 1 1 &lt;= initial.length &lt; graph.length 0 &lt;= initial[i] &lt; graph.length 分析 定义dfs（index,po）为深度遍历函数，返回新感染的结点总数，self.gra存储每个结点的感染状态（1为感染，0为未感染）po是与Minmize Malware Spread不同的地方，存储了当前去除的感染点，那么后面深度遍历是，所有与他相连的点是忽略的，具体的忽略做法是：index-j的边若包含po，则不进行下一步感染； dfs从初始结点i开始，遍历所有剩下结点j，若graph[i][j]==1(i,j相连)，则j被感染，以j为初始结点，进入下一层深度遍历，直至所有相连结点都被感染； 遍历initial，即去除当前结点i的感染状态，初始化self.gra，遍历除了i结点外initial中所有结点，作为初始结点，深度遍历，返回新感染的结点个数； 得到返回新感染节点个数最小的对应的去除的结点，即使需要得到的结果； 题目中要求返回最小的结点序号，可以对initial排序之后再处理。 参考代码class Solution: def minMalwareSpread(self, graph, initial): length=len(graph[0]) def dfs(index,po): s=0 for j in range(length): if(index != j): if(j != po and graph[index][j]==1 and self.gra[j]==0): self.gra[j]=1 s+=(dfs(j,po)+1) return s index =length initial.sort() target=initial[0] for i in initial: self.gra=[0]*length for tar in initial: if(tar!=i): self.gra[tar]=1 curr=0 for tar in initial: if(tar!=i): curr+=dfs(tar,i) if(curr &lt; index): target=i index=curr return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[927.Three Equal Parts]]></title>
    <url>%2F2018%2F10%2F23%2F927-Three-Equal-Parts%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 &lt; j, such that: A[0], A[1], …, A[i] is the first part;A[i+1], A[i+2], …, A[j-1] is the second part, andA[j], A[j+1], …, A[A.length - 1] is the third part.All three parts have equal binary value.If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value. 题目链接：https://leetcode.com/problems/three-equal-parts/ Difficulty: hard Example 1:Input: [1,0,1,0,1] Output: [0,3] Example 2:Input: [1,1,0,1,1] Output: [-1,-1] Note: 3 &lt;= A.length &lt;= 30000 A[i] == 0 or A[i] == 1 分析 i,j将数组分为三个部分a1,a2,a3，通过向后移动i或者向前移动j来判断三部分的值是否相等； 其中移动的i或j的判断依据是移动ij之后对应的a1和a3大小关系，哪个小就移动哪个，我考虑的是移动较小的可以更准确的逼近准确值，相等时，移动i； 直至a1=a2=a3返回[i,j],否则若i+1&lt;j返回[-1,-1]。 参考代码class Solution: def threeEqualParts(self, A): i=0 j=len(A)-1 a1=A[i] a2=0 s=0 s+=a1 for posi in range(1,len(A)-1): a2*=2 if(A[posi]==1): a2+=1 s+=1 a3=A[j] s+=a3 if(s%3!=0): return [-1,-1] index=2 indexP=2**(len(A)-3) while(i+1&lt;j): if(a1==a2==a3): return [i,j] if(a1&gt;a2 or a3&gt;a2): return [-1,-1] if(((a1&lt;&lt;1)+A[i+1]) &gt; (index*A[j-1]+a3)): a3+=index*A[j-1] index=index&lt;&lt;1 a2=a2&gt;&gt;1 indexP=indexP&gt;&gt;1 j-=1 else: a1=(a1&lt;&lt;1)+A[i+1] a2-=(indexP*A[i+1]) indexP=indexP&gt;&gt;1 i+=1 return [-1,-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[926.Flip String to Monotone Increasing]]></title>
    <url>%2F2018%2F10%2F23%2F926-Flip-String-to-Monotone-Increasing%2F</url>
    <content type="text"><![CDATA[DescriptionA string of ‘0’s and ‘1’s is monotone increasing if it consists of some number of ‘0’s (possibly 0), followed by some number of ‘1’s (also possibly 0.) We are given a string S of ‘0’s and ‘1’s, and we may flip any ‘0’ to a ‘1’ or a ‘1’ to a ‘0’. Return the minimum number of flips to make S monotone increasing. 题目链接：https://leetcode.com/problems/flip-string-to-monotone-increasing/ Difficulty: medium Example 1:Input: &quot;00110&quot; Output: 1 Explanation: We flip the last digit to get 00111. Example 2:Input: &quot;010110&quot; Output: 2 Explanation: We flip to get 011111, or alternatively 000111. Example 3:Input: &quot;00011000&quot; Output: 2 Explanation: We flip to get 00000000. Note: 1 &lt;= S.length &lt;= 20000 S only consists of ‘0’ and ‘1’ characters. 分析 由题意知，需要将字符串变为前半部分为0后半部分为1的最小变换次数； 记录所有0和1出现的次数，变换次数初始化为其中的最小值； 定义x为前半部分出现1的次数，y为后半部分出现0的次数，变换次数m等于x+y; 遍历s，若当前位置为1则x+=1，反之y-=1，更新m的最小值； 返回m。 参考代码class Solution: def minFlipsMonoIncr(self, S): s0=0 s1=0 for i in S: if(i==&apos;0&apos;): s0+=1 else: s1+=1 m=min(s0,s1) x1=0 y0=s0 for i in S: m=min(m,x1+y0) if(i==&apos;1&apos;): x1+=1 else: y0-=1 return m]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[925.Long Pressed Name]]></title>
    <url>%2F2018%2F10%2F23%2F925-Long-Pressed-Name%2F</url>
    <content type="text"><![CDATA[DescriptionYour friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. 题目链接：https://leetcode.com/problems/long-pressed-name/ Difficulty: easy Example 1:Input: name = &quot;alex&quot;, typed = &quot;aaleex&quot; Output: true Explanation: &apos;a&apos; and &apos;e&apos; in &apos;alex&apos; were long pressed. Example 2:Input: name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot; Output: false Explanation: &apos;e&apos; must have been pressed twice, but it wasn&apos;t in the typed output. Example 3:Input: name = &quot;leelee&quot;, typed = &quot;lleeelee&quot; Output: true Example 4:Input: name = &quot;laiden&quot;, typed = &quot;laiden&quot; Output: true Explanation: It&apos;s not necessary to long press any character. Note: name.length &lt;= 1000 typed.length &lt;= 1000 The characters of name and typed are lowercase letters. 分析 由题意知，由于长按导致的情况是某一个字母出现的次数变多，且是连续的，定义一个get用于返回连续的字母及其出现的次数，形如get(“aaleex”)-&gt;[(‘a’,2),(‘l’,1),(‘e’,2),(‘x’,1)] 若name和typed都为空则返回True； 若get(name)和get(typed)的长度不一致，返回False； 反之，若每一项中get(typed)的次数大于等于get(name)，则返回True，反之False。 参考代码class Solution: def isLongPressedName(self, name, typed): def get(s): if(len(s)==0): return [] li=[] tar=s[0] index=0 for i in s: if(i!=tar): li.append((tar,index)) index=0 tar=i else: index+=1 return li l1=get(name) l2=get(typed) if(len(l1)==0 and len(l2)==0): return True if(len(l1) == len(l2)): for i in range(len(l1)): if(l1[i][0]==l2[i][0] and l1[i][1]&lt;=l2[i][1]): continue else: return False return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[924.Minimize Malware Spread]]></title>
    <url>%2F2018%2F10%2F14%2F924-Minimize-Malware-Spread%2F</url>
    <content type="text"><![CDATA[DescriptionIn a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread. 题目链接：https://leetcode.com/problems/minimize-malware-spread/description/ Difficulty: hard Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0 Example 2:Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0 Example 3:Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1 Note: 1 &lt; graph.length = graph[0].length &lt;= 300 0 &lt;= graph[i][j] == graph[j][i] &lt;= 1 graph[i][i] = 1 1 &lt;= initial.length &lt; graph.length 0 &lt;= initial[i] &lt; graph.length 分析 定义dfs（index）为深度遍历函数，返回新感染的结点总数，self.gra存储每个结点的感染状态（1为感染，0为未感染）； dfs从初始结点i开始，遍历所有剩下结点j，若graph[i][j]==1(i,j相连)，则j被感染，以j为初始结点，进入下一层深度遍历，直至所有相连结点都被感染； 遍历initial，即去除当前结点i的感染状态，初始化self.gra，遍历除了i结点外initial中所有结点，作为初始结点，深度遍历，返回新感染的结点个数； 得到返回新感染节点个数最小的对应的去除的结点，即使需要得到的结果； 题目中要求返回最小的结点序号，可以对initial排序之后再处理。 参考代码class Solution: def minMalwareSpread(self, graph, initial): length=len(graph[0]) def dfs(index): s=0 for j in range(length): if(index != j): if(graph[index][j]==1 and self.gra[j]==0): self.gra[j]=1 s+=(dfs(j)+1) return s index =length initial.sort() target=initial[0] for i in initial: self.gra=[0]*length for tar in initial: if(tar!=i): self.gra[tar]=1 curr=0 for tar in initial: if(tar!=i): curr+=dfs(tar) if(curr &lt; index): target=i index=curr return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[923.3Sum With Multiplicity]]></title>
    <url>%2F2018%2F10%2F14%2F923-3Sum-With-Multiplicity%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an integer array A, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/3sum-with-multiplicity/description/ Difficulty: medium Example 1:Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation: Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times. Example 2:Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation: A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways. Note: 3 &lt;= A.length &lt;= 3000 0 &lt;= A[i] &lt;= 100 0 &lt;= target &lt;= 300 分析 如果直接在A中选取三个数字，然后计算和是否为target的话，时间复杂度为 $O(n^3)$ 对A进行压缩计数，得到{1:2,2:2,3:3,4:2,5:2}(如例一) 从[1,2,3,4,5]中选取三个数，但是每个数被选中的次数不能超过它在A中出现的次数（在judge函数中实现，judge(a,b)相当于从b个中选取a个的可能性） 三层循环得到三个数字，如和为target，则返回所有数字出现的可能性的乘积，即当前数字的可能的组合个数； 反之，继续； 返回所有满足条件的组合总数。 参考代码class Solution: def threeSumMulti(self, A, target): import collections count=collections.Counter(A) s=0 def judge(a,b): if(a&gt;b): return 0 s=1 for i in range(b,a,-1): s*=i for i in range(2,b-a+1): s//=i return s li=list(count.keys()) for i in range(len(li)): for j in range(i,len(li)): for k in range(j,len(li)): index1=li[i] index2=li[j] index3=li[k] if(index1+index2+index3!=target): continue countIndex=collections.Counter([index1,index2,index3]) curr = 1 for index in countIndex: curr*=judge(countIndex[index],count[index]) s+=curr s%=(10**9+7) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[922.Sort Array By Parity II]]></title>
    <url>%2F2018%2F10%2F14%2F922-Sort-Array-By-Parity-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition. 题目链接：https://leetcode.com/problems/sort-array-by-parity-ii/description/ Difficulty: easy Example 1:Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Note: 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 分析 由题意知，是为了使得list中每个数与对应的下标的奇偶性一致； 遍历list，如当前位置的数与下标的奇偶性一致，则继续； 反之，往后寻找一个数字的奇偶性与当前下标的奇偶性一致的数，交换两个数的位置； 小改进：往后找的时候，去找数字的奇偶性与它对应的下标奇偶性不一致的数字，减少后续比较的次数，代码中是当时做的时候写的，没有体现这一点，但是也AC了。 参考代码class Solution: def sortArrayByParityII(self, A): for i in range(len(A)): j=i+1 if((A[i]%2)==(i%2)): continue while(j&lt;len(A)): if((A[j]%2)==(i%2)): A[i],A[j]=A[j],A[i] break j+=1 return A]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[921.Minunum Add to Make Parentheses Valid]]></title>
    <url>%2F2018%2F10%2F14%2F921-Minunum-Add-to-Make-Parentheses-Valid%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string S of ‘(‘ and ‘)’ parentheses, we add the minimum number of parentheses ( ‘(‘ or ‘)’, and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. 题目链接：https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/description/ Difficulty: medium Example 1:Input: &quot;())&quot; Output: 1 Example 2:Input: &quot;(((&quot; Output: 3 Example 3:Input: &quot;()&quot; Output: 0 Example 4:Input: &quot;()))((&quot; Output: 4 Note: S.length &lt;= 1000 S only consists of ‘(‘ and ‘)’ characters. 分析 括号匹配问题，如果“（”先出现，则后面后出现的“）”可以将前面的一个“（”抵消； 但是“）”先出现，则无法抵消； 遍历输入字符串，index记录“（”的个数，若出现“）”，index减一，若index等于零，则不合法括号数s加一； 最后返回index+s。 参考代码class Solution: def minAddToMakeValid(self, S): index=0 s=0 for i in range(len(S)): if(S[i]==&apos;(&apos;): index+=1 else: if(index!=0): index-=1 else: s+=1 return s+index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[916.Word Subsets]]></title>
    <url>%2F2018%2F10%2F01%2F916-Word-Subsets%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given two arrays A and B of words. Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity. For example, “wrr” is a subset of “warrior”, but is not a subset of “world”. Now say a word a from A is universal if for every b in B, b is a subset of a. Return a list of all universal words in A. You can return the words in any order. 题目链接：https://leetcode.com/problems/word-subsets/description/ Difficulty: hard Example 1:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;o&quot;] Output: [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;] Example 2:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;l&quot;,&quot;e&quot;] Output: [&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;] Example 3:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;oo&quot;] Output: [&quot;facebook&quot;,&quot;google&quot;] Example 4:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;lo&quot;,&quot;eo&quot;] Output: [&quot;google&quot;,&quot;leetcode&quot;] Example 5:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;ec&quot;,&quot;oc&quot;,&quot;ceo&quot;] Output: [&quot;facebook&quot;,&quot;leetcode&quot;] Note: 1 &lt;= A.length, B.length &lt;= 10000 1 &lt;= A[i].length, B[i].length &lt;= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn’t i != j with A[i] == A[j]. 分析 如题所定义的包含关系可以转化为，字符串A,B，若B中的每一个字母出现的次数都小于等于A中字母出现的次数，则A包含B； 对于B中每一个字符串，统计对应字母出现次数最多的次数，存在dicb中； 对于A中每个字符串a，计算a中每个字母出现的次数，存在dica中； 若dica包含dicb，则a是满足要求的字符串。 参考代码class Solution: def wordSubsets(self, A, B): from collections import defaultdict dicb=defaultdict(lambda:0) for b in B: d=defaultdict(lambda:0) for tar in b: d[tar]+=1 for tar in d: dicb[tar]=max(dicb[tar],d[tar]) li=[] #print(dicb) for a in A: dica=defaultdict(lambda:0) for tar in a: dica[tar]+=1 #print(dica) if(all(dica[c]&gt;=dicb[c] for c in dicb)): li.append(a) return li]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[915.Partition Array into Disjoint Intervals]]></title>
    <url>%2F2018%2F10%2F01%2F915-Partition-Array-into-Disjoint-Intervals%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A, partition it into two (contiguous) subarrays left and right so that: Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size. Return the length of left after such a partitioning. It is guaranteed that such a partitioning exists. 题目链接：https://leetcode.com/problems/partition-array-into-disjoint-intervals/description/ Difficulty: medium Example 1:Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6] Example 2:Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12] Note: 2 &lt;= A.length &lt;= 30000 0 &lt;= A[i] &lt;= 10^6 It is guaranteed there is at least one way to partition A as described. 分析 定义ml为左边序列的最大值，mr为右边序列的最小值，mr初始值min(A)； 循环遍历A，更新ml，mr，其中，若A[i]&gt;mr，则不需要更新mr(这一步不做，会时间超限)，反之，mr=A[i+1:] 若ml&lt;=mr,则返回当前序号。 参考代码class Solution: def partitionDisjoint(self, A): ml=0 index=0 mr=min(A) for i in range(len(A)-1): ml=max(ml,A[i]) if(A[i]==mr): mr=min(A[i+1:]) if(ml&lt;=mr): index=i+1 return index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[914.X of a Kind in a Deck of Cards]]></title>
    <url>%2F2018%2F10%2F01%2F914-X-of-a-Kind-in-a-Deck-of-Cards%2F</url>
    <content type="text"><![CDATA[DescriptionIn a deck of cards, each card has an integer written on it. Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where: Each group has exactly X cards. All the cards in each group have the same integer. 题目链接：https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/description/ Difficulty: easy Example 1:Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4] Example 2:Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition. Example 3:Input: [1] Output: false Explanation: No possible partition. Example 4:Input: [1,1] Output: true Explanation: Possible partition [1,1] Example 5:Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2] Note: 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 分析 由题意知，若每个数字出现的次数都大于1，且次数都可以整除某一个数，则返回True，反之False； 找到最小的出现次数m，若小于2，则返回False，能整除的数在[2，m]； 循环，若存在某一个数i（[2，m]）是的每一个数出现的次数都可以整除i，则返回True； 若没有，返回False。 参考代码class Solution: def hasGroupsSizeX(self, deck): dic={} for d in deck: if(d in dic): dic[d]+=1 else: dic[d]=1 m=10000 for d in dic: m=min(dic[d],m) if(dic[d]==1): return False for i in range(2,m+1): for d in dic: if(dic[d]%i!=0): break else: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[913.Cat and Mouse]]></title>
    <url>%2F2018%2F10%2F01%2F913-Cat-and-Mouse%2F</url>
    <content type="text"><![CDATA[DescriptionA game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0. During each player’s turn, they must travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0.) Then, the game can end in 3 ways: If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player’s turn to move), the game is a draw. Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw. 题目链接：https://leetcode.com/problems/cat-and-mouse/description/ Difficulty: hard Example 1:Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Explanation: 4---3---1 | | 2---5 \ / 0 Note: 3 &lt;= graph.length &lt;= 50 It is guaranteed that graph[1] is non-empty. It is guaranteed that graph[2] contains a non-zero element. 分析 参考代码 updating…….]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Breadth-first Search</tag>
        <tag>Minimax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[903.Valid Permutaions for DI Sequence]]></title>
    <url>%2F2018%2F09%2F10%2F903-Valid-Permutaions-for-DI-Sequence%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.) A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i: If S[i] == ‘D’, then P[i] &gt; P[i+1], and; If S[i] == ‘I’, then P[i] &lt; P[i+1]. How many valid permutations are there? Since the answer may be large, return your answer modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/valid-permutations-for-di-sequence/description/ Difficulty: hard Example 1:Input: &quot;DID&quot; Output: 5 Explanation: The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0) Note: 1 &lt;= S.length &lt;= 200 S consists only of characters from the set {‘D’, ‘I’}. 分析 题意：每次可以交换第index（小于等于K）个字母到最后一个，可以交换任意次，是的结果为最小字典顺序； 当K&gt;=2时，相当于时间复杂度为$O(n_2)$的排序算法，当然可能小于$O(n_2)$，最后结果一定是字典顺序；大致过程：每次移到最后相当于字符串循环，每次将待排序字符放在第一位，循环后面的字符串，直到待排序字符排好序，加入循环字符串，以此类推； 当K==1时，相当于首尾相连，找到最小字典顺序字串，简单做法：字符串复制两份，遍历一半，截取length长度的字串，找出最小字典顺序字串。 参考代码]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[902.Numbers At Most N Given Digit Set]]></title>
    <url>%2F2018%2F09%2F10%2F902-Numbers-At-Most-N-Given-Digit-Set%2F</url>
    <content type="text"><![CDATA[DescriptionWe have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}. (Note that ‘0’ is not included.) Now, we write numbers using these digits, using each digit as many times as we want. For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N. 题目链接：https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/ Difficulty: hard Example 1:Input: D = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], N = 100 Output: 20 Explanation: The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. Example 2:Input: D = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], N = 1000000000 Output: 29523 Explanation: We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D. Note: D is a subset of digits ‘1’-‘9’ in sorted order. 1 &lt;= N &lt;= 10^9 分析 分为两部分考虑，数字的长度小于N的长度和数字的长度等于N的长度； 第一种：可能的个数是D的长度的（数字的长度）次方，如例1，5+5*5； 第二种：如果最高位取一个小于N最高位的数字，那么，后面的位置可以取任意数字，若等于，后移移位继续3步骤，如大于，则结束； 第二种情况有一个特例，即D的长度为1的时候，如果N中每个数字都小于D[0]则，可能的数字是1，反之是0。 参考代码class Solution: def atMostNGivenDigitSet(self, D, N): s=0 length=len(D) n=10 l=length while(N&gt;=n): s+=l n*=10 l*=length li=[] while(N&gt;0): li=[N%10]+li N//=10 i=0 index=0 judge=True while(judge and i&lt;len(li)): l//=length for d in D: d=int(d) if(d&lt;li[i]): index+=l elif(d==li[i]): i+=1 if(i==len(li)): index+=1 break else: judge=False break else: judge=False if(length==1): index=1 for ind in li: if(ind&lt;int(D[0])): index=0 break elif(ind&gt;int(D[0])): index=1 break return s+index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[901.Online Stock Span]]></title>
    <url>%2F2018%2F09%2F10%2F901-Online-Stock-Span%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock’s price for the current day. The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6]. 题目链接：https://leetcode.com/problems/online-stock-span/description/ Difficulty: medium Example 1:Input[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation: First, S = StockSpanner() is initialized. Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6. Note that (for example) S.next(75) returned 4, because the last 4 prices (including today&apos;s price of 75) were less than or equal to today&apos;s price. Note: Calls to StockSpanner.next(int price) will have 1 &lt;= price &lt;= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages. 分析 由题意知是为了得到以当前价格为结尾的且每个数字都小于等于当前价格的最长序列的长度； 若直接用list存储价格，每次向前遍历得到长度，时间会超限（有note中知，测试数据很大）； 所以动态存储以每个价格结尾的元组（包括价格和对应的长度）； 如果当前价格小于list最后一个价格，则，改价格对应的长度为1； 如果当前价格大于等list中最后一个价格，则，当前价格的长度加上最后一个价格对应的长度，pop出list中最后一个元祖； 重复5，知道，list为空，或当前价格小于最后一个价格； 将当前价格及其长度，加入到list中。 参考代码class StockSpanner: def __init__(self): self.li=[] def next(self, price): s=1 while self.li and self.li[-1][0]&lt;=price: s+=self.li.pop()[1] self.li.append((price,s)) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[900.RLE Iterator]]></title>
    <url>%2F2018%2F09%2F10%2F900-RLE-Iterator%2F</url>
    <content type="text"><![CDATA[DescriptionWrite an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence. More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n &gt;= 1) and returns the last element exhausted in this way. If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5]. This is because the sequence can be read as “three eights, zero nines, two fives”. 题目链接：https://leetcode.com/problems/rle-iterator/description/ Difficulty: medium Example 1:Input: [&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation: RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times: .next(2) exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5]. .next(1) exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5]. .next(1) exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5]. .next(2) exhausts 2 terms, returning -1. This is because the first term exhausted was 5, but the second term did not exist. Since the last term exhausted does not exist, we return -1. Note: 0 &lt;= A.length &lt;= 1000 A.length is an even integer. 0 &lt;= A[i] &lt;= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 &lt;= n &lt;= 10^9. 分析 已知A存储的是每个数字及其对应出现的次数，其中0 &lt;= A[i] &lt;= 10^9，所以若把A还原成字符串(如[8,8,8,5,5])，这样取next是很方便，但是可能内存或者时间超限； 故定义index指向当前数据对，初始为0，position是遍历到当前数据对的位置，初始为0； 如果index超出A的长度，则返回-1； 如果n大于当前数据对剩余长度（当前数据对长度减去position），则index后移，n减去剩余长度，position置零； 反之，返回当前index对应的数字，position加n。 参考代码class RLEIterator: def __init__(self, A): self.li=A self.index=0 self.position=0 def next(self, n): while(self.index&lt;len(self.li)): if(self.position + n&gt;self.li[self.index]): n-=(self.li[self.index]-self.position) self.position=0 self.index+=2 else: self.position+=n return self.li[self.index+1] return -1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[899.Orderly Queue]]></title>
    <url>%2F2018%2F09%2F02%2F899-Orderly-Queue%2F</url>
    <content type="text"><![CDATA[DescriptionA string S of lowercase letters is given. Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves. 题目链接：https://leetcode.com/problems/orderly-queue/description/ Difficulty: hard Example 1:Input: S = &quot;cba&quot;, K = 1 Output: &quot;acb&quot; Explanation: In the first move, we move the 1st character (&quot;c&quot;) to the end, obtaining the string &quot;bac&quot;. In the second move, we move the 1st character (&quot;b&quot;) to the end, obtaining the final result &quot;acb&quot;. Example 2:Input: S = &quot;baaca&quot;, K = 3 Output: &quot;aaabc&quot; Explanation: In the first move, we move the 1st character (&quot;b&quot;) to the end, obtaining the string &quot;aacab&quot;. In the second move, we move the 3rd character (&quot;c&quot;) to the end, obtaining the final result &quot;aaabc&quot;. Note: 1 &lt;= K &lt;= S.length &lt;= 1000 S consists of lowercase letters only. 分析 题意：每次可以交换第index（小于等于K）个字母到最后一个，可以交换任意次，是的结果为最小字典顺序； 当K&gt;=2时，相当于时间复杂度为$O(n_2)$的排序算法，当然可能小于$O(n_2)$，最后结果一定是字典顺序；大致过程：每次移到最后相当于字符串循环，每次将待排序字符放在第一位，循环后面的字符串，直到待排序字符排好序，加入循环字符串，以此类推； 当K==1时，相当于首尾相连，找到最小字典顺序字串，简单做法：字符串复制两份，遍历一半，截取length长度的字串，找出最小字典顺序字串。 参考代码class Solution: def orderlyQueue(self, S, K): if(K&gt;1): return &apos;&apos;.join(sorted(S)) s=S+S target=S for i in range(1,len(S)+1): if(s[i:i+len(S)]&lt;target): target=s[i:i+len(S)] return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[898.Bitwise ORs of Subarrays]]></title>
    <url>%2F2018%2F09%2F02%2F898-Bitwise-ORs-of-Subarrays%2F</url>
    <content type="text"><![CDATA[DescriptionWe have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], …, A[j]] (with i &lt;= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | … | A[j]. Return the number of possible results. (Results that occur more than once are only counted once in the final answer.) 题目链接：https://leetcode.com/problems/bitwise-ors-of-subarrays/description/ Difficulty: medium Example 1:Input: [0] Output: 1 Explanation: There is only one possible result: 0. Example 2:Input: [1,1,2] Output: 3 Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3. Example 3:Input: [1,2,4] Output: 6 Explanation: The possible results are 1, 2, 3, 4, 6, and 7. Note: 1 &lt;= A.length &lt;= 50000 0 &lt;= A[i] &lt;= 10^9 分析 动态规划：遍历数组，记录以每一个数为结尾的子数组的结果，存在set中； 将当前数与前一个数的结果的取或和本身，存储aSet（set）中； aSet的长度即使所有结果的可能数。 参考代码class Solution: def subarrayBitwiseORs(self, A): index =A[0] aSet=set() judge=set() judge.add(index) aSet.add(index) for i in range(1,len(A)): _judge=set() for j in judge: aSet.add(A[i]) _judge.add(A[i]) aSet.add(j | A[i]) _judge.add(j | A[i]) judge=_judge return len(aSet) 83 / 83 test cases passed. Runtime: 1712 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[897.Increasing Order Search Tree]]></title>
    <url>%2F2018%2F09%2F02%2F897-Increasing-Order-Search-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. 题目链接：https://leetcode.com/problems/increasing-order-search-tree/description/ Difficulty: easy Example 1:Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9 Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8 \ 9 Note: The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000. 分析 题意：将二叉搜索树变为只有右结点的二叉搜索树； 遍历得到原二叉搜索树的中序遍历序列； 根据中序遍历序列，遍历构建只有右结点的二叉搜索树，返回根结点； 做到第二题的时候精神有点恍惚，感觉自己的代码不够pythonic。 参考代码Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def increasingBST(self, root): def _inter(ro): if(ro==None): return None left=[] if(ro.left!=None): left=_inter(ro.left) right=[] if(ro.right!=None): right=_inter(ro.right) return left + [ro.val] + right li=_inter(root) if(len(li) ==0 ): return None head=TreeNode(li[0]) p=head for i in range(1,len(li)): q=TreeNode(li[i]) p.right=q p=q return head 2156 / 2156 test cases passed. Runtime: 160 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Depth-first Search</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[896.Monotonic Array]]></title>
    <url>%2F2018%2F09%2F02%2F896-Monotonic-Array%2F</url>
    <content type="text"><![CDATA[DescriptionAn array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j]. An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j]. Return true if and only if the given array A is monotonic. 题目链接：https://leetcode.com/problems/monotonic-array/description/ Difficulty: easy Example 1:Input: [1,2,2,3] Output: true Example 2:Input: [6,5,4,4] Output: true Example 3:Input: [1,3,2] Output: false Example 4:Input: [1,2,4,5] Output: true Example 5:Input: [1,1,1] Output: true Note: 1 &lt;= A.length &lt;= 50000 100000 &lt;= A[i] &lt;= 100000 分析 判断数组是否是递增或者递减的，定义判断量judge，judge=0初始化，judge=1递增，judge=-1递减，遍历数组； 如果judge=0：当前数大于前一个数，judge=1，如果当前数小于前一个数，judge=-1； 如果judge=1：如果当前数小于前一个数，返回False； 如果judge=-1：如果当前数大于前一个数，返回False； 遍历结束，返回True。 参考代码class Solution: def isMonotonic(self, A): index = A[0] judge=0 for i in range(1,len(A)): if(judge==0): if(A[i]&gt;index): judge=1 if(A[i]&lt;index): judge=-1 index=A[i] elif(judge==1): if(A[i]&lt;index): return False index=A[i] else: if(A[i]&gt;index): return False index=A[i] return True 366 / 366 test cases passed. Runtime: 160 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder51]构建乘积数组]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 题目链接： https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46 分析 如下表格所示，第i行即需要返回B[i]； 故做两次循环，计算上下半角，得到最后的结果。 1 A[1] A[2] A[3] A[0] 1 A[2] A[3] A[0] A[1] 1 A[3] A[0] A[1] A[2] 1 参考代码# -*- coding:utf-8 -*- class Solution: def multiply(self, A): # write code here length=len(A) B=[1]*length for i in range(1,length): B[i]=B[i-1]*A[i-1] temp=1 for i in range(length-2,-1,-1): temp*=A[i+1] B[i]*=temp return B 运行时间： 24 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder50]数组中重复的数字]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 题目链接： https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8 分析 遍历numbers，若当前数字存在d（元组）中，则说明之前出现过这个数字，duplication[0]=number，返回True； 反之，将number加入到中； 返回False。 参考代码# -*- coding:utf-8 -*- class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here d=set() for number in numbers: if(number in d): duplication[0] = number return True else: d.add(number) return False 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder49]把字符串转换成整数]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 题目链接： https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e 输入描述 输入一个字符串,包括数字字母符号,可以为空 输出描述 如果是合法的数值表达则返回该数字，否则返回0 示例1输入 +2147483647 1a33 输出 2147483647 0 分析 judge用于存储数字的正负； digit存储0-9的数字； 遍历s（若s[0]为“+”或者“-”，则从第二个位置开始遍历），若出现不是数字的字符，返回零，反之存入index； 返回index的整数表示形式； 备注：磁体没有考虑“e”，如1e2=0.01。 参考代码# -*- coding:utf-8 -*- class Solution: def StrToInt(self, s): # write code here judge=1 index=&apos;&apos; ii=0 s=s.lstrip() if(len(s)==0): return 0 digit=[str(i) for i in range(10)] if(s[0]==&apos;+&apos;): judge=1 ii=1 elif(s[0]==&apos;-&apos;): judge=-1 ii=1 for i in range(ii,len(s)): if(s[i] in digit): index+=s[i] else: return 0 if(index==&apos;&apos;): return 0 return judge*int(index) 运行时间： 26 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder48]不用加减乘除做加法]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 题目链接： https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215 分析 额额额额，就这样吧。 参考代码# -*- coding:utf-8 -*- class Solution: def Add(self, num1, num2): # write code here s=[num1,num2] return sum(s) 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder47]求1+2+3+...+n]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder47-%E6%B1%821-2-3-n%2F</url>
    <content type="text"><![CDATA[题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 题目链接： https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1 分析 小学问题，额额额额。 参考代码# -*- coding:utf-8 -*- class Solution: def Sum_Solution(self, n): # write code here return n*(1+n)/2 运行时间： 24 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[895.Maximum Frequency Stack]]></title>
    <url>%2F2018%2F08%2F27%2F895-Maximum-Frequency-Stack%2F</url>
    <content type="text"><![CDATA[DescriptionImplement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions: push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack.If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned. 题目链接：https://leetcode.com/problems/maximum-frequency-stack/description/ Difficulty: hard Example 1:Input: [&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation:After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then: pop() -&gt; returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. pop() -&gt; returns 5. The stack becomes [5,7,4]. pop() -&gt; returns 4. The stack becomes [5,7]. Note: Calls to FreqStack.push(int x) will be such that 0 &lt;= x &lt;= 10^9. It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases. 分析 因为每次pop都是返回一个出现频率最大的数字，首先想到的是每次push保存下频率最大的数字，但是pop之后可能就会变化，这是如果去遍历所有push的数字时间会超限； 考虑把所有出现相同次数的数字放在同一个list中，然后把所有的list放入字典中，形如{1: [7, 5, 4], 2: [7, 5]}，代表至少出现一次的是：7，4，5，至少出现两次的是：7，5，题目要求需要在频率相同的情况下pop出最后push进去的，在构建的时候按照push顺序加入到字典中； 在构建一个字典存储每个数字出现的次数，形如：{7: 2, 5: 2, 4: 1} 代码如下 参考代码class FreqStack: def __init__(self): self.count = {} self.group = {} self.max = 0 def push(self, x): if(x in self.count): self.count[x]+=1 else: self.count[x]=1 f=self.count[x] if(f in self.group): self.group[f].append(x) else: self.group[f]=[x] if(f&gt;self.max): self.max=f def pop(self): x=self.group[self.max].pop() self.count[x]-=1 if(not self.group[self.max]): self.max-=1 return x]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[894.All Possible Full Binary Trees]]></title>
    <url>%2F2018%2F08%2F27%2F894-All-Possible-Full-Binary-Trees%2F</url>
    <content type="text"><![CDATA[DescriptionA full binary tree is a binary tree where each node has exactly 0 or 2 children. Return a list of all possible full binary trees with N nodes. Each element of the answer is the root node of one possible tree. Each node of each tree in the answer must have node.val = 0. You may return the final list of trees in any order. 题目链接：https://leetcode.com/problems/all-possible-full-binary-trees/description/ Difficulty: medium Example 1:Input: 7 Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Explanation: Note: 1 &lt;= N &lt;= 20 分析 对任意一个节点只有两个子节点或者0个，那么每个节点的左右子树的节点个数只能为奇数； 依据1，对于每个节点，其左右子树是剩余分成的两份（两份奇数个节点）； 2便是递归的步骤，以此递推。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def allPossibleFBT(self, N): if(N==0): return [None] if(N==1): return [TreeNode(0)] left=[] right=[] root=[] for i in range(1,N-1,2): print(i,N-1-i) left=self.allPossibleFBT(i) right=self.allPossibleFBT(N-1-i) for l in left: for r in right: ro=TreeNode(0) ro.left=l ro.right=r root.append(ro) return root 20 / 20 test cases passed. Runtime: 284 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[893.Groups of Special-Equivalent Strings]]></title>
    <url>%2F2018%2F08%2F27%2F893-Groups-of-Special-Equivalent-Strings%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A. 题目链接：https://leetcode.com/problems/groups-of-special-equivalent-strings/description/ Difficulty: easy Example 1:Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;] Output: 3 Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;] Example 2:Input: [&quot;aa&quot;,&quot;bb&quot;,&quot;ab&quot;,&quot;ba&quot;] Output: 4 Explanation: 4 groups [&quot;aa&quot;], [&quot;bb&quot;], [&quot;ab&quot;], [&quot;ba&quot;] Example 3:Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] Output: 3 Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;] Example 4:Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] Output: 1 Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] Note 1 &lt;= A.length &lt;= 1000 1 &lt;= A[i].length &lt;= 20 All A[i] have the same length. All A[i] consist of only lowercase letters. 分析 两个字符串special-equivalent，代表着一个字符串的奇数位置的字符经过任意次换位置和偶数位置的字符经过任意次换位置，两个字符串相等 经过任意次变换相等，也就是在奇数和偶数位置上的字符总和一直，那么一定可以经过任意次互换位置便可以字符串相等。 考虑包含奇数和偶数位置上的字符的特殊编码，即相应字符的个数（a-z,A-Z）,编码个数即groups数 参考代码def count(A): ans = [0] * 52 for i, letter in enumerate(A): ans[ord(letter) - ord(&apos;a&apos;) + 26 * (i%2)] += 1 return tuple(ans) return len({count(word) for word in A}) 34 / 34 test cases passed. Runtime: 52 ms 错误分析刚开始做这道题的时候，也是类似于编码，但是返回的是两个set def judge(s1): a1=set() a2=set() for i in range(len(s1)): if(i%2==0): a1.add(s1[i]) else: a2.add(s1[i]) return [a1,a2] 但是没有像Solution中的那样返回一个元祖，可以在后面把结果放在dict中，导致的结果就是时间超限。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[892.Surface Area of 3D Shapes]]></title>
    <url>%2F2018%2F08%2F27%2F892-Surface-Area-of-3D-Shapes%2F</url>
    <content type="text"><![CDATA[DescriptionOn a N N grid, we place some 1 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes. 题目链接：https://leetcode.com/problems/surface-area-of-3d-shapes/description/ Difficulty: easy Example 1:Input: [[2]] Output: 10 Example 2:Input: [[1,2],[3,4]] Output: 34 Example 3:Input: [[1,0],[0,2]] Output: 16 Example 4:Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 5:Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 分析 对于每一个立方体，由六个面，在整个立方体集合中贡献最大表面积为6； 如果上面有立方体则减一，如果下面有立方体则减一，以此类推（包含上下左右前后六个面）； 因为N和grid[i][j]都不是很大，所以便利所以立方体便可以得到表面积 参考代码def surfaceArea(self, grid): row=len(grid) s=0 for i in range(row): for j in range(len(grid[i])): for index in range(grid[i][j]): current=6 if(i-1&gt;=0): if(grid[i-1][j]&gt;=index+1): current-=1 if(i+1&lt;row): if(grid[i+1][j]&gt;=index+1): current-=1 if(j-1&gt;=0): if(grid[i][j-1]&gt;=index+1): current-=1 if(j+1&lt;len(grid[i])): if(grid[i][j+1]&gt;=index+1): current-=1 if(index&gt;0): current-=1 if(index &lt; grid[i][j]-1): current-=1 s+=current return s 90 / 90 test cases passed. Runtime: 496 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lda2vev:Mixing Dirichlet Topic Models and Word Embeddings to Make lda2vec]]></title>
    <url>%2F2018%2F08%2F27%2Flda2vev-Mixing-Dirichlet-Topic-Models-and-Word-Embeddings-to-Make-lda2vec%2F</url>
    <content type="text"><![CDATA[结合主题信息和词潜入，生成包含主题信息的向量化表示lda2vec. 论文地址:https://arxiv.org/abs/1605.02019 ABSTRACT 已经证明分布式密集词向量在捕捉语言中的标记级语义和句法规则方面是有效的，而主题模型可以在文档上形成可解释的表示。在这项工作中，我们描述了lda2vec，它是一个与Dirichlet分布的主题向量的潜在文档级别混合学习密集词向量的模型。与连续密集的文档表示形式相反，该表达式通过非负单纯形约束产生稀疏的，可解释的文档混合。我们的方法很容易整合到现有的自动分化框架中，并允许无人监督的文档表示适合科学家使用，同时学习单词向量及它们之间的线性关系。 Introduction主题模型因其能够将文档集合组织为一组较小的突出主题而受到欢迎。 与密集的分布式表示形式相反，这些文档和主题表示通常可以被人类访问，并且更容易被解释。 这种解释性提供了额外的选项来突出我们的文档系统中的模式和结构。 例如，使用潜在狄利克雷分配（LDA）主题模型可以揭示文档中的词汇集合（Blei et al。，2003），强调时间趋势（Charlin et al。，2015），并推断补充产品的网络（McAuley et al。 。，2015）。 见Blei等人。 （2010年），概述计算机视觉，遗传标记，调查数据和社交网络数据等领域的主题建模。 图1：lda2vec通过将word2vec的skip gram体系结构与Dirichlet优化的稀疏主题混合体相结合，在单词和文档上构建表示。 文中描述了图中出现的各种组件和转换。 对于构建文档表示的密集向量方法也存在：Le和Mikolov（2014）提出了可以预测段落中词袋的段落向量，Kiros et al（2015）构建了在给定句子之前和之后重构句子序列的向量，并且Ghosh等人 （2016）构建了预测后续句子特征的语境LSTMs。 概率主题模型倾向于将文档形成为主题的稀疏混合成员，而神经网络模型倾向于将文档建模为密集向量。 由于其稀疏性和低维性，来自前者的陈述更容易检查，并且更直接地产生关于基础系统的高层次直觉（尽管不是没有危害，参见Chang等人（2009））。 本文探讨混合稀疏文档表示密集词和主题向量的混合方法。 不幸的是，制定一个新的概率主题模型需要得到一个新的近似值，这个过程需要大量的专业知识，并且必须根据每个模型进行定制。 因此，原型开发非常耗时，必须仔细考虑对模型体系结构的更改。 但是，使用现代自动分化框架，从业者可以将开发时间集中在模型设计上，而不是模型近似值。 这加快了评估哪些模型特征相关的过程。 这项工作利用Chainer（Tokui等，2015）框架来快速开发模型，同时使我们能够利用GPU来显着提高计算速度。 最后，文本上的传统主题模型没有利用分布式词语表示方面的最新进展，它可以捕捉令牌之间语义上有意义的规则。对词语共现的考察已被证明是一个富有成效的研究范式。例如，Mikolov等人（2013）利用Skipgram负抽样（Skipgram NegativeSampling，SGNS）利用跨越文本语料库的窗口形成的单词上下文对来训练单词嵌入。这些向量表示最终编码显着的线性，如king-man+woman=queen。事实上，Levy和Goldberg（2014c）证明，这隐含地分解了点阵互信息（PMI）矩阵的变体，该矩阵强调预测罕见群体的频繁共现。与PMI矩阵密切相关，Pennington 等人（2014）将大型全球字数共生矩阵分解以产生比SGNS更高效且性能稍高的计算嵌入。一旦创建，这些表示就可用于信息检索（Manning等，2009）和解析任务（Levy和Goldberg，2014a）。在这项工作中，我们将利用word级表示来建立文档级抽象。 本文通过包含可解释文档表示来扩展分布式词语表示，并证明模型推理可以在自动分化框架内执行和扩展。 Model本节介绍lda2vec的模型。 我们有兴趣修改（Mikolov et al。，2013）中的Skipgram负采样（SGNS）目标，以利用文档范围的特征向量，同时学习连续的文档权重加载到主题向量。 网络架构如图1所示。在（1）中的总损失项$\iota$是Skiggram负采样损失（SGNs）$\iota_{ij}^{neg}$的总和，并且在文档权重上增加了Dirichlet似然项，$\iota^d$将在后面讨论。使用上下文向量($\overrightarrow{c_j}$)、支点字向量($\overrightarrow{w_j}$)、目标词向量($\overrightarrow{w_i}$)和负采样词向量($\overrightarrow{w_l}$)进行损失。 $$ \iota =\iota^d +\sum_{ij}\iota_{ij}^{neg} \tag{1}$$ $$\iota_{ij}^{neg} = \log_\sigma(\overrightarrow{c_j}\cdot\overrightarrow{w_l})+\sum_{l=0}^n\log_\sigma(-\overrightarrow{c_j}\cdot\overrightarrow{w_l}) \tag{2}$$ Word Representation如在Mikolov等人（2013），当它们在移动的窗口中共同出现在整个语料库中时，提取枢轴词和目标词对（j，i）。在我们的实验中，窗口在枢轴标记之前和之后包含5个标记。对于每个枢轴目标字对，枢轴字用于预测附近的目标字。每个单词用固定长度的密集分布表示向量表示，但与Mikolov等人（2013年）不同，相同的单词向量用于枢轴和目标表示。2）中所示的SGNS损失试图区分出出现在语料库中的上下文词对，从而随机抽取 “negative”词汇池。当观察到的词与边缘分布完全分离时，该损失最小化。从中得出令牌的分布是$u^β$，其中u表示由总语料库大小归一化的整体词频。除非另有说明，否则，如Mikolov等人(2013)所述，负采样功率β设为3/4，负样本数固定为n = 15。请注意，$u^0.0$的分布会从词汇中绘制负标记而没有受欢迎的概念，而与$u^1.0$成比例的分布则取自经验单字分布。与单字分布相比，$u^{3/4}$的选择稍微强调为负样本选择不常用单词。与优化softmax交叉熵（其需要对每个令牌的总体流行度进行建模）相反，负面抽样侧重于通过从语料库中的每个令牌的边际流行度中抽取负样本来有条件地学习词向量。 Document Representationslda2vec将单词和文档向量嵌入同一个空间并同时训练两个表示。通过将枢轴和文档向量相加，两个空间都可以有效地结合在一起。 Mikolov等人（2013）提供了直觉，词向量可以汇总在一起形成两个词的语义上有意义的组合。例如，Germany+airline的载体表示与Lufthansa的载体相似。我们想利用单词向量的加性来构造一个有意义的单词和文档向量。例如，如果lda2vec正在扫描文档，第j个单词是德国，则预测相邻单词如法国，西班牙和奥地利相似。但是，如果文档特别是关于航空公司，那么我们希望构建一个类似于航空公司的单词向量的文档向量。然后，不是单独预测类似于德国的令牌，而是可以对文档和主要词汇进行类似的预测，例如：Lufthansa，Condor Flugdienst和Aero Lloyd。由有意义的词向量的总和驱动，在LDA2VEC中，上下文向量被明确地设计为文档向量和词向量的总和，如（3）： $$\overrightarrow{c_j}=\overrightarrow{w_j}+\overrightarrow{d_j} \tag{3}$$ 这通过保留文档中所有单词上下文对的($\overrightarrow{d_j}$)来模拟文档范围的关系，同时仍然利用由枢轴词向量($\overrightarrow{w_j}$)和目标词($\overrightarrow{w_i}$)之间的相互作用产生的局部词间关系。文档和单词向量被汇总在一起形成一个上下文向量，分别直观地捕捉长期和短期主题。为了防止共同适应，我们也对非规范化文档向量($\overrightarrow{d_j}$)和枢轴词向量($\overrightarrow{w_j}$)进行dropout（Hinton et al。，2012）。 Document Mixtures如果我们只包含到目前为止的结构，模型将为每个文档生成一个密集的向量。 然而，lda2vec致力于形成可解释的表示，并且这样做会施加额外的约束，使得文档表示与传统的LDA模型中的相似。我们的目标是从混合主题向量生成一个文档向量，为此，我们首先约束文档向量($d_j$),投影到一组潜在的主题向量($\overrightarrow{t_0}$),($\overrightarrow{t_1}),⋯,($\overrightarrow{t_k}$): $$\overrightarrow{d_j}=p_{j0}\cdot\overrightarrow{t_0}+p_{j2}\cdot\overrightarrow{t_2}+\cdots+p_{jk}\cdot\overrightarrow{t_k}+\cdots+p_{jn}\cdot\overrightarrow{t_n} \tag{4}$$ 每个权重0≤$p_{jk}$≤1是表示主题k中文档j的隶属度的分数。 例如，稍后描述的Twenty Newsgroups 模型具有11313个文档并且k = 20个主题，所以j = 0 … 11312，k = 0 … 19。 当单词向量维数设置为300时，假设文档向量($\overrightarrow{d_j}$)，单词向量($\overrightarrow{w_i}$)和主题向量($\overrightarrow{t_k}$)都具有维度300.注意，主题向量($\overrightarrow{t_k}$)是共享的 并且是所有文档的共同组成部分，但其强度由文档权重p_jk调整。为了有助于可解释性，文档成员资格被设计为非负面的，并且归结为统一。 为了实现这个约束，softmax变换将在R^300中初始化的潜在向量映射到由$p_{jk}$定义的单纯形中。softmax变换自然会强制约束$\sum_k p_{jk} = 1$，并允许我们将成員資格解釋为百分比而非无限权重。 将（4）中的混合作为总和来保证主题向量($\overrightarrow{t_k}$)，文档向量($\overrightarrow{d_j}$)和词向量($\overrightarrow{w_i}$)在相同的空间中操作。因此，可以直接计算哪些字($\overrightarrow{w_i}$)最类似于任何给定的主题向量($\overrightarrow{t_k}$)。尽管每个主题不是字面上語料庫中存在的标记，但与其他标记的相似性是有意义的并且可以被测量。此外，通过检查最相似的单词列表，可以尝试解释该主题所代表的内容。例如，通过计算与任何主题向量（例如argma$x_i(\overrightarrow{t_0}\cdot\overrightarrow{w_i})$最相似的标记，人们可以发现第一个主题向量($\overrightarrow{t_0}$)与标记pitching，catcher和Braves相似，而第二个主题向量($\overrightarrow{t_1}$)可能与Jesus，God和faith相似。这为我们提供了将第一个主题解释为baseball主题的选项，因此每个文档比例$p_{j0}$中的第一个分量指示文档j在棒球主题中的数量。同样，第二个主题可能被解释为基督教，任何文档比例的第二个组成部分$p_{j1}$表示该文件在基督教主题中的成员身份。 Sparse Memberships最后，通过对具有低浓度参数α的Dirichlet似然优化文档权重，使文档权重$p_{ij}$被稀疏化： $$\iota^d=\lambda\sum_{jk}(\alpha-1)\log p_{jk} \tag{5}$$ 5）中的总体目标衡量文档j在主题k中概括所有可用文档的可能性。该项的强度由调整参数λ调整。当α＜1时，每一个主题中的文档比例耦合都是稀疏的，当α＞1时，这种简单的可能性会促使文档的比例耦合。为了提高可解释性，我们有兴趣寻找稀疏成员，并设置α=n^(-1)，其中n是主题。我们还发现将Dirichlet优化的整体强度设置为λ= 200的效果很好。文档比例被初始化为相对均匀，但随着时间的推移，$\iota^d$鼓励文档比例向量随着时间的推移变得更加集中（例如稀疏）。在没有这个稀疏诱导项的实验中（或者当α= 1时），文档权重$p_{ij}$倾向于在所有元素之间展开概率质量。如果没有任何稀疏性引入术语，那么许多非零权重的存在使解释文档向量变得困难。此外，我们发现话题基础也受到强烈影响，话题变得不連貫。 # of topics β Topic Coherences 20 0.75 0.567 30 0.75 0.555 40 0.75 0.553 50 0.75 0.547 20 1.00 0.563 30 1.00 0.564 40 1.00 0.552 50 1.00 0.558 图2：给出了在Twenty Newsgroups数据集中由lda2vec发现的平均主题一致性。 主题一致性已被证明与主题模型的人类评估相关（Roder等，2015）。 给出了所选主题的数量，以及负抽样指数参数β。 与β= 1.00相比，β= 0.75将更多的稀有词作为负样本。 在模型n = 20个主题和β= 0.75中找到最好的主题相关性。 Preprocessing and Training1）中的目标是一次在单独的小批量中进行训练，同时使用Adam优化器（Kingma和Ba，2014）在整个数据集中处理两百个时期。Dirichlet似然项$\iota^d$通常是在所有文档上计算的，因此在将目标修改为小批量时，我们调整术语的损失与小批量大小除以总语料库的大小成比例。我们的软件是开源的，可在线获得，记录和单元测试。最后，将给定主题中前十个最有可能的单词提交给在线Palmetto主题质量测量工具，并记录相干性测量$C_v$。在评估多个替代方案后，$C_v$是Roder等人（2015）推荐的一致性度量。此度量对外部语料库上大小为110的滑动窗口内的每对单词的归一化点互信息（NPMI）进行平均，并返回提交的单词集的NPMI平均值。使用3COSMUL度量来评估令牌到词的相似度（Levy和Goldberg，2014b）。 Topic Label “Space” “Encryption” “X Windows” “Middle East” Top tokens Astronomical Astronomy Satellite Planetary telescope Encryption Wiretap Encrypt Escrow Clipper Mydisplay Xlib,Window Cursor pixmap Armenian Lebanese Muslim Turk sy Topic Coherence 0.712 0.675 0.472 0.615 图3：由Twenty Newsgroups数据集中的lda2vec发现的主题。 推断的主题标签显示在第一行。 与该主题相似度最高的令牌将在下面显示。请注意,Twenty Newsgroups语料库包含相应的新闻组，如sci.space，sci.crypt，comp.windows.x和talk.politics.mideast。 ExperimentsTwenty Newsgroups本节详细介绍了发现二十新闻组数据集中显着主题的实验，这是一种流行的文本机器学习语料库。语料库中的每个文档都发布到二十个可能的新闻组中的一个。尽管每篇文章的文本都可用于lda2vec, 但每个新闻组分区并未显示给算法，但对于发现的主题的事后定性评估仍然有用。使用Scikit-learn（Pedregosaetal，2012）中提供的数据加载器预处理语料库，使用SpaCy解析器（Honnibal and Johnson，2015）识别令牌。单词被词组化以将多个入口组合为单个令牌。在语料库中发生少于十次的令牌被删除，标记看起来像是URL，数字或在其正文形式中包含特殊符号。预处理之后，数据集包含11,313个文档中的8946个独特标记的180万个观察值。字向量被初始化为Mikolov等人（2013）的预训练值，但在训练时允许更新这些向量。 通过改变主题数量n∈20,30,40,50和负取样指数β∈0.75,1.0来评估一系列lda2vec参数。 图2总结了n = 20个话题和负抽样功率β= 0.75的最佳话题相关性。我们简要地试验了dropout率的变化，但我们没有观察到任何实质性差异。 图3列出了在Twenty Newsgroups数据集中发现的四个示例主题。每个主题与与训练的单词向量相同的空间中存在的主题向量相关联，并且列出的是与每个主题向量最相似的词。所显示的第一个主题与令牌astronomical, Astronomy, satellite, planetary, and telescope有很高的相似性，因此可能是与’sci.space’新闻组类似的’Space’相关主题。第二个示例主题类似于语义上与’Encryption’相关的单词，例如Clipper和encrypt，并且可能与’sci.crypt’新闻组相关。第三和四个示例主题是“X Windows”和“Middle East”，可能属于“comp.windows.x”和“talk.politics.mideast”新闻组。 Hacker News Comments corpus这部分评估lda2vec在一个非常大的黑客新闻评论语料库上。黑客新闻是社交内容投票网站和社区，主要关注技术和创业。在这个语料库中，单个文档由发布到单个文章的所有评论中的所有单词组成。只包含超过10条评论的报道，并且仅包含评论超过10条的用户的评论。我们忽略其他元数据，如投票，时间戳和作者身份。原始数据集4可在线下载。语料库几乎是二十新闻组语料库的大小，足以学习专业词汇。为了利用这个丰富的语料库，我们使用SpaCy来一次标记整个名词短语和实体（Honnibal and Johnson，2015）。特定的标记过程也可以在线获得，预处理的数据集结果也是如此。这使我们能够捕捉诸如community policing measure等短语以及像Steve Jobs这样的突出数据作为单一的令牌。然而，这种标记化过程会生成一个与Palmetto主题一致性工具中可用的词汇完全不同的词汇，因此我们不会在此语料库上报告主题一致性。经过预处理，该语料库包含75万个令牌，在66万个文档中有11万个独特的令牌。与Twenty Newsgroups分析不同，词向量是随机初始化的，而不是使用预训练向量库。 “Housing Issues” “Internet Portals” “Bitcoin” “Compensation” “Gadget Hardware” more housing basic income new housing house prices short-term rentals DDG. Bing Google+ DDG iGoogle Btc Bitcoins Mt. Gox MtGox Gox current salary more equity vesting equity vesting schedule the Surface Pro HDMI glossy screens Mac Pro Thunderbolt 图4：Hacker News评论数据集中由lda2vec发现的主题。 推断的主题标签显示在第一行。 我们从名词短语中形成令牌，以捕捉这个专用语料库的独特词汇。 Artiﬁcial sweeteners Black holes Comic Sans Functional Programming San Francisco Glucose Fructose sugars sugar Soylent Paleo diet diet carbohydrates Particles Consciousness quantum mechanics universe dark matter Big Bang Planets entanglement Typeface Arial Times New Roman Font new logo Anonymous Pro Baskerville serif font FP Haskell functional languages monads Lisp Clojure category theory OO New York Palo Alto New York City SF Mountain View Seattle Los Angeles Boston 图5：给出顶行中的示例标记，报告Hacker News评论语料库中最相似的单词。 我们使用40个主题和256个隐藏单元来训练lda2vec模型，并报告学习的主题，以演示语料库中存在的主题。 此外，我们证明了向这个语料库指定的词向量和语义关系是学习到的。 在图4中列出了Hacker News语料库中lda2vec发现的示例主题。这些主题表明，语料库的主要主题以与LDA类似的方式在学习的主题向量中得以再现和表示（Blei et al。，2003）。第一个是我们对Housing Issues(房屋问题)的标签，其中涉及到住房政策问题，如住房供应（例如more housing）和成本（如basic income 和 house prices）。另一个主题列出了主要的internet portals（互联网门户），例如隐私意识搜索引擎“Duck Duck Go”（在语料库中缩写为DDG），以及其他主要搜索引擎（例如Bing）和主页（例如Google+和iGoogle）。第三个话题是流行的在线货币和支付系统Bitcoin（比特币），货币btc的缩写形式以及现已解散的比特币交易平台Mt. GOX。第四个主题是考虑薪酬和compensation，包括current salary(当前的薪水)，more equity(更多的股权)和vesting(归属)，以及雇员从其雇主那里获得股票的过程。第五个示例主题是HDMI和glossy screens等技术硬件(hardware)，并且包含诸如Surface Pro和Mac Pro等设备。 图5表明，标记的相似性以与SGNS类似的方式学习（Mikolov et al。，2013），但专门用于Hacker News语料库。与令牌人Artiﬁcial sweeteners类似的令牌包括其他与sugar有关的令牌，如fructose和与食物相关的令牌，如古饮食。与Black holes相似的标记包括物理相关的概念，如星系和暗物质。黑客新闻语料库将大量文本用于字体和设计，最类似于comic Sans的单词是其他流行字体（例如Times New Roman和Helvetica）以及与字体相关的概念，如Typeface和serif font。与Functional Programming类似的令牌与其他计算机科学相关的令牌相似，而类似于San Francisco的令牌包括其他大型美国城市以及位于旧金山(San Francisco)湾区的小城市。 Query Result California + technology Silicon Valley digital + currency Bitcoin Javascript - browser + server Node.js Mark Zuckerberg - Facebook + Amazon Jeff Bezos NLP - text + image computer vision Snowden - United States + Sweden Assange Surface Pro - Microsoft + Amazon Kindle 图6：Hacker News评论数据集中由lda2vec发现的示例线性关系。 第一列表示示例输入查询，第二列表示与输入最相似的标记。 图6表明，除了学习文档的主题以及与词语标记的相似之外，词汇之间的线性规律也被学习到。 “Query”列列出了一系列令牌，这些令牌在组合时会产生与“Result”列中显示的令牌最接近的令牌向量。字面上对矢量的减法和增加进行评估，而是利用3COSMUL目标（Levy和Goldberg，2014b）。结果表明，令牌向量之间存在与黑客新闻社区重要的令牌之间的关系。例如，Silicon Valley(硅谷)的向量与California（加利福尼亚）和Technical（技术）类似，Bitcoin（比特币）确实是一种digital currency（数字货币），Node.js是一种能够在server（服务器）上运行Javascript而不是在客户端browsers（浏览器）上运行Javascript的技术，Jeff Bezos和Mark Zuckerber分别是Amazon（亚马逊）和Facebook的首席执行官，NLP和compute vision（计算机视觉）分别是机器学习研究领域，主要分别处理Text(文本)和Images(图像)，Edward Snowden(爱德华斯诺登)和Julian Assange(朱利安阿桑奇)都是举报者，他们主要位于United states(美国)和Sweden(瑞典)，最终Kindle和Surface Pro都是平板电脑分别由Amazon(亚马逊)和Microsoft(微软)制造。在上述示例中，令牌之间的语义关系对属性和特征进行编码，包括：位置，货币，服务器v.s.客户，领导力数据，机器学习领域，政治数据，国籍，公司和硬件。 Conclusion这项工作演示了一个简单的模型lda2vec，它扩展了SGNS（Mikolov et al。，2013），以构建无监督的文档表示，从而产生连贯的主题。将词，主题和文档向量联合训练并嵌入到共同表示空间中，该空间保留学习词向量之间的语义规则性，同时仍然以LDA的风格产生稀疏且可解释的文档 - 主题比例（Blei等，2003 ）。。在Twenty Newsgroups语料库中形成的主题产生了高度的平均主题一致性，这些主题一致性已被证明与人类主题评估相关（Roder等，2015）。当应用到Hacker News comments语料库时，lda2vec发现了该社区内的显着话题，并且学习了单词之间的线性关系，从而可以在该语料库的专业词汇表中解决单词类比问题。最后，我们注意到，我们的方法在自动微分框架中实现是简单的，并且可以导致更容易解释的无监督表示。]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>recommendation</tag>
        <tag>clustering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DKN:Deep Knowledge-Aware Network for News Recommendation]]></title>
    <url>%2F2018%2F08%2F27%2FDKN-Deep-Knowledge-Aware-Network-for-News-Recommendation%2F</url>
    <content type="text"><![CDATA[用知识图谱表示，结合CNN，利用attention module帮助识别用户的多兴趣，进行新闻推荐 论文地址:https://arxiv.org/abs/1801.08284 参考：Qiu Fengyu ABSTRACT在线新闻推荐系统主要解决新闻信息过载的问题，同时尽可能提升用户的使用体验，注重个性化。一般来说，新闻的语言是高度凝练的，有许多命名实体，并且包含了很多的常识。目前现有的一些推荐算法不关注、或者说无法理解新闻中的一些“知识”以及我们所了解的常识，仅仅通过一些简单的模式匹配、主题相关进行机械的推荐，不具有理论上的扩展性。此外，新闻具有时效性的特征，用户的口味也会 随着时间变化，为解决这些问题，本文提出了 DKN 模型，将知识图谱表示融入新闻推荐中。DKN 是一个预测点击率的基于内容的深度推荐模型。DKN 的核心是一个多通道、命名实体对齐的、融合了知识的卷积神经网络（KCNN），从语义和知识层面上来表示新闻。KCNN 把新闻中的词和实体作为通道（channel），并且在卷积过程中显式地监督两者的对齐关系。为了处理用户喜好的多样性，加入了 Attention 动态地对用户阅读历史进行加权，选择候选新闻。在大量的相关实验中，取得了最好的结果。 KEYWORDS新闻推荐，知识图谱表示，深度神经网络，注意力模型 INTRODUCTION随着网络的发展，现在人们阅读新闻的习惯已经从传统的纸媒、电视转向网络，如Google News和Bing News在线新闻网站，收集各种各样的新闻资源提供给读者。网络新闻平台的一个常见问题是，文章的数量可能会被淹没，从而减轻信息过载的影响，从而帮助读者获取阅读兴趣并提出个性化建议。 总的来说，新闻推荐更为突出的主要有以下三个挑战： 跟电影和酒店相比，新闻具有很强的时间敏感性，容易过期，过时的新闻很快就会被更新的新闻所取代。从而传统基于 ID 的协同过滤方法就很有限了； 用户在阅读新闻的时候是话题敏感的，通常对多个话题都具有倾向性。如何从多种多样的阅读记录中，对用户的多种主题偏好信息进行动态表示，是新闻推荐系统做好的关键； 新闻文本语言高度凝练，还包含了大量的知识实体和常识。 如图1所示，一个用户点击一个标题为“Boris Johnson Has Warned Donald Trump To Stick To The Iran Nuclear Deal”的新闻，其中包含四个实体：“Boris Johnson”,“Donald Trump”, “Iran” and “Nuclear”，事实上，该用户对另外一个新闻（“North Korean EMP Attack Would Cause Mass U.S. Starvation, Says Congressional Report”）也感兴趣，跟上一个联系跟紧密是因为常识。经典的语义模型或者主题模型，都是从词的共现信息或词聚类结构上挖掘新闻之间的关系，仅仅抓住了语义信息，从而给用户的新闻推荐就会变窄，局限在一个话题中。而本文提出的 DKN 能够从中挖掘新闻之间的潜在知识层面上的联系，引入知识图谱中的信息，是一种十分合理的扩展。 为了提取新闻之间深度逻辑关系，将知识图谱引入新闻推荐很有必要。知识图是一种有向异构图，其中节点对应于实体，边对应于关系。 最近，研究人员已经提出了一些学术知识图谱，如NELL,DBpedia,Google Knowledge Graph 和Microsoft Satori.这些知识图谱都成功的应用于机器阅读，文本分类和词嵌入。 考虑到之前提到的新闻推荐的挑战以及知识图谱的广泛成功应用，本文我们提出利用知识图谱做新闻推荐的新的框架（deep knowledge-awarenetwork， DKN）与传统的协同过滤方法不同的是，DKN 是一种基于内容的 CTR（点击率）预测模型：给定一个候选新闻和用户之前的浏览历史，预测用户点击候选新闻的概率。在 DKN 中的主要步骤： 对新闻中的每个词都在知识图谱中找到对应的实体来扩展它的信息，使用他的邻居实体来增强新闻的知识层面的信息。 设计DKN的关键部分knowledge-aware convolutional neural networks (KCNN), 把新闻词和知识层次的信息表示为知识感知嵌入向量。 KCNN 是多个通道的，新闻输入与图像的 RGB 通道类似，这里的通道包含了新闻中词的嵌入（embedding），实体的嵌入及相关实体的嵌入； 词语-实体对齐信息，把一个词和对应的实体在多个通道内进行对齐，通过某种转换函数（映射）来消除词向量和实体向量空间的异构性。或者可以这样理解，KCNN 保证了多个通道内词语的表示的一致性，并且显式地减少不同 embedding 空间的隔阂。 通过 KCNN，得到的新闻知识感知表示向量，候选新闻与用户点击过的新闻通过 attention，加权一个用户的历史新闻得到用户的嵌入表示。用户的嵌入表示和候选新闻的嵌入表示最后通过 DNN 来计算候选新闻被用户点击的概率。 最终，本文提出的 DKN 模型在 Bing News 推荐上得到了显著的性能提升。DKN显著优于基线在F1上的2.8%到17%和AUC的2.6%到16.1%，显著水平为0.1。 提出的注意力机制也可以带来3.5%和1.4%的提高。 PRELIMINARIES这部分介绍本文相关的概念和模型，包括知识图谱嵌入和句子表示的卷积神经网络。 Konowledge Graph Embedding]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>recommendation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[891.Sum of Subsequence Widths]]></title>
    <url>%2F2018%2F08%2F20%2F891-Sum-of-Subsequence-Widths%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between themaximum and minimum element of S. Return the sum of the widths of all subsequences of A. As the answer may be very large, return the answer modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/sum-of-subsequence-widths/description/ Difficulty: hard Example 1:Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6. Note: 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= 20000 分析 将integers A排序 n=3时，形如A=[1,2,3],index=(4-1)*(3-1)=6 n=4时，形如A=[1,2,3,4],index=(8-1)(4-1)+(4-2)(3-2)=23 n=5时，形如A=[1,2,3,4,5],index=(16-1)(5-1)+(8-2)(4-2)=72 总结规律如下 $$index=\sum_{i=0}^{length/2}{(2^{length-1-i}-2^i)*(A[length-1]-A[i])}$$ 参考代码class Solution: def sumSubseqWidths(self, A): length=len(A) if(length==1): return 0 if(length==2): return abs(A[0]-A[1]) p1=length-1 p2=0 P1=2**(length-1) P2=2**0 index=0 A.sort() mod=10**9+7 while(p1&gt;p2): index+=((P1-P2)*(A[p1]-A[p2])) index%=mod p1-=1 p2+=1 P1//=2 P2*=2 return index 64 / 64 test cases passed. Runtime: 1224 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[890.Find and Replace Pattern]]></title>
    <url>%2F2018%2F08%2F20%2F890-Find-and-Replace-Pattern%2F</url>
    <content type="text"><![CDATA[DescriptionYou have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern. You may return the answer in any order. 题目链接：https://leetcode.com/problems/find-and-replace-pattern/description/ Difficulty: medium Example 1:Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot; Output: [&quot;mee&quot;,&quot;aqq&quot;] Explanation: &quot;mee&quot; matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}. &quot;ccc&quot; does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation, since a and b map to the same letter. Note: 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 分析 word与pattern匹配就是一种特殊的相等关系，每个字母是唯一的对应关系； 注意，每个字母只能对应一个，所以，定义两个字典，分别存储key-value和value-key的对应； 定义比较函数judge(a,b)，a=’mee’,b=’aqq’,生成两个字典，{m:a,e:q}和{a:m,q:e},如果相等返回True，反之False。 参考代码class Solution: def findAndReplacePattern(self, words, pattern): def judge(a,b): db={} da={} for i in range(len(a)): if(b[i] in db): if(db[b[i]]!=a[i]): return False else: db[b[i]] = a[i] if(a[i] in da): if(da[a[i]]!=b[i]): return False else: da[a[i]]=b[i] return True li=[] for word in words: if(judge(word,pattern)): li.append(word) return li 46 / 46 test cases passed. Runtime: 60 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[889.Construct Binary Tree from Preorder and Postorder Traversal]]></title>
    <url>%2F2018%2F08%2F20%2F889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[DescriptionReturn any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. 题目链接：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/ Difficulty: medium Example 1:Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note: 1 &lt;= pre.length == post.length &lt;= 30 pre[] and post[] are both permutations of 1, 2, …, pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. 分析 根据先序遍历pre和后续遍历post构建二叉树，常规递归方法； 递归的结束条件是：pre长度为0返回None，长度为1，返回TreeNode(pre[0]) pre[0]作为当前过程的根节点，pre[1:indexof(pre[1])+2]作为左子树先序，post[:indexof(pre[1])+1]作为左子树后序，pre[indexof(pre[1])+2:]作为右子树先序，post[indexof(pre[1])+1：-1]作为右子树后序； 如例：{[2,4,5],[4,5,2]}为左子树，{[3，6，7],[6,7,3]}为右子树，indexof(pre[1])为pre[1] (2)在post中的位置，为：2 以此类推 参考代码#Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def constructFromPrePost(self, pre, post): if(len(pre)==0): return None if(len(pre)==1): return TreeNode(pre[0]) head=TreeNode(pre[0]) index=post.index(pre[1]) left=self.constructFromPrePost(pre[1:2+index], post[:index+1]) right=self.constructFromPrePost(pre[2+index:], post[index+1:-1]) head.left=left head.right=right return head 306 / 306 test cases passed. Runtime: 56 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[888.Fair candy Swap]]></title>
    <url>%2F2018%2F08%2F20%2F888-Fair-candy-Swap%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed an answer exists. 题目链接：https://leetcode.com/problems/fair-candy-swap/description/ Difficulty: easy Example 1:Input: A = [1,1], B = [2,2] Output: [1,2] Example 2:Input: A = [1,2], B = [2,3] Output: [1,2] Example 3:Input: A = [2], B = [1,3] Output: [2,3] Example 4:Input: A = [1,2,5], B = [2,4] Output: [5,4] Note: 1 &lt;= A.length &lt;= 10000 1 &lt;= B.length &lt;= 10000 1 &lt;= A[i] &lt;= 100000 1 &lt;= B[i] &lt;= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer. 分析 交换一个candy使得两个人的candy总数相等，只需要交换的两个candy的差值为两个人的candy的总和的差值的一半（index）即可； 遍历A，存入set，为了搜索快； 遍历B，每一项加上index在set中，即使所需交换的两个candy。 参考代码class Solution: def fairCandySwap(self, A, B): sumA=sum(A) sumB=sum(B) index=(sumB-sumA)//2 bSet=set() for b in B: bSet.add(b) for i in A: if(i+index in bSet): return [i,i+index] return [0,0] 75 / 75 test cases passed. Runtime: 76 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[887.Super Egg Drop]]></title>
    <url>%2F2018%2F08%2F13%2F887-Super-Egg-Drop%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &lt;= F &lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 &lt;= X &lt;= N). Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F? 题目链接：https://leetcode.com/problems/super-egg-drop/description/ Difficulty: hard Example 1:Input: K = 1, N = 2 Output: 2 Explanation: Drop the egg from floor 1. If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2. If it breaks, we know with certainty that F = 1. If it didn&apos;t break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty. Example 2:Input: K = 2, N = 6 Output: 3 Example 3:Input: K = 3, N = 14 Output: 4 Note: 1 &lt;= K &lt;= 100 1 &lt;= N &lt;= 10000 分析 定义dp[i][j]表示j个鸡蛋i个move对应的楼层，若当前鸡蛋没破，对应的前一步是dp[i-1][j],若破了，对应的是dp[i-1][j-1],故dp[i][j]=dp[i-1][j-1]+dp[i-1][j]+1; 初始化，dp[i][j]=0; 动态计算dp[i][j]，直到dp[i][j]&gt;=N,返回i。 参考代码class Solution: def superEggDrop(self, K, N): dp=[[0]*(K+1) for i in range(N+1)] dp[0][0]=0 for i in range(1,N+1): dp[i][0]=0 for j in range(1,K+1): dp[i][j] = dp[i-1][j]+dp[i-1][j-1]+1 if(dp[i][j]&gt;=N): return i return N]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Dynamic Programming</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[886.Possible Bipartition]]></title>
    <url>%2F2018%2F08%2F13%2F886-Possible-Bipartition%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of N people (numbered 1, 2, …, N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way. 题目链接：https://leetcode.com/problems/possible-bipartition/description/ Difficulty: medium Example 1:Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3] Example 2:Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false Example 3:Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false Note: 1 &lt;= N &lt;= 2000 0 &lt;= dislikes.length &lt;= 10000 1 &lt;= dislikes[i][j] &lt;= N A dislikes[i][0] &lt; dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j]. 分析 对每一个[u,v]存储到graph中，代表每个人不喜欢的人的集合； 定义字典color存储每个人的类别，0，1两类； 深度搜索dfs对于每一个node，如果存在于color中，则返回对应值是否等于当前c值；反之，将当前c值存到color，并对所有不喜欢的人dfs，c取反（对1去异或） 对所与人dfs，有false则返回false，反之true。 参考代码class Solution: def possibleBipartition(self, N, dislikes): import collections graph = collections.defaultdict(list) for u, v in dislikes: graph[u].append(v) graph[v].append(u) color = {} def dfs(node, c = 0): if node in color: return color[node] == c color[node] = c return all(dfs(nei, c ^ 1) for nei in graph[node]) return all(dfs(node) for node in range(1, N+1) if node not in color)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[885.Spiral Matrix III]]></title>
    <url>%2F2018%2F08%2F13%2F885-Spiral-Matrix-III%2F</url>
    <content type="text"><![CDATA[DescriptionOn a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid. Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited. 题目链接：https://leetcode.com/problems/spiral-matrix-iii/description/ Difficulty: medium Example 1:Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]] Example 2:Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]] Note: 1 &lt;= R &lt;= 100 1 &lt;= C &lt;= 100 0 &lt;= r0 &lt; R 0 &lt;= c0 &lt; C 分析 由例子可知，从给定点开始，分别向有，向下，向左，向上遍历，初始长度为1，每一圈从向左开始增加1，最后得到遍历二维数组的结果； 定义judge判断某一点是否出界，s是当前遍历的长度； 定义index存储遍历得到的总和，用于结束while； 定义li存储当前满足的结果。 参考代码class Solution: def spiralMatrixIII(self, R, C, r0, c0): index=1 li=[] s=0 r,c=r0,c0 li.append([r,c]) def judge(x,y): if(x&gt;=0 and x&lt;R and y&gt;=0 and y &lt;C): return True return False while(index &lt; R*C): s+=1 for i in range(s): c+=1 if(judge(r,c)): li.append([r,c]) index+=1 for i in range(s): r+=1 if(judge(r,c)): li.append([r,c]) index+=1 s+=1 for i in range(s): c-=1 if(judge(r,c)): li.append([r,c]) index+=1 for i in range(s): r-=1 if(judge(r,c)): li.append([r,c]) index+=1 return li]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[884.Uncommon Words from Two Sentences]]></title>
    <url>%2F2018%2F08%2F13%2F884-Uncommon-Words-from-Two-Sentences%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given two sentences A and B. (A sentence is a string of space separated words. Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words. You may return the list in any order. 题目链接：https://leetcode.com/problems/uncommon-words-from-two-sentences/description/ Difficulty: easy Example 1:Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot; Output: [&quot;sweet&quot;,&quot;sour&quot;] Example 2:Input: A = &quot;apple apple&quot;, B = &quot;banana&quot; Output: [&quot;banana&quot;] Note: 0 &lt;= A.length &lt;= 200 0 &lt;= B.length &lt;= 200 0 &lt;= A[i] &lt;= 10^9 A and B both contain only spaces and lowercase letters. 分析 如果有一项出现两次或以上，那么一定不是Uncommon Words； 遍历A+B，定义一个set存储遍历结果，若该项已经存在于set中，说明出现不止一次，从list中移出。 参考代码class Solution: def uncommonFromSentences(self, A, B): d=set() li=[] a=A.split()+B.split() for index in a: if(index in d): if(index in li): li.remove(index) else: d.add(index) li.append(index) return li]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[883.Projection Area of 3D Shapes]]></title>
    <url>%2F2018%2F08%2F06%2F883-Projection-Area-of-3D-Shapes%2F</url>
    <content type="text"><![CDATA[DescriptionOn a N N grid, we place some 1 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side. Return the total area of all three projections. 题目链接：https://leetcode.com/problems/projection-area-of-3d-shapes/description/ Difficulty: easy Example 1:Input: [[2]] Output: 5 Example 2:Input: [[1,2],[3,4]] Output: 17 Explanation: Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane. Example 3:Input: [[1,0],[0,2]] Output: 8 Example 4:Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14 Example 5:Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21 Note: 1 &lt;= grid.length = grid[0].length &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 分析 updating 参考代码class Solution: def projectionArea(self, grid): row=len(grid) col=len(grid[0]) index=0 for i in range(row): index+=max(grid[i]) for j in range(col): ii=0 for i in range(row): if(grid[i][j]!=0): index+=1 ii=max(ii,grid[i][j]) index+=ii return index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[882.Reachable Nodes In Subdivided Graph]]></title>
    <url>%2F2018%2F08%2F06%2F882-Reachable-Nodes-In-Subdivided-Graph%2F</url>
    <content type="text"><![CDATA[DescriptionStarting with an undirected graph (the “original graph”) with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge. Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, …, x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), …, (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge. Return how many nodes you can reach in at most M moves. 题目链接：https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/description/ Difficulty: hard Example 1:Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation: The nodes that are reachable in the final graph after M = 6 moves are indicated below. Example 2:Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23 Note: 0 &lt;= edges.length &lt;= 10000 0 &lt;= edges[i][0] &lt; edges[i][1] &lt; N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 &lt;= edges[i][2] &lt;= 10000 0 &lt;= M &lt;= 10^9 1 &lt;= N &lt;= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0. 分析 updating 参考代码updating]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[881.Boats to Save People]]></title>
    <url>%2F2018%2F08%2F06%2F881-Boats-to-Save-People%2F</url>
    <content type="text"><![CDATA[DescriptionThe i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) 题目链接：https://leetcode.com/problems/boats-to-save-people/description/ Difficulty: medium Example 1:Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2:Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3:Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note: 1 &lt;= people.length &lt;= 50000 1 &lt;= people[i] &lt;= limit &lt;= 30000 分析 updating 参考代码class Solution: def numRescueBoats(self, people, limit): peo=sorted(people) length=len(peo) index=0 i,j=0,length-1 while(i&lt;=j): index+=1 if(peo[i]+peo[j]&lt;=limit): i+=1 j-=1 return index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Two Pointers</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[880.Decoded String at Index]]></title>
    <url>%2F2018%2F08%2F06%2F880-Decoded-String-at-Index%2F</url>
    <content type="text"><![CDATA[DescriptionAn encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken: If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape isrepeatedly written d-1 more times in total. Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string. 题目链接：https://leetcode.com/problems/decoded-string-at-index/description/ Difficulty: medium Example 1:Input: S = &quot;leet2code3&quot;, K = 10 Output: &quot;o&quot; Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;. The 10th letter in the string is &quot;o&quot;. Example 2:Input: S = &quot;ha22&quot;, K = 5 Output: &quot;h&quot; Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;. Example 3:Input: S = &quot;a2345678999999999999999&quot;, K = 1 Output: &quot;a&quot; Explanation: The decoded string is &quot;a&quot; repeated 8301530446056247680 times. The 1st letter is &quot;a&quot;. Note: 2 &lt;= S.length &lt;= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 &lt;= K &lt;= 10^9 The decoded string is guaranteed to have less than 2^63 letters. 分析 updating 参考代码class Solution: def decodeAtIndex(self, S, K): size=0 for i in S: if(i.isdigit()): size*=int(i) else: size+=1 for index in reversed(S): K %= size if(K==0 and index.isalpha()): return index if(index.isdigit()): size/=int(index) else: size-=1 return]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]孩子们的游戏（圆圈中最后剩下的数）]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%EF%BC%88%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 题目链接： https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6 分析 用list存储小朋友的编号； 模拟报数，每次将list中报数为m的小盆友的编号移出，同时记录当前位置； 直至剩下最后一个小朋友； 可能是程序的测试用例很小，最直接的办法竟然没有时间超限，应该有更pythonic的方法。 参考代码class Solution: def LastRemaining_Solution(self, n, m): # write code here li=[i for i in range(n)] index=0 if(not n or not m): return -1 while(len(li)&gt;1): index=(index+m-1)%len(li) li.remove(li[index]) return li[0] 运行时间： 64 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]扑克牌顺子]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 题目链接： https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4 分析 首先对numbers进行排序，统计大小王的个数； 定义judge代表已经排好序的牌的最大值，judge==0代表还没有排序； 遍历所有牌，如果有牌大于judge+大小王的个数，则返回False； 反之用大小王替代当前牌与之前牌的差值。 参考代码class Solution: def IsContinuous(self, numbers): # write code here index=0 numbers.sort() judge=0 if(not numbers): return False for i in numbers: if(i==0): index+=1 else: if(judge==0): judge=i else: if(i==judge+1): judge=i else: while(index): judge+=1 index-=1 if(judge+1==i): break if(judge+1!=i): return False judge+=1 return True 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]翻转单词顺序列]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 题目链接： https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3 分析 如下参考代码是遍历字符串的每个字符，遇到空格代表一个新的word，加入到new_s的前面，最后返回即可; 也可以用split()更简单一些，直接将字符串按空格分割。 参考代码class Solution: def ReverseSentence(self, s): # write code here new_s=&apos;&apos; index=&apos;&apos; if(s.strip()==&apos;&apos;): return s for i in s: if(i==&apos; &apos;): if(new_s): new_s = index+&apos; &apos;+new_s else: new_s = &apos;&apos;+index index=&apos;&apos; else: index+=i if(index): if(new_s): new_s = index+&apos; &apos;+new_s else: new_s = index return new_s 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]左旋转字符串]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 题目链接： https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec 分析 只需将移动位置的左右两部分呼唤位置即可，如下参考代码，很大的s，对len(s)取余； 也可以两个s拼接，直接取移动位置后长度为len(s)的字符串。 参考代码class Solution: def LeftRotateString(self, s, n): # write code here if(len(s)==0): return s n=n%len(s) if(n==0): return s else: return s[n:]+s[:n] 运行时间： 29 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]和为S的两个数字]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 题目链接： https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b 输出描述 对应每个测试案例，输出两个数，小的先输出。 分析 两个数的和相等乘积最小，只需要差值最大，类比同周长的矩形和正方形面积，遍历数组，第一个满足的即是最小乘积； i，j指向数字首尾，如果两个数和大于tsum，向左移动j； 如果和为tsum，返回结果； 反之i，j均向右移动； 循环2，3，4。 参考代码class Solution: def FindNumbersWithSum(self, array, tsum): # write code here j=len(array)-1 i=0 while(i&lt;=j): while(array[i]+array[j]&gt;tsum): j-=1 if(array[i]+array[j]==tsum): return [array[i],array[j]] else: j+=1 i+=1 return [] 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]和为S的连续正数序列]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 题目链接： https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe 输出描述 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 分析 连续序列（start-end）的和为（end+start）*（end-start+1）/2=sum; 所以end=(pow(1-4(index-index**2-2sum),0.5)-1)/2； 且start的值小于sum/2。 参考代码class Solution: def FindContinuousSequence(self, tsum): # write code here li=[] index=1 while(index&lt;=tsum//2): end=(pow(1-4*(index-index**2-2*tsum),0.5)-1)/2 if(int(end)==end): end=int(end) li.append([i for i in range(index,end+1)]) index+=1 return li 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数组中只出现一次的数字]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 题目链接： https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811 分析 遍历数组，用dict存储每个数字及其出现的次数； 遍历dict，返回所有出现一次的数字。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here d={} for index in array: if(index in d): d[index]+=1 else: d[index]=1 l=[] for index in d: if(d[index]%2==1): l.append(index) return l 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]平衡二叉树]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 题目链接： https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222 分析 递归：如果当前结点为空，返回平衡判断True以及深度0； 如果左右平衡判断出现False，则返回False； 如果左右子树的深度差值大于1，则返回False； 否则返回平衡判断True以及深度（左右子树最大深度+1） 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def IsBalanced_Solution(self, pRoot): # write code here def judge(root): if(not root): return [True,0] left_judge,left=judge(root.left) right_judge,right=judge(root.right) if(not left_judge or not right_judge): return [False,0] if(abs(left-right)&gt;1): return [False,0] return [True,max(left,right)+1] [bo,dep]=judge(pRoot) return bo 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树的深度]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 题目链接： https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b 分析 递归：如果当前结点为空，返回0，否则返回左右子树最大深度+1. 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def TreeDepth(self, pRoot): # write code here if(not pRoot): return 0 left=self.TreeDepth(pRoot.left) right=self.TreeDepth(pRoot.right) return max(left,right)+1 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数字在排序数组中出现的次数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述统计一个数字在排序数组中出现的次数。 题目链接： https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2 分析 遍历找到数组中等于k的数字（代码中是二分查找）； i，j分别向左右移动，知道，对应的下一个值不等于k； 返回j-i+1 参考代码class Solution: def GetNumberOfK(self, data, k): # write code here i,j=0,len(data)-1 mid=(i+j)//2 while(i&lt;=j and data[mid]!=k): if(k&gt;data[mid]): i=mid+1 mid=(i+j)//2 elif(k==data[mid]): break else: j=mid-1 mid=(i+j)//2 if(i&gt;j): return 0 i=j=mid while(i&gt;0): if(data[i-1]==k): i-=1 else: break while(j&lt;len(data)-1): if(data[j+1]==k): j+=1 else: break return j-i+1 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]两个链表的第一个公共结点]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入两个链表，找出它们的第一个公共结点。 题目链接： https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46 分析 相当于寻找两个数组的第一个相同数； 遍历两个链表，比较每个结点的val值，相同则返回； 遍历结束返回None。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here p=pHead1 q=pHead2 if(not pHead1 or not pHead2): return None while(p!=None): q=pHead2 while(q): if(p.val==q.val): return q q=q.next p=p.next return None 运行时间： 29 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数组中的逆序对]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题目链接： https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5 输入描述 题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例1输入： 1,2,3,4,5,6,7,0 输出： 7 分析 如果直接两边遍历比较，时间复杂度为$O(n^2)$,时间会超限； 考虑利用时间复杂度为O(nlogn)的归并排序解决，归并排序的子步骤是将两部分的排好序的序列合并，且归并排序是稳定的不会导致计数重复； 每次两部分合并时，若把后面的部分归并时，则该数字比前半部分的剩余序列都小，即逆序对数； 复现归并排序算法，加入计算逆序部分，返回逆序对总数。 参考代码class Solution: def _inter(self,temp,data,low,high): if(low&gt;=high): temp[low]=data[low] return 0 mid=(low+high)//2 left=self._inter(data,temp,low,mid) right=self._inter(data,temp,mid+1,high) count=0 i,j=low,mid+1 index=low while(i&lt;=mid and j &lt;=high): if(data[i]&lt;=data[j]): temp[index]=data[i] i+=1 else: temp[index]=data[j] j+=1 count+=(mid-i+1) index+=1 while(i&lt;=mid): temp[index]=data[i] i+=1 index+=1 while(j&lt;=high): temp[index]=data[j] j+=1 index+=1 return count+left+right def InversePairs(self, data): # write code here if(not data): return 0 import copy temp = [i for i in data] return self._inter(temp,data,0,len(data)-1)%1000000007 运行时间： 2179 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]第一次只出现一次的字符]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 题目链接： https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c 分析 用dict存储字符以及出现的位置；若重复出现，赋值为-1； 用list存储只出现一次的字符，若重复出现，将字符移出； 返回list中第一个字符。 参考代码class Solution: def FirstNotRepeatingChar(self, s): # write code here li=[] d={} for i in range(len(s)): if(s[i] in d): if(d[s[i]]!=-1): li.remove(d[s[i]]) d[s[i]]=-1 else: li.append(i) d[s[i]]=i if(li): return li[0] return -1 运行时间： 41 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]丑数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 题目链接： https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b 分析 由于丑数是只包含质因子2、3和5的数，所以每个数都是由若干个2，3，5相乘得来的； 故循环计算list存储的数分别乘以2，3，5，将最小的数append到list中，同时，该数字对应的在list中的位置后移； 返回最后一个数 参考代码class Solution: def GetUglyNumber_Solution(self, index): # write code here li=[1] index2,index3,index5=0,0,0 if(index&lt;=0): return 0 while(index-1): m=min(li[index2]*2,li[index3]*3,li[index5]*5) li.append(m) if(m%2==0): index2+=1 if(m%3==0): index3+=1 if(m%5==0): index5+=1 index-=1 return li[-1] 运行时间： 27 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]把数组排成最小的数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 题目链接： https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993 分析 定义一个新的比较函数，返回a+b拼接的数字与b+a拼接的数字的差值； 按题意，放在前面是的组合数字更小的数字应该放在前面，所以将新定义的函数传入sorted作为cmp参数，直接调用sorted排序； 主义，sorted的cmp参数在python3中已经不可以使用了。 参考代码class Solution: def PrintMinNumber(self, numbers): # write code here def judge(a,b):#a&lt;=b return int(str(a)+str(b))-int(str(b)+str(a)) numbers=sorted(numbers,cmp=judge) index=&apos;&apos; for i in numbers: index+=str(i) return index 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]整数1出现的次数（从1到n整数中1出现的次数）]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B4%E6%95%B01%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 题目链接： https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6 分析 1-10之间1出现10次，11-100之间1出现了19次（个位九次，十位九次，百位一次），一次类推； 但是本题的测试用例比较小，如下暴力解法，也通过了，直接计算每个数中1的个数； 建议总结上面的规律。 参考代码class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here s=0 for index in range(1,n+1): while(index&gt;0): if(index%10==1): s+=1 index/=10 return s 运行时间： 36 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]连续子数组的最大和]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 题目链接： https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484 分析 动态规划问题，遍历数组，每一步根据以前一个数字为结尾的字串的最大和，以及当前数字，计算以当前数字为结尾的字串的最大和； 得到所有字串的最大和。 参考代码class Solution: def FindGreatestSumOfSubArray(self, array): # write code here index=0 ans=array[0] for i in array: index=max(0,index)+i if(index&gt;ans): ans=index return ans 运行时间： 27ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]最小的k个数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 题目链接： https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf 分析 排序，返回最后k个数。 参考代码class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here tinput.sort() if(k&gt;len(tinput) or k&lt;=0): return [] return tinput[:k] 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数组中出现次数超过一半的数字]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 题目链接： https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163 分析 遍历数组，将数组中的数字及其相应的出现次数保存到dict中； 返回dict中出现次数大于一般的数字，反之返回0； 参考代码class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here d={} length=len(numbers) for index in numbers: if(index not in d): d[index]=1 else: d[index]+=1 for index in d: if(d[index]&gt;(length/2)): return index return 0 运行时间： 27ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]字符串的排列]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 题目链接： https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7 输入描述 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 分析 递归，每一步选取s中的一个字母加在list中； 终止条件：len(s)==0，则把list加入到全局变量dic（如果dic中不存在）中； 返回dic 参考代码class Solution: def Permutation(self, ss): # write code here ss=list(ss) dic=[] if(len(ss)==0): return dic def _inter(li,s): if(len(s)==0): li=&apos;&apos;.join(li) if(li not in dic): dic.append(li) return for i in s: import copy S=copy.copy(s) S.remove(i) _inter(li+[i],S) _inter([],ss) return dic 运行时间： 30ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉搜索树与双向链表]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 题目链接： https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5 分析 递归，递归过程中把root结点的左子树的最右结点与root结点相连，把root结点的右子树的最左结点与root相连； 最后返回root的最左结点，既是根节点。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def Convert(self, pRootOfTree): # write code here if(pRootOfTree==None): return self.Convert(pRootOfTree.left) left=pRootOfTree.left if(left): while(left.right): left=left.right pRootOfTree.left,left.right=left,pRootOfTree self.Convert(pRootOfTree.right) right=pRootOfTree.right if(right): while(right.left): right=right.left pRootOfTree.right,right.left=right,pRootOfTree while(pRootOfTree.left): pRootOfTree=pRootOfTree.left return pRootOfTree 运行时间： 28ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]复杂链表的复制]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 题目链接： https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba 分析 遍历链表可以复制next，但是random指向不一定，所以不能立刻复制，故用dict存储原链表中每个结点的id值（每个结点的id是唯一的）与新结点； 遍历中，复制结点和next指向，random指向原结点的random； 遍历结束后，利用dict重新调整random； 返回p_Head 参考代码class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None class Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here head=pHead p_Head=None new_Head=None dict1={} while(head): node=RandomListNode(head.label) node.random=head.random dict1[id(head)]=node head=head.next if(p_Head): new_Head.next=node new_Head=node else: new_Head=node p_Head=node new_Head=p_Head while(new_Head): if(new_Head.random!=None): new_Head.random=dict1[id(new_Head.random)] new_Head=new_Head.next return p_Head 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树中和为某一值的路径]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 题目链接： https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca 分析 递归，每一次递归的和为expectNumber-root.val; 终止条件：如果root为空返回空list，如果root为叶结点且值为expectNumber，则返回[root.val]; 返回root的值加左右结点返回的list。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here li=[] if(not root): return [] if(root and not root.left and not root.right and root.val==expectNumber): return [[root.val]] left=self.FindPath(root.left,expectNumber-root.val) right=self.FindPath(root.right,expectNumber-root.val) for index in left+right: li.append([root.val]+index) return li 运行时间： 31ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉搜索树的后序遍历序列]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 题目链接： https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd 分析 二叉搜索树是根结点大于左子树的所有结点，小于右子树的所有结点； 根据后续遍历序列，根结点为最后一个数字，去除前面小于根结点的序列，如果后面都大于根结点，则继续下一层，否则返回False； 最后返回True 参考代码class Solution: def VerifySquenceOfBST(self, sequence): # write code here def _inter(se): if(len(se)&lt;=2): return 1 else: index=se[-1] i=0 while(se[i]&lt;index): i+=1 judge=i while(judge&lt;len(se)-1): if(se[judge]&lt;index): return 0 judge+=1 print(se[:i]) print(se[i:-1]) return _inter(se[:i])*_inter(se[i:-1]) if(not sequence): return False if(_inter(sequence)): return True else: return False 运行时间： 33ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]从上往下打印二叉树]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 题目链接： https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701 分析 将根节点压入list，每次取出list第一个TreeNode，将该TreeNode的非空左/右结点压入list； li存储所有压入过list的TreeNode，li即是二叉树的层次遍历序列。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if(not root): return [] lay=[root] li=[root.val] while(len(lay)): ro=lay[0] lay=lay[1:] if(ro.left): li.append(ro.left.val) lay.append(ro.left) if(ro.right): li.append(ro.right.val) lay.append(ro.right) return li 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]栈的的压入、弹出序列]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E6%A0%88%E7%9A%84%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 题目链接： https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106 分析 用list存储栈中的数字，遍历压栈序列，记录压栈序列和出栈序列遍历位置； 如果当前压栈数字等于出栈数字，压栈出栈位置后移；否则：如果list最后一个等于出栈数字，list pop出最后一个数字，出栈位置后移，反之，出栈数字压入list，出栈位置后移； 直到遍历完压栈序列，判断list的逆序与出栈剩余序列是否一致，是则返回True，反之False。 参考代码class Solution: def IsPopOrder(self, pushV, popV): # write code here index=0 li=[] length=len(pushV) i=0 while(index &lt; length): if(pushV[index]==popV[i]): index+=1 i+=1 else: if(len(li) and li[-1] == popV[i]): i+=1 li.pop() else: li.append(pushV[index]) index+=1 while(i&lt;length): if(li[-1] == popV[i]): li.pop() i+=1 else: return False return True 运行时间： 25ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[879.Profitable Schemes]]></title>
    <url>%2F2018%2F07%2F30%2F879-Profitable-Schemes%2F</url>
    <content type="text"><![CDATA[DescriptionThere are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can’t participate in another crime. Let’s call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen? Since the answer may be very large, return it modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/profitable-schemes/ Difficulty: hard Example 1:Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation: To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. Example 2:Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation: To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). Note: 1 &lt;= G &lt;= 100 0 &lt;= P &lt;= 100 1 &lt;= group[i] &lt;= 100 0 &lt;= profit[i] &lt;= 100 1 &lt;= group.length = profit.length &lt;= 100 分析 反面教材-&gt;递归,updating 参考代码class Solution: def profitableSchemes(self, G, P, group, profit): length=len(group) target=0 def _inter(index,sumG,sumP): if(sumG+group[index]&lt;=G and sumP+profit[index]&gt;=P): nonlocal target target+=1 if(index+1&lt;length): _inter(index+1,sumG,sumP) if(sumG+group[index]&lt;=G): _inter(index+1,sumG+group[index],sumP+profit[index]) _inter(0,0,0) return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[878.Nth Magical Number]]></title>
    <url>%2F2018%2F07%2F30%2F878-Nth-Magical-Number%2F</url>
    <content type="text"><![CDATA[DescriptionA positive integer is magical if it is divisible by either A or B. Return the N-th magical number. Since the answer may be very large, return it modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/nth-magical-number/ Difficulty: hard Example 1:Input: N = 1, A = 2, B = 3 Output: 2 Example 2:Input: N = 4, A = 2, B = 3 Output: 6 Example 3:Input: N = 5, A = 2, B = 4 Output: 10 Example 4:Input: N = 3, A = 6, B = 4 Output: 8 Note: 1 &lt;= N &lt;= 10^9 2 &lt;= A &lt;= 40000 2 &lt;= B &lt;= 40000 分析 updating 参考代码class Solution: def nthMagicalNumber(self, N, A, B): def getMiniMul(x,y): a=b=min(x,y) while(True): if(a%x==0 and a%y==0): return a a+=b if(A==B): return (A*N)%(10**9+7) M=getMiniMul(A,B) length=int(M/A+M/B-(M%A==0 and M%B==0)) index=(N-1)%length+1 a=int(index*B/(A+B)) b=int(index*A/(A+B)) target=min(A*(a+1),B*(b+1)) index=(N-1)//length*M+target return index if index &lt; (10**9+7) else index%(10**9+7)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[877.Stone Game]]></title>
    <url>%2F2018%2F07%2F30%2F877-Stone-Game%2F</url>
    <content type="text"><![CDATA[DescriptionAlex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game. 题目链接：https://leetcode.com/problems/stone-game/ Difficulty: medium Example 1:Input: [5,3,4,5] Output: true Explanation: Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true. Note: 2 &lt;= piles.length &lt;= 500 piles.length is even. 1 &lt;= piles[i] &lt;= 500 sum(piles) is odd. 分析 updating 参考代码class Solution: def stoneGame(self, piles): index=piles[0] for pile in piles: if(index!=pile): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[876.Middle of the Linked List]]></title>
    <url>%2F2018%2F07%2F30%2F876-Middle-of-the-Linked-List%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. 题目链接：https://leetcode.com/problems/middle-of-the-linked-list/ Difficulty: easy Example 1:Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge&apos;s serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2:Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100. 分析 updating 参考代码Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def middleNode(self, head): a=head b=head b=b.next while(b!=None): a=a.next b=b.next if(b!=None): b=b.next return a]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]包含min函数的栈]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 题目链接： https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49 分析 用list代替栈，append代替栈的push操作，pop代替栈的pop操作，定义m为最小值 push：将m更新为m和node之间的最小值 pop：pop出最后一个数，如果pop出的是最小值，则重新更新m top：返回list最后一个数 min：返回m note要求时间复杂度应为O（1），但其实测试用例没有这么大，leetcode上有一题上是要返回频率最大的数字，可以借鉴上面的方法，参考代码：https://redtongue.coding.me/2018/08/27/895-Maximum-Frequency-Stack/ 参考代码class Solution: def __init__(self): self.stack=[] self.m=None def push(self, node): # write code here self.stack.append(node) if(self.m==None): self.m=node else: self.m=min(self.m,node) def pop(self): # write code here self.stack.pop() if(self.stack): self.m=min(self.stack) else: self.m=None def top(self): return self.stack[-1] # write code here def min(self): # write code here return self.m 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]顺时针打印矩阵]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 题目链接： https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a 分析 定义y_i,y_j,x_i,x_j为左右上下的边界，没输出一条边，便更新边界值，直到不满足{x_i&lt;=x_j and y_i&lt;=y_j}； 定义index为方向，0为向左，1为向下，2为向右，3为向上。 返回遍历值。 note递归应该也是可以做的 输入 ‘a’ ‘b’ ‘c’ ‘d’ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输出 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 参考代码class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here y_i,y_j,x_i,x_j=0,len(matrix[0])-1,0,len(matrix)-1 index=0 x,y=0,0 li=[] li.append(matrix[x][y]) while(x_i&lt;=x_j and y_i&lt;=y_j): if(index==0): while(y+1&lt;=y_j): y+=1 li.append(matrix[x][y]) x_i+=1 elif(index==1): while(x+1&lt;=x_j): x+=1 li.append(matrix[x][y]) y_j-=1 elif(index==2): while(y-1&gt;=y_i): y-=1 li.append(matrix[x][y]) x_j-=1 else: while(x-1&gt;=x_i): x-=1 li.append(matrix[x][y]) y_i+=1 index=(index+1)%4 return li 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树的镜像]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 题目链接： https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011 分析 二叉树镜像，即把每个结点的左右子树互换； 递归最方便，每次递归过程如下：如果当前结点不为空，左右子树互换，左右子结点进入下一轮递归。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if(root): index=root.left root.left=root.right root.right=index self.Mirror(root.left) self.Mirror(root.right) return root 运行时间： 27ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]树的子结构]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 题目链接： https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88 分析 首先定义一个函数judge判断两颗树是否为包含关系，递归的每一步，判断当前结点是否都不为空且值相同，否则不是包含关系， 判断两个子结点是否为空，空则返回true，反之进入下一轮迭代； 最后，遍历pRoot1，比较每个结点和pRoot2是否为包含关系，是返回true，否则，遍历结束，返回False。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here def judge(p1,p2): if(p1 and p2 and p1.val==p2.val): index=1 else: return 0 if(p2.left): a=judge(p1.left,p2.left) else: a=1 if(p2.right): b=judge(p1.right,p2.right) else: b=1 return index*a*b if(not pRoot2): return False l=[pRoot1] if(not pRoot1): return False while(len(l)!=0): p=pRoot2 if(judge(l[0],pRoot2)): return True else: if(l[0].left): l.append(l[0].left) if(l[0].right): l.append(l[0].right) l=l[1:] return False 运行时间： 28ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]合并两个排序的链表]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 题目链接： https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337 分析 首先比较两个链表的表头，较小的当作新链表的表头； 同时遍历两个链表，一次将较小的结点加入到新链表中，知道有一个链表遍历结束； 将另外一个没有遍历完的链表的剩余部分直接加入到新链表的尾部。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here head=None if(pHead1!=None and pHead2!=None): if(pHead1.val &lt; pHead2.val): head=pHead1 pHead1=pHead1.next else: head=pHead2 pHead2=pHead2.next elif(pHead1!=None): head=pHead1 pHead1=pHead1.next elif(pHead2!=None): head=pHead2 pHead2=pHead2.next h=head while(pHead1!=None and pHead2!=None): if(pHead1.val &lt; pHead2.val): h.next=pHead1 h=pHead1 pHead1=pHead1.next else: h.next=pHead2 h=pHead2 pHead2=pHead2.next if(pHead1!=None): h.next=pHead1 if(pHead2!=None): h.next=pHead2 return head 运行时间： 22ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]反转链表]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，反转链表后，输出新链表的表头。 题目链接： https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca 分析 遍历每个结点，首先保存该结点的next，再将该结点指向前一个结点； 知道遍历到最后一个结点（next为None），将该结点指向前一个结点，并返回该结点。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if(pHead==None or pHead.next==None): return pHead ne=None p=pHead while(p): index=p.next p.next=ne ne=p p=index return ne 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]链表中倒数第k个结点]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，输出该链表中倒数第k个结点。 题目链接： https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a 分析 遍历链表，将所有结点放在list中； 返回list[-k]。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def FindKthToTail(self, head, k): # write code here h=head l=[] while(h): l.append(h) h=h.next if(k&gt;len(l) or k&lt;=0): return return l[-k] 运行时间： 24ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]调整数组顺序使得奇数在偶数前面]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%BE%97%E5%A5%87%E6%95%B0%E5%9C%A8%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 题目链接： https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593 分析 因为需要保持相对位置不变，遍历将奇数和偶数分别放在list中； 组合返回即可。 参考代码class Solution: def reOrderArray(self, array): # write code here s1=[] s2=[] for index in array: if(index%2==0): s2.append(index) else: s1.append(index) return s1+s2 运行时间： 25ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数值的整数次方]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 题目链接： https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00 分析 如果指数exponent是负数，只是将正数次幂的结果取倒数； 结果为result=1乘以base指数exponent次。 参考代码class Solution: def Power(self, base, exponent): # write code here judge=0 if(exponent&lt;0): judge=1 exponent*=(-1) result=1 while(exponent): result*=base exponent-=1 if(judge): return 1/result else: return result 运行时间： 21ms 占用内存： 5852k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二进制中1的个数]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 题目链接： https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8 分析 首先用list存储整数的二进制形式； 如果为正数，返回list的和； 否则，list中{0，1}取反，再加一。 参考代码class Solution: def NumberOf1(self, n): # write code here index=abs(n) li=[0]*32 i=-1 while(index&gt;0): li[i]=index%2 index//=2 i-=1 if(n&gt;0): return sum(li) else: l=[0 if ii else 1 for ii in li] left=1 for i in range(len(l)-1,-1,-1): if(not left): break if(l[i]): if(left): l[i]=0 else: if(left): l[i] = 1 left=0 return sum(l) 运行时间： 21ms 占用内存： 5736k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]矩形覆盖]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 题目链接： https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6 分析 这几题可能是跟斐波那契数列杠上了，同样的分治思想，设F(n)为覆盖2n的大矩形的方法总数，因为都是21的小矩形，所以F(n-1)和F(n-2)可以把F(n)的所有可能性覆盖，虽然F(n-2)到F(n)之间的2*2的剩余有两种覆盖方法，但是其中一种是F(n-1)中已经包含的； 代码也就显而易见了。 参考代码class Solution: def rectCover(self, number): # write code here if(number==0): return 0 a,b=1,1 while(number): a,b=b,a+b number-=1 return a 运行时间： 21ms 占用内存： 5732k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]变态跳台阶]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题目链接： https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387 在跳台阶中的错误代码中考虑可能会有比较厉害的青蛙，万万没想到，来了个变态。 分析 在跳台阶中，青蛙一次只能跳一级或跳两级,用分治的思想的来想，那么青蛙的最后一跳也只能是一个台阶或两个台阶，设F(n)为n级的台阶总共的跳法总数，那么F(n)=F(n-1)+F(n-2)； 同理，虽然变态，但是$F(n) = \sum_{i=0}^{n-1}{F(i)}$，其中F(0)=1 这个规律是显而易见的，但是我们列出来几项方便看的更清楚，{1，2，4，8，16，……} 虽然变态，但是代码很溜。 参考代码class Solution: def jumpFloorII(self, number): # write code here return 2**(number-1) 运行时间： 22ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]跳台阶]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目链接： https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4 分析 刚看到这个题目我想的是用递归来做，可惜失败了，时间超限； 后来想一想青蛙一次只能跳一级或跳两级，他每一步选择只有两个，用递归确实浪费了； 用分治的思想的来想，那么青蛙的最后一跳也只能是一个台阶或两个台阶，设F(n)为n级的台阶总共的跳法总数，那么F(n)=F(n-1)+F(n-2)。 参考代码class Solution: def jumpFloor(self, number): # write code here a,b=1,1 while(number): a,b=b,a+b number-=1 return a 运行时间： 21ms 占用内存： 5732k 递归代码好吧，这是错误代码，但是万一下一次青蛙比较厉害，可以很多台阶，就可以借鉴了。 class Solution: def jumpFloor(self, number): if(n==0): return 1 else: #如果青蛙比较厉害，下面就需要相应修改了 if(n&gt;1): a=self.jumpFloor(n-1) a+=self.jumpFloor(n-2) else: a=self.jumpFloor(n-1) return a return _inter(number)]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]斐波那契数列]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 题目链接： https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3 分析 斐波那契数列如：1，1，2，3，5，8…… ，即F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2） 额外增加一个0，a=0,b=1代表前两个数字，每次只需将b赋值给a，a+b赋值给b，循环次数即斐波那契数列项数。 参考代码class Solution: def Fibonacci(self, n): # write code here a,b=0,1 while(n): a,b=b,a+b n-=1 return a 运行时间： 30ms 占用内存： 5644k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]旋转数组的最小数字]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 题目链接： https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba 分析 输入是一个非减排序的数组，如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，所以最小数字就是第一个小于前面数字的数字。 如果数组长度为0，返回0。 参考代码class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if(len(rotateArray)==0): return 0 index=rotateArray[0] for i in rotateArray: if i &lt; index: return i 运行时间： 549ms 占用内存： 5860k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]用两个栈实现队列]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题目链接： https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6 分析 栈是先进后出，队列是先进先出，用list的append代表栈的push操作，list的pop代表栈的pop操作； 用s1存储队列push的数据，s2存储队列需要pop的数据； 如果s2为空则将s1的所有数据pop出来后append到s2中，以此将数据反转； 用s2的pop替代队列的pop操作。 参考代码class Solution: def __init__(self): self.s1=[] self.s2=[] def push(self, node): # write code here self.s1.append(node) def pop(self): # return xx if(not self.s2): while(self.s1): self.s2.append(self.s1.pop()) return self.s2.pop() 运行时间： 28ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]重建二叉树]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目链接： https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6 分析 如题目中所给的例子，前序：{1,2,4,7,3,5,6,8}，中序：{4,7,2,1,5,3,8,6}； 前序是“根左右”，中序是“左根右”，所以{1}是根节点，左子树的前序是{2,4,7}，左子树的中序是{4,7,2}，右子树的前序{3,5,6,8}，右子树的中序是{5,3,8,6}，这是一次迭代过程； 以此类推，返回根节点。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): root=None if(len(pre) != 0 and len(tin)!=0): root=TreeNode(pre[0]) index=tin.index(pre[0]) root.left=self.reConstructBinaryTree(pre[1:index+1],tin[:index]) root.right=self.reConstructBinaryTree(pre[index+1:],tin[index+1:]) return root 运行时间： 45ms 占用内存： 5856k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]从尾到头打印链表]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 题目链接： https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035 分析 从头指针开支遍历链表，将每个节点的值（ListNode.val）存储到list中，要求是从尾到头，所以每次添加到list中时用list=[ListNode.val]+list。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here li=[] node=listNode while(node!=None): li=[node.val]+li node=node.next return li 运行时间： 22ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]替换空格]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 题目链接： https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423 分析 用一个新变量存储需返回的字符串newStr，逐个遍历源字符串，遇到空格newStr+=’%20’。 参考代码class Solution: # s 源字符串 def replaceSpace(self, s): newStr=&apos;&apos; for i in s: if(i==&apos; &apos;): newStr+=&apos;%20&apos; else: newStr+=i return newStr 运行时间： 23ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二维数组中的查找]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目链接： https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e 分析 每一行都按照从左到右递增，每一列都按照从上到下递增，所以每一行最大数是最后一个 比较每一行的最后一个数字与target的大小，如果target大，则目标在下一行，否则，目标在这一行中，将这一行的数字逐个与target比较。 如果到最后一行也没有与target相等的数，返回False 参考代码class Solution: # array 二维列表 def Find(self, target, array): for row in array: if(len(row)&gt;0 and target&gt;row[-1]): continue else: for i in row: if(i==target): return True return False 运行时间： 184ms 占用内存： 5724k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>查找</tag>
      </tags>
  </entry>
</search>
