<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1004.Max Consecutive Ones III（最大连续1的个数 III）]]></title>
    <url>%2F2019%2F03%2F03%2F1004-Max-Consecutive-Ones-III%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of 0s and 1s, we may change up to K values from 0 to 1.Return the length of the longest (contiguous) subarray that contains only 1s. 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。返回仅包含 1 的最长（连续）子数组的长度。 题目链接：https://leetcode.com/problems/max-consecutive-ones-iii/ Difficulty: medium Example 1:Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2:Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 Output: 10 Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Note: 1 &lt;= A.length &lt;= 20000 0 &lt;= K &lt;= A.length A[i] is 0 or 1 分析 压缩A，遍历A，存储每一部分0或1的个数，形如例一：li=[(1,3),(0,3),(1,4),(0,1)]; 从前往后遍历，得到包含最多1部分的组合，其中0部分的长度要小于K； 记录每一次遍历得到的最大长度（即1的长度加上可变换的0的长度）； 可变换0的长度是min（K，当前连续段中0的最大个数（1部分中间的0加上两端的0）） 返回最大长度； 注意，不能直接返回1部分的长度加K，其中的0可能没有这么多。 参考代码class Solution(object): def longestOnes(self, A, K): li=[] index=A[0] s=0 for a in A: if(a==index): s+=1 else: li.append((index,s)) s=1 index=a li.append((index,s)) if(len(li)==1): return K index = 0 if(li[0][0]==0): index=1 s=0 Max=0 for i in range(index,len(li),2): j=i s=li[i][1] k=0 j+=2 while(j&lt;len(li) and (k+li[j-1][1])&lt;=K): s+=li[j][1] k+=li[j-1][1] j+=2 ok=0 if(i&gt;=1): ok+=li[i-1][1] if(j-1&lt;len(li)): ok+=li[j-1][1] mid=min(K-k,ok) kk=k+mid Max=max((s+kk),Max) return Max]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003.Check If Word Is Valid After Substitutions（检查替换后的词是否有效）]]></title>
    <url>%2F2019%2F03%2F03%2F1003-Check-If-Word-Is-Valid-After-Substitutions%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given that the string &quot;abc&quot; is valid. From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V. (X or Y may be empty.) Then, X + &quot;abc&quot; + Y is also valid. If for example S = &quot;abc&quot;, then examples of valid strings are: &quot;abc&quot;, &quot;aabcbc&quot;, &quot;abcabc&quot;, &quot;abcabcababcc&quot;. Examples of invalid strings are: &quot;abccba&quot;, &quot;ab&quot;, &quot;cababc&quot;, &quot;bac&quot;. Return true if and only if the given string S is valid. 给定有效字符串 &quot;abc&quot;。 对于任何有效的字符串 V，我们可以将 V 分成两个部分 X 和 Y，使得 X + Y（X 与 Y 连接）等于 V。（X 或 Y 可以为空。）那么，X + &quot;abc&quot; + Y 也同样是有效的。 例如，如果 S = &quot;abc&quot;，则有效字符串的示例是：&quot;abc&quot;，&quot;aabcbc&quot;，&quot;abcabc&quot;，&quot;abcabcababcc&quot;。无效字符串的示例是：&quot;abccba&quot;，&quot;ab&quot;，&quot;cababc&quot;，&quot;bac&quot;。 如果给定字符串 S 有效，则返回 true；否则，返回 false。 题目链接：https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/ Difficulty: medium Example 1:Input: &quot;aabcbc&quot; Output: true Explanation: We start with the valid string &quot;abc&quot;. Then we can insert another &quot;abc&quot; between &quot;a&quot; and &quot;bc&quot;, resulting in &quot;a&quot; + &quot;abc&quot; + &quot;bc&quot; which is &quot;aabcbc&quot;. Example 2:Input: &quot;abcabcababcc&quot; Output: true Explanation: &quot;abcabcabc&quot; is valid after consecutive insertings of &quot;abc&quot;. Then we can insert &quot;abc&quot; before the last letter, resulting in &quot;abcabcab&quot; + &quot;abc&quot; + &quot;c&quot; which is &quot;abcabcababcc&quot;. Example 3:Input: &quot;abccba&quot; Output: false Example 4:Input: &quot;cababc&quot; Output: false Note: 1 &lt;= S.length &lt;= 20000 S[i] is ‘a’, ‘b’, or ‘c’ 分析 每次遍历S，judge为True表示上一次遍历中包含“abc”； 若当前位置加上后两位为“abc”，则指针往后移动三位，judge置为True； 反之加入到s中； 遍历完成，s赋值S； 直至S为“”（返回True），或者某一个遍历没有得到“abc”字串（返回False）。 参考代码class Solution(object): def isValid(self, S): judge=True while(len(S) &gt; 0 and judge): i=0 s=&apos;&apos; judge=False while(i&lt;len(S)): if(i&lt;len(S)-2 and S[i:i+3]==&apos;abc&apos;): i+=3 judge=True else: s+=S[i] i+=1 S=s if(len(S)==0): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002.Find Common Characters（查找常用字符 ）]]></title>
    <url>%2F2019%2F03%2F03%2F1002-Find-Common-Characters%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.You may return the answer in any order. 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。你可以按任意顺序返回答案。 题目链接：https://leetcode.com/problems/find-common-characters/ Difficulty: easy Example 1:Input: [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;] Output: [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;] Example 2:Input: [&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;] Output: [&quot;c&quot;,&quot;o&quot;] Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 A[i][j] is a lowercase letter 分析 遍历A的第一项的每个字母ind，逐次做一下操作； 遍历A其他的项，若包含ind，则将该项中的ind去掉； 若A所有的项都包含ind，则将ind加入到ans中； 返回ans。 参考代码class Solution(object): def commonChars(self, A): ans=[] if(len(A)==1): return list(A[0]) index = A[0] for ind in index: for i in range(1,len(A)): if(ind in A[i]): position=A[i].index(ind) A[i]=A[i][:position]+A[i][position+1:] else: break else: ans.append(ind) return ans]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1000.Minimum Cost to Merge Stones（合并石头的最低成本）]]></title>
    <url>%2F2019%2F03%2F03%2F1000-Minimum-Cost-to-Merge-Stones%2F</url>
    <content type="text"><![CDATA[DescriptionThere are N piles of stones arranged in a row. The i-th pile has stones[i] stones.A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.Find the minimum cost to merge all piles of stones into one pile. If it is impossible, return-1. 有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。 题目链接：https://leetcode.com/problems/minimum-cost-to-merge-stones/ Difficulty: hard Example 1:Input: stones = [3,2,4,1], K = 2 Output: 20 Explanation: We start with [3, 2, 4, 1]. We merge [3, 2] for a cost of 5, and we are left with [5, 4, 1]. We merge [4, 1] for a cost of 5, and we are left with [5, 5]. We merge [5, 5] for a cost of 10, and we are left with [10]. The total cost was 20, and this is the minimum possible. Example 2:Input: stones = [3,2,4,1], K = 3 Output: -1 Explanation: After any merge operation, there are 2 piles left, and we can&apos;t merge anymore. So the task is impossible. Example 3:Input: stones = [3,5,1,2,6], K = 3 Output: 25 Explanation: We start with [3, 5, 1, 2, 6]. We merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6]. We merge [3, 8, 6] for a cost of 17, and we are left with [17]. The total cost was 25, and this is the minimum possible. Note: 1 &lt;= stones.length &lt;= 30 2 &lt;= K &lt;= 30 1 &lt;= stones[i] &lt;= 100 分析 updating 参考代码]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001.Grid Illumination（网格照明）]]></title>
    <url>%2F2019%2F02%2F24%2F1001-Grid-Illumination%2F</url>
    <content type="text"><![CDATA[DescriptionOn a N x N grid of cells, each cell (x, y) with 0 &lt;= x &lt; N and 0 &lt;= y &lt; N has a lamp. Initially, some number of lamps are on. lamps[i] tells us the location of the i-th lamp that is on. Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess). For the i-th query queries[i] = (x, y), the answer to the query is 1 if the cell (x, y) is illuminated, else 0. After each query (x, y) [in the order given by queries], we turn off any lamps that are at cell (x, y) or are adjacent 8-directionally (ie., share a corner or edge with cell (x, y).) Return an array of answers. Each value answer[i] should be equal to the answer of the i-th query queries[i]. 在 N x N 的网格上，每个单元格 (x, y) 上都有一盏灯，其中 0 &lt;= x &lt; N 且 0 &lt;= y &lt; N。 最初，一定数量的灯是亮着的。lamps[i] 告诉我们亮着的第 i 盏灯的位置。每盏灯都照亮其所在 x 轴、y 轴和两条对角线上的每个正方形（类似于国际象棋中的皇后）。 对于第 i 次查询 queries[i] = (x, y)，如果单元格 (x, y) 是被照亮的，则查询结果为 1，否则为 0 。 在每个查询 (x, y) 之后 [按照查询的顺序]，我们关闭位于单元格 (x, y) 上或其相邻 8 个方向上（与单元格 (x, y) 共享一个角或边）的任何灯。 返回答案数组 answer。每个值 answer[i] 应等于第 i 次查询 queries[i] 的结果。 题目链接：https://leetcode.com/problems/grid-illumination/ Difficulty: hard Example 1:输入：N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]] 输出：[1,0] 解释： 在执行第一次查询之前，我们位于 [0, 0] 和 [4, 4] 灯是亮着的。 表示哪些单元格亮起的网格如下所示，其中 [0, 0] 位于左上角： 1 1 1 1 1 1 1 0 0 1 1 0 1 0 1 1 0 0 1 1 1 1 1 1 1 然后，由于单元格 [1, 1] 亮着，第一次查询返回 1。在此查询后，位于 [0，0] 处的灯将关闭，网格现在如下所示： 1 0 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 1 1 1 1 1 1 在执行第二次查询之前，我们只有 [4, 4] 处的灯亮着。现在，[1, 0] 处的查询返回 0，因为该单元格不再亮着。 Note: 1 &lt;= N &lt;= 10^9 0 &lt;= lamps.length &lt;= 20000 0 &lt;= queries.length &lt;= 20000 lamps[i].length == queries[i].length == 2 分析 updating（我觉得题目有问题，下面是我当时提交的代码，但是没有通过，手动验证测试用例，我觉得我没错[苦笑]） 参考代码class Solution(object): def gridIllumination(self, N, lamps, queries): answer=[] def get(a,b,x,y): if(a==x or b==y): return True if(abs(a-x)==abs(b-y)): return True return False for query in queries: judge=False for lamp in lamps: if(get(lamp[0],lamp[1],query[0],query[1])): lamps.remove(lamp) if(not judge): judge=True if(judge): answer.append(1) else: answer.append(0) return answer]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[999.Available Captures for Rook（车的可用捕获量）]]></title>
    <url>%2F2019%2F02%2F24%2F999-Available-Captures-for-Rook%2F</url>
    <content type="text"><![CDATA[DescriptionOn an 8 x 8 chessboard, there is one white rook. There also may be empty squares, white bishops, and black pawns. These are given as characters ‘R’, ‘.’, ‘B’, and ‘p’ respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces. The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies. Also, rooks cannot move into the same square as other friendly bishops. Return the number of pawns the rook can capture in one move. 在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。 车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。 返回车能够在一次移动中捕获到的卒的数量。 题目链接：https://leetcode.com/problems/available-captures-for-rook/ Difficulty: easy Example 1: Input: [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] Output: 3 Explanation: In this example the rook is able to capture all the pawns. Example 2: Input: [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] Output: 0 Explanation: Bishops are blocking the rook to capture any pawn. Example 3: Input: [[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] Output: 3 Explanation: The rook can capture the pawns at positions b5, d6 and f5. Note: board.length == board[i].length == 8 board[i][j] is either ‘R’, ‘.’, ‘B’, or ‘p’ There is exactly one cell with board[i][j] == ‘R’ 分析 找到白色车（R）的位置，分别向八个方向寻找卒（p）； 若某个方向上碰到某个象（B）或者棋盘的边缘，则停止该方向的寻找； 若找到卒，Sum加一； 返回Sum。 参考代码class Solution(object): def numRookCaptures(self, board): row,col=0,0 for i in range(8): for j in range(8): if(board[i][j]==&apos;R&apos;): row=i col=j break Sum=0 for i in range(row-1,-1,-1): if(board[i][col]==&quot;B&quot;): break if(board[i][col]==&quot;p&quot;): Sum+=1 break for i in range(row+1,8): if(board[i][col]==&quot;B&quot;): break if(board[i][col]==&quot;p&quot;): Sum+=1 break for j in range(col-1,-1,-1): if(board[row][j]==&quot;B&quot;): break if(board[row][j]==&quot;p&quot;): Sum+=1 break for j in range(col+1,8): if(board[row][j]==&quot;B&quot;): break if(board[row][j]==&quot;p&quot;): Sum+=1 break return Sum]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[998.Maximum Binary Tree II（最大二叉树 II）]]></title>
    <url>%2F2019%2F02%2F24%2F998-Maximum-Binary-Tree-II%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree. Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine: If A is empty, return null. Otherwise, let A[i] be the largest element of A. Create a root node with value A[i]. The left child of root will be Construct([A[0], A[1], ..., A[i-1]]) The right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]]) Return root. Note that we were not given A directly, only a root node root = Construct(A). Suppose B is a copy of A with the value val appended to it. It is guaranteed that B has unique values. Return Construct(B). 最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。 给出最大树的根节点 root。 就像之前的问题那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的： 如果 A 为空，返回 null 否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]]) root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]]) 返回 root 请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A). 假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。 返回 Construct(B)。 题目链接：https://leetcode.com/problems/maximum-binary-tree-ii/ Difficulty: medium Example 1: Input: root = [4,1,3,null,null,2], val = 5 Output: [5,4,null,1,3,null,null,2] Explanation: A = [1,4,2,3], B = [1,4,2,3,5] Example 2: Input: root = [5,2,4,null,1], val = 3 Output: [5,2,4,null,1,null,3] Explanation: A = [2,1,5,4], B = [2,1,5,4,3] Example 3: Input: root = [5,2,3,null,1], val = 4 Output: [5,2,4,null,1,3] Explanation: A = [2,1,5,3], B = [2,1,5,3,4] Note: 1 &lt;= B.length &lt;= 100 分析 由题意知，对于任意子树，根节点大于所有子节点，且每次插入的节点中序遍历序列的尾部，则节点x应插入到某节点a的右子树上（a的值大于x的值），当前位置子树移到a的左子树上； 若x大于root的值，则x左根节点，root左x的左子树； 找到ro1、ro2，其中ro1的值大于x的值，ro2的值小于x的值，ro2是ro1的右子树，x做ro1的右节点，ro2做x的左节点； 若ro2为None，x做ro1的右节点； 返回root。 参考代码Definition for a binary tree node. class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None class Solution(object): def insertIntoMaxTree(self, root, val): p=TreeNode(val) if(root==None): return p if(val&gt;=root.val): p.left=root return p ro1=root ro2=ro1.right while(ro2!=None): if(val&gt;ro2.val): ro1.right=p p.left=ro2 return root else: ro1=ro2 ro2=ro1.right ro1.right=p return root]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[997.Find the Town Judge（找到小镇的法官）]]></title>
    <url>%2F2019%2F02%2F24%2F997-Find-the-Town-Judge%2F</url>
    <content type="text"><![CDATA[DescriptionIn a town, there are N people labelled from 1 to N. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b. If the town judge exists and can be identified, return the label of the town judge. Otherwise, return -1. 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。 如果小镇的法官真的存在，那么： 小镇的法官不相信任何人。 每个人（除了小镇法官外）都信任小镇的法官。 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。 题目链接：https://leetcode.com/problems/find-the-town-judge/ Difficulty: easy Example 1:Input: N = 2, trust = [[1,2]] Output: 2 Example 2:Input: N = 3, trust = [[1,3],[2,3]] Output: 3 Example 3:Input: N = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 Example 4:Input: N = 3, trust = [[1,2],[2,3]] Output: -1 Example 5:Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]] Output: 3 Note: 1 &lt;= N &lt;= 1000 trust.length &lt;= 10000 trust[i] are all different trust[i][0] != trust[i][1] 1 &lt;= trust[i][0], trust[i][1] &lt;= N 分析 初始化字典A，每一项代表每个人被那些人信任； 对于任意trust，a信任b，从A中删除a； 同时若b在A中，则将a添加为信任b的list中； 返回A中被信任N-1次的人，若无，返回-1。 参考代码class Solution: def findJudge(self, N: int, trust: List[List[int]]) -&gt; int: A={} for i in range(N): A[i+1]=[] for t in trust: x,y=t if(x in A): A.pop(x) if(y in A): A[y].append(x) for a in A: if(len(A[a])==N-1): return a return -1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[996.Number of Sequareful Arrays(正方形数组的数目)]]></title>
    <url>%2F2019%2F02%2F17%2F996-Number-of-Sequareful-Arrays%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square. Return the number of permutations of A that are squareful. Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i]. 给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。 返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。 题目链接：https://leetcode.com/problems/number-of-squareful-arrays/ Difficulty: hard Example 1:Input: [1,17,8] Output: 2 Explanation: [1,8,17] and [17,8,1] are the valid permutations. Example 2:Input: [2,2,2] Output: 1 Note: 1 &lt;= A.length &lt;= 12 0 &lt;= A[i] &lt;= 1e9 分析 Solution 参考代码class Solution(object): def numSquarefulPerms(self, A): N = len(A) count = collections.Counter(A) graph = {x: [] for x in count} for x in count: for y in count: if int((x+y)**.5 + 0.5) ** 2 == x+y: graph[x].append(y) def dfs(x, todo): count[x] -= 1 if todo == 0: ans = 1 else: ans = 0 for y in graph[x]: if count[y]: ans += dfs(y, todo - 1) count[x] += 1 return ans return sum(dfs(x, len(A) - 1) for x in count)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Graph</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[995.Minimum Number of K Consecutive Bit Flips(K 连续位的最小翻转次数 )]]></title>
    <url>%2F2019%2F02%2F17%2F995-Minimum-Number-of-K-Consecutive-Bit-Flips%2F</url>
    <content type="text"><![CDATA[DescriptionIn an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0. Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1. 在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。 返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。 题目链接：https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/ Difficulty: hard Example 1:Input: A = [0,1,0], K = 1 Output: 2 Explanation: Flip A[0], then flip A[2]. Example 2:Input: A = [1,1,0], K = 2 Output: -1 Explanation: No matter how we flip subarrays of size 2, we can&apos;t make the array become [1,1,1]. Example 3:Input: A = [0,0,0,1,0,1,1,0], K = 3 Output: 3 Explanation: Flip A[0],A[1],A[2]: A becomes [1,1,1,1,0,1,1,0] Flip A[4],A[5],A[6]: A becomes [1,1,1,1,1,0,0,0] Flip A[5],A[6],A[7]: A becomes [1,1,1,1,1,1,1,1] Note: 1 &lt;= A.length &lt;= 30000 1 &lt;= K &lt;= A.length 分析 用li记录每个位需要翻转的情况（初始为零），遍历每个位，index记录当前位的翻转情况； 遇到某一位反转之后为0，则说明该点需要翻转以此，首先将index对1取异或（相当于0变成1，1变成0），再将K位之后对应的li对1取异或，若超出li的长度说明，不能将所有的数字翻转成1，返回-1，Sum加一； 遇到某一位反转之后为1，继续下一位； 遍历完成，返回记录的翻转次数Sum。 时间复杂度为O(n). 错误分析：用li记录每个位翻转情况，遍历，遇到需要翻转的位，将后续K位的翻转情况记录，即对应li中的记录取异或，答案正确，但是时间复杂度为O(nk),时间超限。 参考代码class Solution(object): def minKBitFlips(self, A, K): index=0 Sum=0 li=[0]*len(A) i=0 while(i &lt; (len(A))): index ^= li[i] if(A[i]^index == 0): Sum += 1 index ^= 1 if(i+K&lt;len(A)): li[i+K] ^= 1 if(i+K&gt;len(A)): return -1 i+=1 return Sum]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[994.Rotting Oranges（腐烂的橘子 ）]]></title>
    <url>%2F2019%2F02%2F17%2F994-Rotting-Oranges%2F</url>
    <content type="text"><![CDATA[DescriptionIn a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead. 在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 题目链接：https://leetcode.com/problems/rotting-oranges/ Difficulty: easy Example 1:Input: [[2,1,1],[1,1,0],[0,1,1]] Output: 4 Example 2:Input: [[2,1,1],[0,1,1],[1,0,1]] Output: -1 Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally. Example 3:Input: [[0,2]] Output: 0 Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0. Note: 1 &lt;= grid.length &lt;= 10 1 &lt;= grid[0].length &lt;= 10 grid[i][j] is only 0, 1, or 2. 分析 用size记录好橘子的个数，每分钟（即每次循环）遍历所有坏橘子，将其周围的好橘子感染变坏，同时修改size值以及grid中相应的数字； 直至size等于0或者不再改变，停止循环； size等于零，返回time，反之，说明有橘子没有变坏，返回-1. 参考代码class Solution(object): def orangesRotting(self, grid): time=0 size=0 for row in grid: for col in row: if(col == 1): size+=1 row=len(grid) col=len(grid[0]) def get(x,y,gr): if(x-1&gt;=0 and gr[x-1][y]==2): return True if(y-1&gt;=0 and gr[x][y-1]==2): return True if(x+1&lt;len(gr) and gr[x+1][y]==2): return True if(y+1&lt;len(gr[0]) and gr[x][y+1]==2): return True return False import copy judge=True while(judge and size&gt;0): judge=False new_grid=copy.deepcopy(grid) for row in range(len(grid)): for col in range(len(grid[0])): if(grid[row][col]==1 and get(row,col,grid)): new_grid[row][col]=2 #print(row,col) size-=1 judge=True grid=copy.deepcopy(new_grid) #print(grid) time+=1 if(not judge): return -1 return time]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[993.Cousins in Binary Tree（二叉树的堂兄弟节点 ）]]></title>
    <url>%2F2019%2F02%2F17%2F993-Cousins-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionIn a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.Return true if and only if the nodes corresponding to the values x and y are cousins. 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 题目链接：https://leetcode.com/problems/cousins-in-binary-tree/ Difficulty: easy Example 1:Input: root = [1,2,3,4], x = 4, y = 3 Output: false Example 2:Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true Example 3:Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false Note: The number of nodes in the tree will be between 2 and 100. Each node has a unique integer value from 1 to 100. 分析 定义一个judge函数用于判断x,y是否为兄弟，判断方式如下：对二叉树做前序遍历，若某一个节点的左节点值等于x且该节点的右节点值等于y，则x，y为兄弟；相反还要做一次判断，x是否为右节点，y是否为左节点； 避免为兄弟节点之后，定义get函数获得xy对应节点在树中的深度，若相等则为堂兄弟节点。get是一个前序遍历，index记录深度。 参考代码Definition for a binary tree node. class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None class Solution(object): def isCousins(self, root, x, y): def get(ro,tar,index): if(ro!=None and ro.val==tar): return index else: t=0 if(ro.left): t=max(t,get(ro.left,tar,index+1)) if(ro.right): t=max(t,get(ro.right,tar,index+1)) return t def judge(ro,x,y): if(ro==None): return True else: jud=True judx=False judy=False if(ro.left): jud = jud and judge(ro.left,x,y) if(ro.left.val==x): judx=True if(ro.right): jud = jud and judge(ro.right,x,y) if(ro.right.val==y): judy=True if(judx and judy): jud=False return jud if(not judge(root,x,y) or not judge(root,y,x)): return False if(get(root,x,0)==get(root,y,0)): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[980.Unique Paths III(不同路径 III)]]></title>
    <url>%2F2019%2F01%2F20%2F980-Unique-Paths-III%2F</url>
    <content type="text"><![CDATA[DescriptionOn a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once. 在二维网格 grid 上，有 4 种类型的方格： 1 表示起始方格。且只有一个起始方格。 2 表示结束方格，且只有一个结束方格。 0 表示我们可以走过的空方格。 -1 表示我们无法跨越的障碍。 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。 题目链接：https://leetcode.com/problems/unique-paths-iii/ Difficulty: hard Example 1:Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] Output: 2 Explanation: We have the following two paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) Example 2:Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]] Output: 4 Explanation: We have the following four paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) Example 3:Input: [[0,1],[2,0]] Output: 0 Explanation: There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid. Note: 1 &lt;= grid.length * grid[0].length &lt;= 20 分析 updating（Solution） 参考代码class Solution: def uniquePathsIII(self, grid): R, C = len(grid), len(grid[0]) def neighbors(r, c): for nr, nc in ((r-1, c), (r, c-1), (r+1, c), (r, c+1)): if 0 &lt;= nr &lt; R and 0 &lt;= nc &lt; C and grid[nr][nc] % 2 == 0: yield nr, nc todo = 0 for r, row in enumerate(grid): for c, val in enumerate(row): if val != -1: todo += 1 if val == 1: sr, sc = r, c if val == 2: tr, tc = r, c self.ans = 0 def dfs(r, c, todo): todo -= 1 if todo &lt; 0: return if r == tr and c == tc: if todo == 0: self.ans += 1 return grid[r][c] = -1 for nr, nc in neighbors(r, c): dfs(nr, nc, todo) grid[r][c] = 0 dfs(sr, sc, todo) return self.ans]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[979.Distribute Coins in Binary Tree(在二叉树中分配硬币)]]></title>
    <url>%2F2019%2F01%2F20%2F979-Distribute-Coins-in-Binary-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total. In one move, we may choose two adjacent nodes and move one coin from one node to another. (The move may be from parent to child, or from child to parent.) Return the number of moves required to make every node have exactly one coin. 给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。 在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。 返回使每个结点上只有一枚硬币所需的移动次数。 题目链接：https://leetcode.com/problems/distribute-coins-in-binary-tree/ Difficulty: medium Example 1:Input: [3,0,0] Output: 2 Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child. Example 2:Input: [0,3,0] Output: 3 Explanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child. Example 3:Input: [1,0,2] Output: 2 Example 4:Input: [1,0,0,null,3] Output: 4 Note: 1&lt;= N &lt;= 100 0 &lt;= node.val &lt;= N 分析 每一次递归记录当前节点的硬币变化情况：如left是左节点多出的硬币，right是右节点多出的硬币，index是当前节点多出的硬币； 用全局变量Sum记录硬币移动的次数； 返回Sum。 参考代码Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def distributeCoins(self, root): if(root==None): return 0 Sum=0 def _iter(ro): left=0 if(ro.left!=None): left=_iter(ro.left) right=0 if(ro.right!=None): right=_iter(ro.right) index=ro.val+left+right-1 nonlocal Sum Sum+=abs(left) Sum+=abs(right) return index _iter(root) return Sum]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[978.Longest Turbulent Subarray(最长湍流子数组)]]></title>
    <url>%2F2019%2F01%2F20%2F978-Longest-Turbulent-Subarray%2F</url>
    <content type="text"><![CDATA[DescriptionA subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if: For i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is odd, and A[k] &lt; A[k+1] when k is even;OR, for i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is even, and A[k] &lt; A[k+1]when k is odd.That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray. Return the length of a maximum size turbulent subarray of A. 当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组： 若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]；或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。 返回 A 的最大湍流子数组的长度。 题目链接：https://leetcode.com/problems/longest-turbulent-subarray/ Difficulty: medium Example 1:Input: [9,4,2,10,7,8,8,1,9] Output: 5 Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5]) Example 2:Input: [4,8,12,16] Output: 2 Example 3:Input: [100] Output: 1 Note: 1 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt;= 10^9 分析 用li记录以当前数字结尾的字串的湍流子数组的长度； 向后遍历，若当前数字与下一个数字的大小关系与上一组数字的大小关系一致（若上一组关系是“大于”则这一组的关系是“小于”，反之则是大于，注：“等于”是不满足的），则满足长度加一； 反之置2； 初始为1； 返回li的最大值。 参考代码class Solution: def maxTurbulenceSize(self, A): def get(a,b,i): if(i%2==0): if(a&lt;b): return True else: return False else: if(a&gt;b): return True else: return False li=[1] index=[] for i in range(len(A)-1): judge=get(A[i],A[i+1],i) if(A[i]==A[i+1]): index.append(&quot;#&quot;) li.append(1) continue if(len(index)==0 or index[-1]==&quot;#&quot;): index.append(judge) li.append(2) else: if(judge==index[-1]): index.append(judge) li.append(li[-1]+1) else: index.append(judge) li.append(2) return max(li)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[977.Squares of a Sorted Array（有序数组的平方）]]></title>
    <url>%2F2019%2F01%2F20%2F977-Squares-of-a-Sorted-Array%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 题目链接：https://leetcode.com/problems/squares-of-a-sorted-array/ Difficulty: easy Example 1:Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Example 2:Input: [-7,-3,2,3,11] Output: [4,9,9,49,121] Note: 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A is sorted in non-decreasing order. 分析 找到最小点（距离0最近的点）index； 设置两个游标i，j从index向左右移动； 移动判断移动i或j，得到有序数组的平方。 参考代码class Solution: def sortedSquares(self, A): target=abs(A[0]) index=0 for i in range(len(A)): if(abs(A[i])&lt;=target): index=i target=abs(A[i]) else: break i=index j=index+1 li=[] while(i &gt;= 0 and j &lt; len(A)): if(abs(A[i])&lt;abs(A[j])): li.append(A[i]**2) i-=1 else: li.append(A[j]**2) j+=1 while(i&gt;=0): li.append(A[i]**2) i-=1 while(j&lt;len(A)): li.append(A[j]**2) j+=1 return li]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
        <tag>Sort</tag>
        <tag>Two Points</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[976.Largest Perimeter Triangle（三角形的最大周长）]]></title>
    <url>%2F2019%2F01%2F14%2F976-Largest-Perimeter-Triangle%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths. If it is impossible to form any triangle of non-zero area, return 0. 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0。 题目链接：https://leetcode.com/problems/largest-perimeter-triangle/ Difficulty: easy Example 1:Input: [2,1,2] Output: 5 Example 2:Input: [1,2,1] Output: 0 Example 3:Input: [3,2,3,4] Output: 10 Example 4:Input: [3,6,2,3] Output: 8 Note: 3 &lt;= A.length &lt;= 10000 1 &lt;= A[i] &lt;= 10^6 分析 updating（Solution） 参考代码class Solution(object): def largestPerimeter(self, A): A.sort() for i in xrange(len(A) - 3, -1, -1): if A[i] + A[i+1] &gt; A[i+2]: return A[i] + A[i+1] + A[i+2] return 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[975.Odd Even Jump(奇偶跳)]]></title>
    <url>%2F2019%2F01%2F14%2F975-Odd-Even-Jump%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given an integer array A. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, …) jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, …) jumps in the series are called even numbered jumps. You may from index i jump forward to index j (with i &lt; j) in the following way: During odd numbered jumps (ie. jumps 1, 3, 5, …), you jump to the index j such that A[i] &lt;= A[j] and A[j] is the smallest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j. During even numbered jumps (ie. jumps 2, 4, 6, …), you jump to the index j such that A[i] &gt;= A[j] and A[j] is the largest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j. (It may be the case that for some index i, there are no legal jumps.) A starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.) Return the number of good starting indexes. 给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5… 次跳跃称为奇数跳跃，而第 2、4、6… 次跳跃称为偶数跳跃。 你可以按以下方式从索引 i 向后跳转到索引 j（其中 i &lt; j）： 在进行奇数跳跃时（如，第 1，3，5… 次跳跃），你将会跳到索引 j，使得 A[i] &lt;= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。 在进行偶数跳跃时（如，第 2，4，6… 次跳跃），你将会跳到索引 j，使得 A[i] =&gt; A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。 （对于某些索引 i，可能无法进行合乎要求的跳跃。） 如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。 返回好的起始索引的数量。 题目链接：https://leetcode.com/problems/odd-even-jump/ Difficulty: hard Example 1:Input: [10,13,12,14,15] Output: 2 Explanation: From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can&apos;t jump any more. From starting index i = 1 and i = 2, we can jump to i = 3, then we can&apos;t jump any more. From starting index i = 3, we can jump to i = 4, so we&apos;ve reached the end. From starting index i = 4, we&apos;ve reached the end already. In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps. Example 2:Input: [2,3,1,1,4] Output: 3 Explanation: From starting index i = 0, we make jumps to i = 1, i = 2, i = 3: During our 1st jump (odd numbered), we first jump to i = 1 because A[1] is the smallest value in (A[1], A[2], A[3], A[4]) that is greater than or equal to A[0]. During our 2nd jump (even numbered), we jump from i = 1 to i = 2 because A[2] is the largest value in (A[2], A[3], A[4]) that is less than or equal to A[1]. A[3] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3. During our 3rd jump (odd numbered), we jump from i = 2 to i = 3 because A[3] is the smallest value in (A[3], A[4]) that is greater than or equal to A[2]. We can&apos;t jump from i = 3 to i = 4, so the starting index i = 0 is not good. In a similar manner, we can deduce that: From starting index i = 1, we jump to i = 4, so we reach the end. From starting index i = 2, we jump to i = 3, and then we can&apos;t jump anymore. From starting index i = 3, we jump to i = 4, so we reach the end. From starting index i = 4, we are already at the end. In total, there are 3 different starting indexes (i = 1, i = 3, i = 4) where we can reach the end with some number of jumps. Example 3:Input: [5,1,3,4,2] Output: 3 Explanation: We can reach the end from starting indexes 1, 2, and 4. Note: 1 &lt;= A.length &lt;= 20000 0 &lt;= A[i] &lt; 100000 分析 updating（Solution） 参考代码class Solution(object): def oddEvenJumps(self, A): N = len(A) def make(B): ans = [None] * N stack = [] # invariant: stack is decreasing for i in B: while stack and i &gt; stack[-1]: ans[stack.pop()] = i stack.append(i) return ans B = sorted(range(N), key = lambda i: A[i]) oddnext = make(B) B.sort(key = lambda i: -A[i]) evennext = make(B) odd = [False] * N even = [False] * N odd[N-1] = even[N-1] = True for i in xrange(N-2, -1, -1): if oddnext[i] is not None: odd[i] = even[oddnext[i]] if evennext[i] is not None: even[i] = odd[evennext[i]] return sum(odd)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[974.Subarray Sums Divisible by K(和可被 K 整除的子数组)]]></title>
    <url>%2F2019%2F01%2F14%2F974-Subarray-Sums-Divisible-by-K%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K. 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 题目链接：https://leetcode.com/problems/subarray-sums-divisible-by-k/ Difficulty: medium Example 1:Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Note: 1 &lt;= A.length &lt;= 30000 -10000 &lt;= A[i] &lt;= 10000 2 &lt;= K &lt;= 10000 分析 updating（Solution） 参考代码class Solution(object): def subarraysDivByK(self, A, K): P = [0] for x in A: P.append((P[-1] + x) % K) count = collections.Counter(P) return sum(v*(v-1)/2 for v in count.values())]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[973.K Cloest Points to Origin(最接近原点的 K 个点)]]></title>
    <url>%2F2019%2F01%2F14%2F973-K-Cloest-Points-to-Origin%2F</url>
    <content type="text"><![CDATA[DescriptionWe have a list of points on the plane. Find the K closest points to the origin (0, 0). (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) 我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。 （这里，平面上两点之间的距离是欧几里德距离。） 你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。 题目链接：https://leetcode.com/problems/k-closest-points-to-origin/ Difficulty: easy Example 1:Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin. We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]]. Example 2:Input: points = [[3,3],[5,-1],[-2,4]], K = 2 Output: [[3,3],[-2,4]] (The answer [[-2,4],[3,3]] would also be accepted.) Note: 1 &lt;= K &lt;= points.length &lt;= 10000 -10000 &lt; points[i][0] &lt; 10000 -10000 &lt; points[i][1] &lt; 10000 分析 updating（Solution） 参考代码class Solution(object): def kClosest(self, points, K): points.sort(key = lambda P: P[0]**2 + P[1]**2) return points[:K]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Divide and Conquer</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[964.Least Operators to Express Number(表示数字的最少运算符)]]></title>
    <url>%2F2018%2F12%2F23%2F964-Least-Operators-to-Express-Number%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3. When writing such an expression, we adhere to the following conventions: The division operator (/) returns rational numbers. There are no parentheses placed anywhere. We use the usual order of operations: multiplication and division happens before addition and subtraction. It’s not allowed to use the unary negation operator (-). For example, “x - x“ is a valid expression as it only uses subtraction, but “-x + x“ is not because it uses negation. We would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used. 给定一个正整数 x，我们将会写出一个形如 x (op1) x (op2) x (op3) x … 的表达式，其中每个运算符 op1，op2，… 可以是加、减、乘、除（+，-，，或是 /）之一。例如，对于 x = 3，我们可以写出表达式 3 3 / 3 + 3 - 3，该式的值为 3 。 在写这样的表达式时，我们需要遵守下面的惯例： 除运算符（/）返回有理数。 任何地方都没有括号。 我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。 不允许使用一元否定运算符（-）。例如，“x - x” 是一个有效的表达式，因为它只使用减法，但是 “-x + x” 不是，因为它使用了否定运算符。 我们希望编写一个能使表达式等于给定的目标值 target 且运算符最少的表达式。返回所用运算符的最少数量。 题目链接：https://leetcode.com/problems/least-operators-to-express-number/ Difficulty: hard Example 1:Input: x = 3, target = 19 Output: 5 Explanation: 3 * 3 + 3 * 3 + 3 / 3. The expression contains 5 operations. Example 2:Input: x = 5, target = 501 Output: 8 Explanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5. The expression contains 8 operations. Example 3:Input: x = 100, target = 100000000 Output: 3 Explanation: 100 * 100 * 100 * 100. The expression contains 3 operations. Note: 2 &lt;= x &lt;= 100 1 &lt;= target &lt;= 2 * 10^8 分析 updating（Solution） 参考代码from functools import lru_cache class Solution(object): def leastOpsExpressTarget(self, x, target): cost = list(range(40)) cost[0] = 2 @lru_cache(None) def dp(i, targ): if targ == 0: return 0 if targ == 1: return cost[i] if i &gt;= 39: return float(&apos;inf&apos;) t, r = divmod(targ, x) return min(r * cost[i] + dp(i+1, t), (x-r) * cost[i] + dp(i+1, t+1)) return dp(0, target) - 1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[963.Minimum Area Rectangle II(最小面积矩形 II)]]></title>
    <url>%2F2018%2F12%2F23%2F963-Minimum-Area-Rectangle-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes. If there isn’t any rectangle, return 0. 给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边不一定平行于 x 轴和 y 轴。 如果没有任何矩形，就返回 0。 题目链接：https://leetcode.com/problems/minimum-area-rectangle-ii/ Difficulty: medium Example 1: Input: [[1,2],[2,1],[1,0],[0,1]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2. Example 2: Input: [[0,1],[2,1],[1,1],[1,0],[2,0]] Output: 1.00000 Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1. Example 3: Input: [[0,3],[1,2],[3,1],[1,3],[2,1]] Output: 0 Explanation: There is no possible rectangle to form from these points. Example 4: Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]] Output: 2.00000 Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2. Note: 1 &lt;= points.length &lt;= 50 0 &lt;= points[i][0] &lt;= 40000 0 &lt;= points[i][1] &lt;= 40000 All points are distinct. Answers within 10^-5 of the actual value will be accepted as correct. 分析 updating（Solution） 参考代码class Solution(object): def minAreaFreeRect(self, points): EPS = 1e-7 points = set(map(tuple, points)) ans = float(&apos;inf&apos;) for p1, p2, p3 in itertools.permutations(points, 3): p4 = p2[0] + p3[0] - p1[0], p2[1] + p3[1] - p1[1] if p4 in points: v21 = complex(p2[0] - p1[0], p2[1] - p1[1]) v31 = complex(p3[0] - p1[0], p3[1] - p1[1]) if abs(v21.real * v31.real + v21.imag * v31.imag) &lt; EPS: area = abs(v21) * abs(v31) if area &lt; ans: ans = area return ans if ans &lt; float(&apos;inf&apos;) else 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[962.Maximum Width Ramp(最大宽度坡)]]></title>
    <url>%2F2018%2F12%2F23%2F962-Maximum-Width-Ramp%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of integers, a ramp is a tuple (i, j) for which i &lt; j and A[i] &lt;= A[j]. The width of such a ramp is j - i. Find the maximum width of a ramp in A. If one doesn’t exist, return 0. 给定一个整数数组 A，坡是元组 (i, j)，其中 i &lt; j 且 A[i] &lt;= A[j]。这样的坡的宽度为 j - i。 找出 A 中的坡的最大宽度，如果不存在，返回 0 。 题目链接：https://leetcode.com/problems/maximum-width-ramp/ Difficulty: medium Example 1:Input: [6,0,8,2,1,5] Output: 4 Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5. Example 2:Input: [9,8,1,0,1,9,4,0,4,1] Output: 7 Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): A[2] = 1 and A[9] = 1. Note: 2 &lt;= A.length &lt;= 50000 0 &lt;= A[i] &lt;= 50000 分析 updating（Solution） 参考代码class Solution(object): def maxWidthRamp(self, A): ans = 0 m = float(&apos;inf&apos;) for i in sorted(range(len(A)), key = A.__getitem__): ans = max(ans, i - m) m = min(m, i) return ans]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[961.N-Repeated Element in Size 2N Array（重复 N 次的元素）]]></title>
    <url>%2F2018%2F12%2F23%2F961-N-Repeated-Element-in-Size-2N-Array%2F</url>
    <content type="text"><![CDATA[DescriptionIn a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. 在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。 返回重复了 N 次的那个元素。 题目链接：https://leetcode.com/problems/n-repeated-element-in-size-2n-array Difficulty: easy Example 1:Input: [1,2,3,3] Output: 3 Example 2:Input: [2,1,2,5,3,2] Output: 2 Example 3:Input: [5,1,5,2,5,3,5,4] Output: 5 Note: 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length is even 分析 updating 参考代码class Solution: def repeatedNTimes(self, A): D=set() for a in A: if(a not in D): D.add(a) else: return a return]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[960.Delete Columns to Make Sorted III]]></title>
    <url>%2F2018%2F12%2F19%2F960-Delete-Columns-to-Make-Sorted-III%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = [&quot;babca&quot;,&quot;bbazb&quot;] and deletion indices {0, 1, 4}, then the final array after deletions is [&quot;bc&quot;,&quot;az&quot;]. Suppose we chose a set of deletion indices D such that after deletions, the final array has every element (row) in lexicographic order. For clarity, A[0] is in lexicographic order (ie. A[0][0] &lt;= A[0][1] &lt;= ... &lt;= A[0][A[0].length - 1]), A[1] is in lexicographic order (ie. A[1][0] &lt;= A[1][1] &lt;= ... &lt;= A[1][A[1].length - 1]), and so on. Return the minimum possible value of D.length. 给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。 比如，有 A = [&quot;babca&quot;,&quot;bbazb&quot;]，删除索引序列 {0, 1, 4}，删除后 A 为[&quot;bc&quot;,&quot;az&quot;]。 假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组的行中的每个元素都是按字典序排列的。 清楚起见，A[0] 是按字典序排列的（即，A[0][0] &lt;= A[0][1] &lt;= ... &lt;= A[0][A[0].length - 1]），A[1] 是按字典序排列的（即，A[1][0] &lt;= A[1][1] &lt;= ... &lt;= A[1][A[1].length - 1]），依此类推。 请你返回 D.length 的最小可能值。 题目链接：https://leetcode.com/problems/delete-columns-to-make-sorted-iii/ Difficulty: hard Example 1:Input: [&quot;babca&quot;,&quot;bbazb&quot;] Output: 3 Explanation: After deleting columns 0, 1, and 4, the final array is A = [&quot;bc&quot;, &quot;az&quot;]. Both these rows are individually in lexicographic order (ie. A[0][0] &lt;= A[0][1] and A[1][0] &lt;= A[1][1]). Note that A[0] &gt; A[1] - the array A isn&apos;t necessarily in lexicographic order. Example 2:Input: [&quot;edcba&quot;] Output: 4 Explanation: If we delete less than 4 columns, the only row won&apos;t be lexicographically sorted. Example 3:Input: [&quot;ghi&quot;,&quot;def&quot;,&quot;abc&quot;] Output: 0 Explanation: All rows are already lexicographically sorted. Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 分析 updating（Solution） 参考代码class Solution(object): def minDeletionSize(self, A): W = len(A[0]) dp = [1] * W for i in xrange(W-2, -1, -1): for j in xrange(i+1, W): if all(row[i] &lt;= row[j] for row in A): dp[i] = max(dp[i], 1 + dp[j]) return W - max(dp)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[959.Regions Cut By Slashes]]></title>
    <url>%2F2018%2F12%2F19%2F959-Regions-Cut-By-Slashes%2F</url>
    <content type="text"><![CDATA[DescriptionIn a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a/, \, or blank space. These characters divide the square into contiguous regions. (Note that backslash characters are escaped, so a \ is represented as “\“.) Return the number of regions. 在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。 （请注意，反斜杠字符是转义的，因此 \ 用 “\“ 表示。）。 题目链接：https://leetcode.com/problems/regions-cut-by-slashes/ Difficulty: medium Example 1:Input: [ &quot; /&quot;, &quot;/ &quot; ] Output: 2 Explanation: The 2x2 grid is as follows: Example 2:Input: [ &quot; /&quot;, &quot; &quot; ] Output: 1 Explanation: The 2x2 grid is as follows: Example 3:Input: [ &quot;\\/&quot;, &quot;/\\&quot; ] Output: 4 Explanation: (Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.) The 2x2 grid is as follows: Example 4:Input: [ &quot;/\\&quot;, &quot;\\/&quot; ] Output: 5 Explanation: (Recall that because \ characters are escaped, &quot;/\\&quot; refers to /\, and &quot;\\/&quot; refers to \/.) The 2x2 grid is as follows: Example 5:Input: [ &quot;//&quot;, &quot;/ &quot; ] Output: 3 Explanation: The 2x2 grid is as follows: Note: 1 &lt;= grid.length == grid[0].length &lt;= 30 grid[i][j] is either ‘/‘, ‘\’, or ‘ ‘. 分析 updating（Solution） 参考代码class DSU: def __init__(self, N): self.p = range(N) def find(self, x): if self.p[x] != x: self.p[x] = self.find(self.p[x]) return self.p[x] def union(self, x, y): xr = self.find(x) yr = self.find(y) self.p[xr] = yr class Solution(object): def regionsBySlashes(self, grid): N = len(grid) dsu = DSU(4 * N * N) for r, row in enumerate(grid): for c, val in enumerate(row): root = 4 * (r*N + c) if val in &apos;/ &apos;: dsu.union(root + 0, root + 1) dsu.union(root + 2, root + 3) if val in &apos;\ &apos;: dsu.union(root + 0, root + 2) dsu.union(root + 1, root + 3) # north/south if r+1 &lt; N: dsu.union(root + 3, (root+4*N) + 0) if r-1 &gt;= 0: dsu.union(root + 0, (root-4*N) + 3) # east/west if c+1 &lt; N: dsu.union(root + 2, (root+4) + 1) if c-1 &gt;= 0: dsu.union(root + 1, (root-4) + 2) return sum(dsu.find(x) == x for x in xrange(4*N*N))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Depth-first Search</tag>
        <tag>Union Find</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[958.Check Completeness of a Binary Tree]]></title>
    <url>%2F2018%2F12%2F19%2F958-Check-Completeness-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a binary tree, determine if it is a complete binary tree. Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. 给定一个二叉树，确定它是否是一个完全二叉树。 百度百科中对完全二叉树的定义如下： 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。） 题目链接：https://leetcode.com/problems/check-completeness-of-a-binary-tree/ Difficulty: medium Example 1: Input: [1,2,3,4,5,6] Output: true Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible. Example 2: Input: [1,2,3,4,5,null,7] Output: false Explanation: The node with value 7 isn&apos;t as far left as possible. Note: The tree will have between 1 and 100 nodes. 分析 updating 参考代码Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def isCompleteTree(self, root): if(root==None): return True li=[root] judge=False while(len(li)&gt;0): ro=li[0] li=li[1:] if(ro==None): break if(judge): if(ro.left): return False if(ro.left==None): judge=True li.append(ro.left) if(judge): if(ro.right): return False if(ro.right==None): judge=True li.append(ro.right) return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[957.Prison Cells After Days（N 天后的牢房）]]></title>
    <url>%2F2018%2F12%2F19%2F957-Prison-Cells-After-Days%2F</url>
    <content type="text"><![CDATA[DescriptionThere are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. (Note that because the prison is a row, the first and the last cells in the row can’t have two adjacent neighbors.) We describe the current state of the prison in the following way:cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0. Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.) 8 间牢房排成一排，每间牢房不是有人住就是空着。 每天，无论牢房是被占用或空置，都会根据以下规则进行更改： 如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。否则，它就会被空置。（请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。） 我们用以下方式描述监狱的当前状态：如果第 i 间牢房被占用，则 cell[i]==1，否则 cell[i]==0。 根据监狱的初始状态，在 N 天后返回监狱的状况（和上述 N 种变化）。 题目链接：https://leetcode.com/problems/prison-cells-after-n-days/ Difficulty: medium Example 1:Input: cells = [0,1,0,1,1,0,0,1], N = 7 Output: [0,0,1,1,0,0,0,0] Explanation: The following table summarizes the state of the prison on each day: Day 0: [0, 1, 0, 1, 1, 0, 0, 1] Day 1: [0, 1, 1, 0, 0, 0, 0, 0] Day 2: [0, 0, 0, 0, 1, 1, 1, 0] Day 3: [0, 1, 1, 0, 0, 1, 0, 0] Day 4: [0, 0, 0, 0, 0, 1, 0, 0] Day 5: [0, 1, 1, 1, 0, 1, 0, 0] Day 6: [0, 0, 1, 0, 1, 1, 0, 0] Day 7: [0, 0, 1, 1, 0, 0, 0, 0] Example 2:Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000 Output: [0,0,1,1,1,1,1,0] Note: cells.length == 8 cells[i] is in {0, 1} 1 &lt;= N &lt;= 10^9 分析 updating（Solution） 参考代码class Solution(object): def prisonAfterNDays(self, cells, N): def nextday(cells): return [int(i &gt; 0 and i &lt; 7 and cells[i-1] == cells[i+1]) for i in xrange(8)] seen = {} while N &gt; 0: c = tuple(cells) if c in seen: N %= seen[c] - N seen[c] = N if N &gt;= 1: N -= 1 cells = nextday(cells) return cells]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[956.Tallest Billboard]]></title>
    <url>%2F2018%2F12%2F09%2F956-Tallest-Billboard%2F</url>
    <content type="text"><![CDATA[DescriptionYou are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height. You have a collection of rods which can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6. Return the largest possible height of your billboard installation. If you cannot support the billboard, return 0. 你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。 你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。 返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。 题目链接：https://leetcode.com/problems/tallest-billboard/ Difficulty: hard Example 1:Input: [1,2,3,6] Output: 6 Explanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6. Example 2:Input: [1,2,3,4,5,6] Output: 10 Explanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10. Example 3:Input: [1,2] Output: 0 Explanation: The billboard cannot be supported, so we return 0. Note: 0 &lt;= rods.length &lt;= 20 1 &lt;= rods[i] &lt;= 1000 The sum of rods is at most 5000. 分析 updating（Solution） 参考代码from functools import lru_cache class Solution: def tallestBillboard(self, rods): @lru_cache(None) def dp(i, s): if i == len(rods): return 0 if s == 0 else float(&apos;-inf&apos;) return max(dp(i + 1, s), dp(i + 1, s - rods[i]), dp(i + 1, s + rods[i]) + rods[i]) return dp(0, 0)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[955.Delete Columns to Make Sorted II(删列造序 ||)]]></title>
    <url>%2F2018%2F12%2F09%2F955-Delete-Columns-to-Make-Sorted-II%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = [&quot;abcdef&quot;,&quot;uvwxyz&quot;] and deletion indices {0, 2, 3}, then the final array after deletions is [&quot;bef&quot;,&quot;vyz&quot;]. Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] &lt;= A[1] &lt;= A[2] ... &lt;= A[A.length - 1]). Return the minimum possible value of D.length. 给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。 选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。 比如，有 A = [&quot;abcdef&quot;, &quot;uvwxyz&quot;]，删除索引序列 {0, 2, 3}，删除后 A 为[&quot;bef&quot;, &quot;vyz&quot;]。 假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（A[0] &lt;= A[1] &lt;= A[2] ... &lt;= A[A.length - 1]）排列的，然后请你返回 D.length 的最小可能值。 题目链接：https://leetcode.com/problems/delete-columns-to-make-sorted-ii/ Difficulty: medium Example 1:Input: [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;] Output: 1 Explanation: After deleting the first column, A = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]. Now A is in lexicographic order (ie. A[0] &lt;= A[1] &lt;= A[2]). We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1. Example 2:Input: [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;] Output: 0 Explanation: A is already in lexicographic order, so we don&apos;t need to delete anything. Note that the rows of A are not necessarily in lexicographic order: ie. it is NOT necessarily true that (A[0][0] &lt;= A[0][1] &lt;= ...) Example 3:Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;] Output: 3 Explanation: We have to delete every column. Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 分析 定义judge，存储当前数与下一个数的字典序关系，若等于0，当前字母串的字典在下一个字母串的前面； 若sum（judge）=0即所有字母串的字典序都在下一个字母串的前面，返回s（须删除的序列数）； 遍历A[0],判断每一列是否应该被删除，遍历A，若符合字典序，继续遍历，反之，若不满足字典序，s+1，break； 每次遍历结束，调整judge，符合字典序，置0； 返回s。 参考代码class Solution: def minDeletionSize(self, A): s=0 judge=[1]*(len(A)-1) for i in range(len(A[0])): if(sum(judge)==0): return s for j in range(len(A)-1): if(judge[j]==0): continue if(A[j][i]&gt;A[j+1][i]): s+=1 break else: for j in range(len(A)-1): if(A[j][i]&lt;A[j+1][i]): judge[j]=0 return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[954.Array of Doubled Pairs(二倍数对数组)]]></title>
    <url>%2F2018%2F12%2F09%2F954-Array-of-Doubled-Pairs%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers A with even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 &lt;= i &lt; len(A) / 2. 给定一个长度为偶数的整数数组 A，只有对 A 进行重组后可以满足 “对于每个 0 &lt;= i &lt; len(A) / 2，都有 A[2 * i + 1] = 2 * A[2 * i]” 时，返回 true；否则，返回 false。 题目链接：https://leetcode.com/problems/array-of-doubled-pairs/ Difficulty: medium Example 1:Input: [3,1,3,6] Output: false Example 2:Input: [2,1,2,6] Output: false Example 3:Input: [4,-2,2,-4] Output: true Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4]. Example 4:Input: [1,2,4,16,8,4] Output: false Note: 0 &lt;= A.length &lt;= 30000 A.length is even -100000 &lt;= A[i] &lt;= 100000 分析 先将A排序； 分为两种情况，负数和正数； 负数：遍历，若遍历完lii，当前数加入到lii，反之，比较，若当前数a小于lii[ii]的一半，加入到lii，若等于，ii后移，若大于，返回False； 正数：遍历，若遍历完li，当前数加入到li，反之，比较，若当前数a小于li[i]的两倍，加入到li，若等于，i后移，若大于，返回False； 若lii和li为空，返回True； 返回False。 参考代码class Solution: def canReorderDoubled(self, A): A.sort() li=[] i=0 lii=[] ii=0 for a in A: if(a&lt;0): if(ii==len(lii)): lii.append(a) else: if(a&lt;lii[ii]/2): lii.append(a) elif(a==lii[ii]/2): ii+=1 else: return False continue if(ii!=len(lii)): return False if(i==len(li)): li.append(a) else: if(a&lt;2*li[i]): li.append(a) elif(a==2*li[i]): i+=1 else: return False if(i==len(li) and ii==len(lii)): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[953.Verifying an Alien Dictionary(验证外星语词典)]]></title>
    <url>%2F2018%2F12%2F09%2F953-Verifying-an-Alien-Dictionary%2F</url>
    <content type="text"><![CDATA[DescriptionIn an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language. 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。 给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。 题目链接：https://leetcode.com/problems/verifying-an-alien-dictionary/ Difficulty: easy Example 1:Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot; Output: true Explanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted. Example 2:Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot; Output: false Explanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted. Example 3:Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot; Output: false Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info). Note: 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 20 order.length == 26 All characters in words[i] and order are english lowercase letters. 分析 定义一个判断符合‘order’顺序的函数judge，遍历w1，w2，若w1在大于w2，返回False，若w1在小于w2，返回True，反之继续； 将‘order’存入字典，保存其序号，用于judge中判断； 遍历‘words’，用judge判断，若存在逆序，返回False； 返回True。 参考代码class Solution: def isAlienSorted(self, words, order): def judge(w1,w2,o): i=0 while(i&lt;len(w1) and i &lt; len(w2)): if(o[w1[i]] &lt; o[w2[i]]): return True elif(o[w1[i]]&gt;o[w2[i]]): return False else: i+=1 if(i&lt;len(w1)): return False else: return True o={} for i in range(len(order)): o[order[i]]=i for i in range(len(words)-1): if(not judge(words[i],words[i+1],o)): return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[952.Largest Component Size by Common Factor(按公因数计算最大组件大小)]]></title>
    <url>%2F2018%2F12%2F02%2F952-Largest-Component-Size-by-Common-Factor%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-empty array of unique positive integers A, consider the following graph: There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i] and A[j] share a common factor greater than 1. Return the size of the largest connected component in the graph. 给定一个由不同正整数的组成的非空数组 A，考虑下面的图： 有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记； 只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。 返回图中最大连通组件的大小。 题目链接：https://leetcode.com/problems/largest-component-size-by-common-factor/ Difficulty: hard Example 1:Input: [4,6,15,35] Output: 4 Example 2:Input: [20,50,9,63] Output: 2 Example 3:Input: [2,3,6,7,4,12,21,39] Output: 8 Note: 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= 100000 分析 updating 参考代码updating]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[951.Flip Equivalent Binary Trees(翻转等价二叉树)]]></title>
    <url>%2F2018%2F12%2F02%2F951-Flip-Equivalent-Binary-Trees%2F</url>
    <content type="text"><![CDATA[DescriptionFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations. Write a function that determines whether two binary trees are flip equivalent. The trees are given by root nodes root1 and root2. 我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。 只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。 编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。 题目链接：https://leetcode.com/problems/flip-equivalent-binary-trees/ Difficulty: medium Example 1:Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5. Note: Each tree will have at most 100 nodes. Each value in each tree will be a unique integer in the range [0, 99]. 分析 递归对比检测每个节点，每次递归过程分为如下三种可能： 1：当前节点都为None，返回True；2：当前节点都不为None，此时若两个节点的值不相等，返回False，反之，递归到下一层，比较左右子结点，分为两种情况（左节点对左节点，右节点对右节点或者左节点对右节点，右节点对左节点），一种情况为True，就返回True；3：也就是一个为None，一个不为None，返回False。 递归实现过程如下。 参考代码Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def flipEquiv(self, root1, root2): if(root1==None and root2==None): return True elif(root1!=None and root2!=None): if(root1.val!=root2.val): return False else: return (self.flipEquiv(root1.left,root2.left) and self.flipEquiv(root1.right,root2.right)) or (self.flipEquiv(root1.left,root2.right) and self.flipEquiv(root1.right,root2.left)) else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[950.Reveal Cards In Increasing Order(按递增顺序显示卡牌)]]></title>
    <url>%2F2018%2F12%2F02%2F950-Reveal-Cards-In-Increasing-Order%2F</url>
    <content type="text"><![CDATA[DescriptionIn a deck of cards, every card has a unique integer. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. The first entry in the answer is considered to be the top of the deck. 牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。 最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。 现在，重复执行以下步骤，直到显示所有卡牌为止： 从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。 如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。 如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。 返回能以递增顺序显示卡牌的牌组顺序。 答案中的第一张牌被认为处于牌堆顶部。 题目链接：https://leetcode.com/problems/reveal-cards-in-increasing-order/ Difficulty: medium Example 1:Input: [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order doesn&apos;t matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. Note: 1 &lt;= A.length &lt;= 1000 1 &lt;= A[i] &lt;= 10^6 A[i] != A[j] for all i != j 分析 由题意知，是每显示一张卡片，将下一张（如果有）放到最后面； 相当于在一排位置上，循环填坑，每次跳两个位置，被占用的坑忽略； 首先将数组排序，按顺序填入坑中；形如[-,-,-,-,-,-,-]中填入[2,3,5,7,11,13,17]; 接下来每次填入一个数字的结果如下：[2,-,-,-,-,-,-]-&gt;[2,-,3,-,-,-,-]-&gt;[2,-,3,-,5,-,-]-&gt;[2,-,3,-,5,-,7]-&gt;[2,-,3,11,5,-,7]-&gt;[2,13,3,11,5,-,7]-&gt;[2,13,3,11,5,17,7]; 如上即是返回结果。 参考代码class Solution: def deckRevealedIncreasing(self, deck): deck.sort() A=[0]*len(deck) index=0 judge=[i for i in range(len(deck))] for i in range(len(A)): A[judge[index]]=deck[i] judge=judge[:index]+judge[index+1:] index+=1 if(len(judge)): index%=len(judge) return A]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[949.Largest Time for Given Digits(给定数字能组成的最大时间)]]></title>
    <url>%2F2018%2F12%2F02%2F949-Largest-Time-for-Given-Digits%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of 4 digits, return the largest 24 hour time that can be made. The smallest 24 hour time is 00:00, and the largest is 23:59. Starting from 00:00, a time is larger if more time has elapsed since midnight. Return the answer as a string of length 5. If no valid time can be made, return an empty string. 给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。 最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。 以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。 题目链接：https://leetcode.com/problems/largest-time-for-given-digits/ Difficulty: easy Example 1:Input: [1,2,3,4] Output: &quot;23:41&quot; Example 2:Input: [5,5,5,5] Output: &quot;&quot; Note: A.length == 4 0 &lt;= A[i] &lt;= 9 分析 直接暴力列出所有可能的时间，共有432*1=24中，判断合法时间，返回最大时间； 合法时间的原则是：时间的小时要小于24，时间的分钟要小于60； 遍历所有可能性，返回满足条件的最大时间；无满足条件，返回“”。 参考代码class Solution: def largestTimeFromDigits(self, A): if(sum(A)==0): return &quot;00:00&quot; li=[&quot;0&quot;,&quot;0&quot;] for i in range(4): for j in range(4): for k in range(4): for q in range(4): if(i!=j and i!=k and i!=q and j!=k and j!=q and k!=q): h=str(A[i])+str(A[j]) m=str(A[k])+str(A[q]) if(int(h)&lt;24 and int(m) &lt; 60): if(int(h)&gt;int(li[0]) or (int(h)==int(li[0]) and int(m) &gt; int(li[1]))): li=[h,m] if((int(li[0])+int(li[1]))==0): return &quot;&quot; else: return li[0]+&quot;:&quot;+li[1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[948.Bag of Tokens(令牌放置)]]></title>
    <url>%2F2018%2F11%2F25%2F948-Bag-of-Tokens%2F</url>
    <content type="text"><![CDATA[DescriptionYou have an initial power P, an initial score of 0 points, and a bag of tokens. Each token can be used at most once, has a value token[i], and has potentially two ways to use it. If we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point. If we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point. Return the largest number of points we can have after playing any number of tokens. 你的初始能量为 P，初始分数为 0，只有一包令牌。 令牌的值为 token[i]，每个令牌最多只能使用一次，可能的两种使用方法如下： 如果你至少有 token[i] 点能量，可以将令牌置为正面朝上，失去 token[i] 点能量，并得到 1 分。 如果我们至少有 1 分，可以将令牌置为反面朝上，获得 token[i] 点能量，并失去 1 分。 在使用任意数量的令牌后，返回我们可以得到的最大分数。 题目链接：https://leetcode.com/problems/bag-of-tokens/ Difficulty: medium Example 1:Input: tokens = [100], P = 50 Output: 0 Example 2:Input: tokens = [100,200], P = 150 Output: 1 Example 3:Input: tokens = [100,200,300,400], P = 200 Output: 2 Note: tokens.length &lt;= 1000 0 &lt;= tokens[i] &lt; 10000 0 &lt;= P &lt; 10000 分析 得分原则：能量够的情况下，尽量得分；反正尽量获取更多能量； 将tokens排序，若剩余能量不小于最小token的情况下，将令牌置为正面朝上，得一分；反之若是分数大于零，将最大能量的令牌置为反面朝上，减一分；记录当前得分，以及中间过程中出现过的最大得分； 操作完所有的token或者不能再操作token之时，返回最大得分。 参考代码class Solution: def bagOfTokensScore(self, tokens, P): tokens.sort() i,j=0,len(tokens)-1 points=0 power=P m_p=0 while(i&lt;=j): if(power&gt;=tokens[i]): points+=1 power-=tokens[i] i+=1 m_p=max(m_p,points) elif(points&gt;0): points-=1 power+=tokens[j] j-=1 else: break return m_p]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[947.Most Stonees Removed with Same Row or Column(移除最多的同行或同列石头)]]></title>
    <url>%2F2018%2F11%2F25%2F947-Most-Stonees-Removed-with-Same-Row-or-Column%2F</url>
    <content type="text"><![CDATA[DescriptionOn a 2D plane, we place stones at some integer coordinate points. Each coordinate point may have at most one stone. Now, a move consists of removing a stone that shares a column or row with another stone on the grid. What is the largest possible number of moves we can make? 在二维平面上，我们将石头放置在一些整数坐标点上。每个坐标点上最多只能有一块石头。 现在，move 操作将会移除与网格上的另一块石头共享一列或一行的石头。 我们最多能执行多少次 move 操作？ 题目链接：https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/ Difficulty: hard Example 1:Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Example 2:Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]] Output: 3 Example 3:Input: stones = [[0,0]] Output: 0 Note: 1 &lt;= stones.length &lt;= 1000 0 &lt;= stones[i][j] &lt; 10000 分析 根据题意，所有的操作次数等于所有点数减去所有区域块数； 区域块的划分原则：将横坐标或纵坐标相同的点，划分到同一个区域； 用Dict_x和Dict_y存储所有点坐标的，key是横坐标（或纵坐标），value是该横坐标（或纵坐标）对应的所有点的纵坐标（或横坐标）； 定义DFS，遍历某一点的相邻点（横坐标或纵坐标相同），从Dict_x和Dict_y中移出，以此得到区域块数； 返回操作总次数。 参考代码class Solution: def removeStones(self, stones): import collections Dict_x=collections.defaultdict(list) Dict_y=collections.defaultdict(list) for stone in stones: Dict_x[stone[0]].append(stone[1]) Dict_y[stone[1]].append(stone[0]) s=0 def dfs(stone): x,y=stone for tar in Dict_x[x]: Dict_x[x].remove(tar) dfs([x,tar]) for tar in Dict_y[y]: Dict_y[y].remove(tar) dfs([tar,y]) for stone in stones: if(stone[1] in Dict_x[stone[0]]): s+=1 dfs(stone) return len(stones)-s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Depth-first Search</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[946.Validate Stack Sequence(验证栈序列)]]></title>
    <url>%2F2018%2F11%2F25%2F946-Validate-Stack-Sequence%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. 给定 pushed 和 popped 两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 题目链接：https://leetcode.com/problems/validate-stack-sequences/ Difficulty: medium Example 1:Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&gt; 4, push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 Example 2:Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2. Note: 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed is a permutation of popped. pushed and popped have distinct values. 分析 模拟栈的操作，以此来匹配进栈序列和出栈序列； 若栈为空或者栈顶元素不等于当前出栈数字：将进栈数字压入栈（若没有进栈数字了，返回False），循环2； pop出栈顶元素； 遍历完所有出栈数字，返回True。 参考代码class Solution: def validateStackSequences(self, pushed, popped): i=0 stack=[] for pop in popped: while(len(stack)==0 or stack[-1]!=pop): if(i&lt;len(pushed)): stack.append(pushed[i]) i+=1 else: return False stack=stack[:-1] return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[945.Minimum Increment to Make Array Unique(使数组唯一的最小增量)]]></title>
    <url>%2F2018%2F11%2F25%2F945-Minimum-Increment-to-Make-Array-Unique%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers A, a move consists of choosing any A[i], and incrementing it by 1. Return the least number of moves to make every value in A unique. 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。 返回使 A 中的每个值都是唯一的最少操作次数。 题目链接：https://leetcode.com/problems/minimum-increment-to-make-array-unique/ Difficulty: medium Example 1:Input: [1,2,2] Output: 1 Explanation: After 1 move, the array could be [1, 2, 3]. Example 2:Input: [3,2,1,2,1,7] Output: 6 Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7]. It can be shown with 5 or less moves that it is impossible for the array to have all unique values. Note: 0 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt; 40000 分析 根据题意是将数组中重复的数字调整（增加）到数组中不存在的数，返回增加的次数（每次增加1）； 将数组A排序，依次遍历，若当前数字比前一个大，则继续； 反之，调整当前数字到比前一个数字大（排序数组中调整是加1）； 记录所有调整操作的次数，返回。 参考代码class Solution: def minIncrementForUnique(self, A): A.sort() s=0 index=0 for a in A: if(a&lt;index): s+=(index-a) index+=1 else: index=a+1 return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[944.Delete Columns to Make Sorted(删除列以使之有序)]]></title>
    <url>%2F2018%2F11%2F18%2F944-Delete-Columns-to-Make-Sorted%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have a string “abcdef” and deletion indices {0, 2, 3}, then the final string after deletion is “bef”. Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Formally, the c-th column is [A[0][c], A[1][c], …, A[A.length-1][c]] Return the minimum possible value of D.length. 给出由 N 个小写字母串组成的数组 A，所有小写字母串的长度都相同。 现在，我们可以选择任何一组删除索引，对于每个字符串，我们将删除这些索引中的所有字符。 举个例子，如果字符串为 “abcdef”，且删除索引是 {0, 2, 3}，那么删除之后的最终字符串为 “bef”。 假设我们选择了一组删除索引 D，在执行删除操作之后，A 中剩余的每一列都是有序的。 形式上，第 c 列为 [A[0][c], A[1][c], …, A[A.length-1][c]] 返回 D.length 的最小可能值。 题目链接：https://leetcode.com/problems/delete-columns-to-make-sorted/ Difficulty: medium Example 1:Input: [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;] Output: 1 Example 2:Input: [&quot;a&quot;,&quot;b&quot;] Output: 0 Example 3:Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;] Output: 3 Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 1000 分析 按题意，D的最小长度就是A的不是有序的列的个数； 取得A中每个项的最小长度m； 遍历[0:m]列，若该列无序，则该列索引在D中； 返回所有满足要求的索引的和。 参考代码class Solution: def minDeletionSize(self, A): M=1000 for a in A: M=min(M,len(a)) s=0 for m in range(M): for i in range(1,len(A)): if(A[i][m]&lt;A[i-1][m]): s+=1 break return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[943.Find the Shortest Superstring(最短超级串)]]></title>
    <url>%2F2018%2F11%2F18%2F943-Find-the-Shortest-Superstring%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of strings, find any smallest string that contains each string in A as a substring. We may assume that no string in A is substring of another string in A. 给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。 我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。 题目链接：https://leetcode.com/problems/find-the-shortest-superstring/ Difficulty: hard Example 1:Input: [&quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot;] Output: &quot;alexlovesleetcode&quot; Explanation: All permutations of &quot;alex&quot;,&quot;loves&quot;,&quot;leetcode&quot; would also be accepted. Example 2:Input: [&quot;catg&quot;,&quot;ctaagt&quot;,&quot;gcta&quot;,&quot;ttca&quot;,&quot;atgcatc&quot;] Output: &quot;gctaagttcatgcatc&quot; Note: 1 &lt;= A.length &lt;= 12 1 &lt;= A[i].length &lt;= 20 分析 如下是一个时间超限的代码； 定义一个矩阵matrix存储每两个字符串拼接抵消的长度； 用深度优先搜索，找到最长路径，即使需要的拼接顺序； 额(⊙﹏⊙) 参考代码class Solution: def shortestSuperstring(self, A): matrix=[] for i in range(len(A)): li=[0]*len(A) for j in range(len(A)): if(i!=j): m=min(len(A[i]),len(A[j])) for tar in range(m,0,-1): if(A[i][-tar:] == A[j][:tar]): li[j]=tar break matrix.append(li) r_li,r_m=[],0 def dfs(li,u,N,m): li.append(u) if(len(li)==N): nonlocal r_li,r_m if(m&gt;=r_m): r_li=li r_m=m return for i in range(N): if(i not in li): dfs(li.copy(),i,N,m+matrix[u][i]) for i in range(len(A)): dfs([],i,len(A),0) if(r_m==0): return &apos;&apos;.join(A) rStr=A[r_li[0]] index=r_li[0] for tar in r_li[1:]: rStr+=(A[tar][matrix[index][tar]:]) index=tar return rStr]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[942.DI String Match(增减字符串匹配)]]></title>
    <url>%2F2018%2F11%2F18%2F942-DI-String-Match%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string S that only contains “I” (increase) or “D” (decrease), let N = S.length. Return any permutation A of [0, 1, …, N] such that for all i = 0, …, N-1: If S[i] == “I”, then A[i] &lt; A[i+1] If S[i] == “D”, then A[i] &gt; A[i+1] 给定只含 “I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。 返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有： 如果 S[i] == “I”，那么 A[i] &lt; A[i+1] 如果 S[i] == “D”，那么 A[i] &gt; A[i+1] 题目链接：https://leetcode.com/problems/di-string-match/ Difficulty: easy Example 1:Input: &quot;IDID&quot; Output: [0,4,1,3,2] Example 2:Input: &quot;III&quot; Output: [0,1,2,3] Example 3:Input: &quot;DDI&quot; Output: [3,2,0,1] Note: 1 &lt;= S.length &lt;= 10000 S only contains characters “I” or “D”. 分析 如题意所示，只需要返回一个满足要求的增减字符串； 那么其中一个满足条件的情况是，每一个位置的数字v是[0,1,…,N]中第D个（D是DI序列中D的数量）； 按照增减规律，当前位置的数字的前面有D个后面有I个（D，I分别是DI序列中D，I的数量）； 逐步求得每个位置的数字。 参考代码class Solution: def diStringMatch(self, S): I=0 D=0 for s in S: if(s==&apos;I&apos;): I+=1 else: D+=1 li=[i for i in range(len(S)+1)] tar=[li[D]] li.remove(li[D]) for s in S: if(s==&apos;I&apos;): I-=1 else: D-=1 tar.append(li[D]) li.remove(li[D]) return tar]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[941.Valid Mountain Array(有效的山脉数组)]]></title>
    <url>%2F2018%2F11%2F18%2F941-Valid-Mountain-Array%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if: A.length &gt;= 3 There exists some i with 0 &lt; i &lt; A.length - 1 such that: A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[B.length - 1] 给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。 让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组： A.length &gt;= 3 在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[B.length - 1] 题目链接：https://leetcode.com/problems/valid-mountain-array/ Difficulty: easy Example 1:Input: [2,1] Output: false Example 2:Input: [3,5,5] Output: false Example 3:Input: [0,3,2,1] Output: true Note: 0 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt;= 10000 分析 山脉数组就是先增后减，单调增单调减都是合法的，长度小于3的也不合法； 当时的代码使用一个判断量judge=True，遍历A，如果开始下降了，更改judge=False； 若judge为False，序列是不降的，返回False； 遍历结束，若judge是True，返回False，即序列单调增。 参考代码class Solution: def validMountainArray(self, A): if(len(A)&lt;3): return False index=A[0] judge=True if(A[1]&lt;A[0]): return False for tar in A[1:]: if(judge): if(tar&gt;index): index=tar elif(tar&lt;index): index=tar judge=False else: return False else: if(tar&lt;index): index=tar else: return False if(judge): return False return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 和 Github]]></title>
    <url>%2F2018%2F11%2F14%2FGit-%E5%92%8C-Github%2F</url>
    <content type="text"><![CDATA[以下教程没用具体的代码截图，言简意赅，都是具体的操作，就是为了自己以后当作笔记来看，可以参考廖雪峰 Git 教程安装Git在Windows上安装Git，可以从Git官网直接下载安装程序，（网速慢的朋友这里），然后按默认选项安装即可。 安装完成后，在开始菜单中打开Git Bash，输入如下命令： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 相当于自报家门，注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库首先创建一个新目录，进入到到新目录，在Git Bash中输入如下命令： $ git init Git就把仓库建好了，会多了一“.git”目录，如果没有看到，可能是隐藏了，右键查看，取消隐藏就可以了。 新建文件，修改内容，如下命令提交到Git仓库： $ git add readme.txt readme.txt是需要提交的文件，可以用“.”代表所有需要提交的文件。 如下命令告诉Git仓库将文件提交到仓库： $ git commit -m &quot;解释标识这次提交&quot; “解释标识这次提交”想怎么写就怎么写，为了自己以后看的明白，还是写的清楚一些，最好是这次提交修改了什么内容。 commit之前可以多次add，add后面多个文件可以空格隔开。 管理版本版本回退版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： 版本回退，“HEAD”表示当前版本，上一个版本就是“HEAD^”,上上一个就是“HEAD^”，上一百个个就是“HEAD~100”。 如下命令是回退到上一个版本： $ git reset --hard HEAD^ 也可以返回前面的版本： $ git reset --hard 1094a “1094a”是版本的commit_id，可以通过git log 查看，不用写全，只需要写出前几位几个。 工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory） 就是你在电脑里能看到的目录 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 管理更改什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 修改之后add，再修改，commit时只会commit第一次修改的内容，每一次add对应一个commit或者多个add对应一个commit。 提交之后可以使用如下命令查看仓库文件与本地文件的区别： $ git diff HEAD -- readme.txt 上面查看的是readme.txt的区别。 撤销修改两种情况，一种是只是本地修改了，没有git add： $ git checkout -- readme.txt 如上，放弃readme.txt的修改。 第二种是已经git add了： $ git reset HEAD readme.txt 如上，把暂存区的修改撤销掉（unstage），重新放回工作区； $ git checkout -- readme.txt 再利用checkout放弃本地的修改。 删除文件将本地文件删除，再将仓库中的文件删除： git rm test.txt 如上删除。 将本地文件删除，删错了，从仓库中找回来： $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库GitHub是个神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 第0步：申请GitHUb账号。 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果一切顺利的话，可以在用户主目录（如C:\Users\red_tongue）里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 在GitHub上免费托管的Git仓库，任何人都可以看到，私人的收费的。 添加远程仓库首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：如test 目前，在GitHub上的这个test仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的test仓库下运行命令： $ git remote add origin git@github.com:redtongue/test.git redtongue修改为自己相应的账户名。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从远程克隆准备好远程库，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:redtongue/test.git 注意把Git库的地址换成你自己的，然后进入test目录看看。 分支管理有了分支，你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 创建与合并分支每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 创建分支，合并分支，都是操作指针，速度很快。 首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev 等价： $ git branch dev $ git checkout dev 然后，用git branch命令查看当前分支： $ git branch dev分支的工作完成，切换回master分支： $ git checkout master 然后，我们把dev分支的工作成果合并到master分支上： $ git merge dev 合并完成后，就可以放心地删除dev分支了： $ git branch -d dev 解决冲突如上在两个分支做完修改之后，使用git merge [branch name] 合并之后会提示 CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 冲突的文件是readme.txt，查看readme.txt会发现，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，修改为自己需要的内容，再提交： $ git add readme.txt $ git commit -m &quot;conflict fixed&quot; [master cf810e4] conflict fixed 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log –graph命令可以看到分支合并图。 用带参数的git log也可以看到分支的合并情况： $ git log --graph --pretty=oneline --abbrev-commit 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 如下是–no-ff方式的git merge： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev 将修改后的dev分支合并到master上，因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug 分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。但是当前正在dev上进行的工作还没有提交： $ git stash 利用stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支，修改之后，合并到master分支上。 再回到dev分支上干原来的活。 用git stash list命令看看存储的工作现场。 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了。 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@{0} Feature分支每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 创建分支，修改文件，add，commit，最后合并： $ git checkout -b feature-vulcan $ git add vulcan.py $ git commit -m &quot;add feature vulcan&quot; $ git checkout dev（切回dev，准备合并） 合并。。。。。 合并之前想删除，强行删除： $ git branch -D feature-vulcan 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。 多人协作要查看远程库的信息，用git remote： 或者，用git remote -v显示更详细的信息： 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 抓取分支 $ git clone git@github.com:redtongue/test.git 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。 要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git add env.txt $ git commit -m &quot;add env&quot; $ git push origin dev]]></content>
      <categories>
        <category>whatever</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[940.Distinct Subsequences II(不同的子序列 II)]]></title>
    <url>%2F2018%2F11%2F11%2F940-Distinct-Subsequences-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string S, count the number of distinct, non-empty subsequences of S . Since the result may be large, return the answer modulo 10^9 + 7. 给定一个字符串 S，计算 S 的不同非空子序列的个数。 因为结果可能很大，所以返回答案模 10^9 + 7. 题目链接：https://leetcode.com/problems/distinct-subsequences-ii/ Difficulty: hard Example 1:Input: &quot;abc&quot; Output: 7 Explanation: The 7 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ab&quot;, &quot;ac&quot;, &quot;bc&quot;, and &quot;abc&quot;. Example 2:Input: &quot;aba&quot; Output: 6 Explanation: The 6 distinct subsequences are &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;aa&quot; and &quot;aba&quot;. Example 3:Input: &quot;aaa&quot; Output: 3 Explanation: The 3 distinct subsequences are &quot;a&quot;, &quot;aa&quot; and &quot;aaa&quot;. Note: S contains only lowercase letters. 1 &lt;= S.length &lt;= 2000 分析 分析得，以每个字母结尾的字串是上一个字串和加1（1是指只有该字母）； 所以用D存储以每个字母结尾的字串和； 遍历S，更新每个字母对应的以此结尾的字串和，用Sum记录所有的字串和； 返回Sum。 参考代码class Solution: def distinctSubseqII(self, S): if(len(S)==1): return 1 Sum=1 old={} old[S[0]]=1 for s in S[1:]: if(s in old): tar=old[s] old[s]=Sum+1 Sum+=(Sum+1-tar) else: old[s]=Sum+1 Sum*=2 Sum+=1 Sum=Sum%(10**9+7) return Sum]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[939.Minimum Area Rectangle(最小面积矩形)]]></title>
    <url>%2F2018%2F11%2F11%2F939-Minimum-Area-Rectangle%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn’t any rectangle, return 0. 给定在 xy 平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于 x 轴和 y 轴。 如果没有任何矩形，就返回 0。 题目链接：https://leetcode.com/problems/minimum-area-rectangle/ Difficulty: medium Example 1:Input: [[1,1],[1,3],[3,1],[3,3],[2,2]] Output: 4 Example 2:Input: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]] Output: 2 Note: 1 &lt;= points.length &lt;= 500 0 &lt;= points[i][0] &lt;= 40000 0 &lt;= points[i][1] &lt;= 40000 All points are distinct. 分析 以横坐标作为字典的key值，所有在此横坐标的点的y值合成的list作为value值； 去除value值长度小于2的项（少于两个点不可能形成矩形）； 遍历字典任意两个key值对应的value的最小差值，乘积即为矩形的面积； 定义初始足够大的s值，遍历过程中，取得最小值； 返回s。 参考代码class Solution: def minAreaRect(self, points): import collections D=collections.defaultdict(list) for point in points: D[point[0]].append(point[1]) D={d:D[d] for d in D if len(D[d])&gt;=2} s=10**10 for d1 in D: for d2 in D: if(d1!=d2): li=[tar for tar in D[d1] if tar in D[d2]] if(len(li)&lt;2): continue li.sort() length=10**10 for i in range(1,len(li)): length=min(length,li[i]-li[i-1]) s=min(s,length*(abs(d1-d2))) return s if s&lt;10**10 else 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[938.Range Sum of BST(二叉搜索树的范围和)]]></title>
    <url>%2F2018%2F11%2F11%2F938-Range-Sum-of-BST%2F</url>
    <content type="text"><![CDATA[DescriptionGiven the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive). The binary search tree is guaranteed to have unique values. 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。 二叉搜索树保证具有唯一的值。 题目链接：https://leetcode.com/problems/range-sum-of-bst/ Difficulty: medium Example 1:Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 Output: 32 Example 2:Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 Output: 23 Note: The number of nodes in the tree is at most 10000. The final answer is guaranteed to be less than 2^31. 分析 简单的前序遍历，返回所有满足2条件的节点的值的和； 判断该节点的值是否在L，R之间； 返回节点和。 参考代码Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def rangeSumBST(self, root, L, R): if(root==None): return 0 left=self.rangeSumBST(root.left, L, R) right=self.rangeSumBST(root.right, L, R) if(root.val&gt;=L and root.val&lt;=R): return left+right+root.val else: return left+right]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[937.Recorder Log Files（重新排列日志文件）]]></title>
    <url>%2F2018%2F11%2F11%2F937-Recorder-Log-Files%2F</url>
    <content type="text"><![CDATA[DescriptionYou have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier. Reorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order. Return the final order of the logs. 你有一个日志数组 logs。每条日志都是以空格分隔的字串。 对于每条日志，其第一个字为字母数字标识符。然后，要么： 标识符后面的每个字将仅由小写字母组成，或； 标识符后面的每个字将仅由数字组成。 我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。 将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。 返回日志的最终顺序。 题目链接：https://leetcode.com/problems/reorder-log-files/ Difficulty: easy Example 1:Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;] Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;] Note: 0 &lt;= logs.length &lt;= 100 3 &lt;= logs[i].length &lt;= 100 logs[i] is guaranteed to have an identifier, and a word after the identifier. 分析 遍历logs，将数字日志加入li，判断依据是：每一条log的第二项是否为数字； 将字母日志去除表示符加入到D链表中，逆序排序（排序即使字典序）； 遍历D，将每一项加入到li中； 返回li。 参考代码class Solution: def reorderLogFiles(self, logs): l=[] D=[] for log in logs: li=log.split() if(li[1].isdigit()): l.append(log) else: D.append((li[1:],log)) D.sort(reverse=True) for d in D: l=[d[1]]+l return l]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DeepInf:Social Influence Prediction with Deep Learning]]></title>
    <url>%2F2018%2F11%2F10%2FDeepInf-Social-Influence-Prediction-with-Deep-Learning%2F</url>
    <content type="text"><![CDATA[结合深度学习预测每个用户的社交影响。 论文地址:https://arxiv.org/abs/1807.05560 ABSTRACT 脸书、推特、微信和微博等社交信息网络活动成为日常生活的重要组成部分，我们可以接触朋友的行为，同样的被他们影响。因此，对每一个用户的社交影响的有效预测对于如在线推荐和广告等各种应用至关重要。 传统的社交影响预测方法通常设计各种手工规则来提取用户和网络的特征。但是，这种方式的有效性严重依赖于领域专家的知识。结果，很难将他们泛化到不同的领域。受到最近深度神经网络在各种计算应用中的成功的启发，我们设计了一个端到端框架DeepInf1，以学习用户的潜在特征表示来预测社会影响。 通常，DeepInf将用户的本地网络作为图形神经网络的输入，用于学习其潜在的社交表示。 我们设计了将网络结构和用户特定特征纳入卷积神经网络和注意力网络的策略。 代表不同类型的社交和信息网络的Open Academic Graph，Twitter，Weibo和Digg的大量实验表明，提出的端到端模型DeepInf明显优于传统的基于特征工程的方法，表明了社交应用的有效表示学习。 INTRODUCTION社会影响力无处不在，不仅在我们的日常生活中，而且在虚拟的网络空间。 社会影响一词通常指的是一个人的情绪，观点或行为受到他人影响的现象。 随着在线和移动社交平台的全球渗透，人们目睹了社会影响力在各个领域的影响，如总统选举[7]，广告[3,24]和创新采用[42]。 到目前为止，毫无疑问，社会影响已经成为推动我们社会决策的普遍而复杂的力量，明确需要方法论来描述，理解和量化社会影响的潜在机制和动态。 实际上，在文献中已经对社会影响预测做了大量工作[26,32,42,43]。 例如，Matsubara等人 [32]通过精心设计从经典的“易感染的”（SI）模型扩展的微分方程，研究社会影响的动态; 最近，Li等人[26] 提出了一种通过结合递归神经网络（RNN）和表示学习来推断级联大小的端到端预测器。 所有这些方法主要旨在预测社会影响的全局或聚合模式，例如时间范围内的级联大小。 然而，在诸如广告和推荐的许多在线应用中，有效地预测每个个体的社交影响，即用户级社交影响预测是至关重要的。 图1：社会影响局部性预测的一个激励性例子。目标是预测v的活动状态，给定 1）她近邻的观察活动状态（黑色和灰色的圆圈分别用来表示“活动”和“不活动”）和 2）他嵌入的本地网络。 在本文中，我们关注用户级社会影响力的预测。 我们的目标是在给定近邻居的行动状态和她的本地结构信息的情况下预测用户的行动状态。 例如，在图1中，对于中央用户v，如果她的一些朋友（black circles）购买了产品，她将来会购买相同的产品吗？ 上述问题在现实世界的应用中很普遍，因为它经常被观察到其复杂性和非线性，例如[2]中的“S形”曲线和[46]中着名的“结构多样性”。 上述观察激发了许多用户级影响预测模型，其中大多数[27,53,54]考虑了复杂的手工制作的特征，这需要对特定领域的广泛了解，并且通常难以推广到不同的领域。 受到最近神经网络在表示学习中的成功启发，我们设计了一种端到端的方法来自动发现社会影响中的隐藏和预测信号。 通过将网络嵌入[37]，图形卷积[25]和图形注意机制[49]构建到一个统一的框架中，我们期望端到端模型可以比使用特征工程的传统方法获得更好的性能。 具体而言，我们提出了一个基于深度学习的框架DeepInf，将影响动态和网络结构表示为潜在空间。 为了预测用户v的动作状态，我们首先通过随机漫步重新开始对她的本地邻居进行采样。 在获得如图1所示的本地网络之后，我们利用图形卷积和注意技术来学习潜在的预测信号。 我们展示了我们提出的框架在不同领域的四个社交和信息网络中的有效性和效率 - Open Academic Graph（OAG），Digg，Twitter和微博。 我们将DeepInf与几种传统方法进行比较，例如具有手工制作特征的线性模型[54]以及最先进的图分类模型[34]。 实验结果表明，DeepInf模型可以显着提高预测性能，展示了社交和信息网络挖掘任务的表示学习的前景。 本文的其余部分安排如下：第2节制定社会影响预测问题。 第3节详细介绍了拟议的框架。 在第4节和第5节，我们进行了广泛的实验和案例研究。 最后，第6节总结了相关工作，第7节总结了这项工作。 PROBLEM FORMULATION定义2.1。 r-neighbors和r-ego network设G =（V，E）是一个静态社交网络，其中V表示用户集和E⊆V×V表示关系集。 对于用户v，其r-neighbors被定义为 $\Gamma_v^r = {u:d(u,v)≤r}$ 其中d（u，v）是最短路径距离（就跳数而言） 用户v的r-ego network是由 $\Gamma_v^r$ 引起的子网络，由 $G_v^r$ 表示。 定义2.2 社交活动社交网络中的用户执行社交活动，例如转推。 在每个时间戳t，我们观察到用户u的二元动作状态， $s_u^t∈{0,1}$ ，其中 $s_u^t=1$ 表示用户u在时间戳t之前或之后执行了此动作，并且 $s_u^t=0$ 表示用户尚未执行此操作。 这样的动作日志可以从许多社交网络获得，例如Twitter中的“转发”动作和学术社交网络中的引用动作。 鉴于上述定义，我们引入了社会影响局部性，这相当于一种封闭的世界假设：用户的社会决策和行动仅受到网络内近邻的影响，而假设外部来源不存在。 问题1：社交影响局部性 v的行动状态的概率取决于她的r-ego网络 $G_v^r$ 和她的r-neighbors的行动状态。 更正式地，给定 $G_v^r$ 和 $s_v^t={s_u^t:u∈\Gamma_v^r {v}}$ ，社会影响局部性旨在量化在给定时间间隔Δt之后v的激活概率： $$P(s_v^{t+∆t} | G_v^r,S_v^t)$$ 实际上，假设我们有N个实例，每个实例是一个3元组（v，a，t），其中v是用户，a是社交动作，t是时间戳。 对于这样的3元组（v，a，t），我们也知道v的r-ego网络 $G_v^r$ ，v的r-neighbors- $S_v^t$ 的动作状态，以及v在t +Δt的未来动作状态 ，即 $s_v^{t+∆t}$。 然后我们将社会影响预测表示为二元图分类问题，可以通过最小化以下关于模型参数θ的负对数似然目标来解决： $$\iota(θ)=-\sum_{i=1}^{N}log⁡(P_θ (s_{v_i}^{t_i+∆t} | G_{v_i}^r,S_{v_i}^{t_i})) \tag{1}$$ 特别是，在这项工作中，我们假设Δt足够大，也就是说，我们想要在观察窗口的末尾预测自我用户v的行动状态。 MODEL FRAMEWORK在本节中，我们正式提出DeepInf，一种基于深度学习的模型，用于参数化方程1中的概率，并自动检测社会影响的机制和动态。 该框架首先对固定大小的子网络进行采样，作为每个r-ego网络的代理（参见第3.1节）。 然后将采样的子网络馈入具有小批量学习的深度神经网络（参见第3.2节）。 最后，将模型输出与基础事实进行比较，以最小化负对数似然损失。 Sampling Near Neighbors给定用户v，提取她的r-ego网络 $G_v^r$ 的直接方式是从用户v开始执行广度优先搜索（BFS）。然而，对于不同的用户， $G_v^r$ 可以具有不同的大小。 同时，由于社交网络中的小世界属性， $G_v^r$ 的大小（关于顶点的数量）可能非常大[50]。 这种不同大小的数据不适合大多数深度学习模型。 为了解决这些问题，我们从v的r-ego网络中采样固定大小的子网，而不是直接处理r-ego网络。 采样方法的一个自然选择是执行随机重启（RWR）[45]。 受[2,46]的启发，这表明人们更容易受到活跃邻居的影响而不是非活动邻居，我们从自我用户v或其中一个活跃邻居随机开始随机游走。 接下来，随机游走以与每个边缘的权重成比例的概率迭代地行进到其邻域。 此外，在每个步骤中，为步行分配返回起始节点的概率，即，自我用户v或v的活动邻居之一。 RWR一直运行，直到它成功收集固定数量的顶点，用 $\overline{\Gamma_v^r}$ 表示，其中 $\overline{\Gamma_v^r}=n$ 。 然后我们将由 $\overline{\Gamma_v^r}$ 引起的子网 $\overline{G_v^r}$ 视为r-ego网络 $G_v^r$ 的代理，并且表示 $\overline{S_v^t} ={s_u^t:u∈\overline{\Gamma_v^r{v}}}$ 是v的采样邻居的动作状态。 因此，我们将方程1中的优化目标重新定义为： $$\iota(θ)=-\sum_{i=1}^Nlog⁡(P_θ (s_{v_i}^{t_i+∆t} | \overline{G_{v_i}^r},\overline{S_{v_i}^{t_i}})) \tag{2}$$ Neural Network Model Figure 2: Model Framework of DeepInf. 利用每个用户检索到的 $\overline{\Gamma_v^r}$ 和 $\overline{S_v^t}$ ，我们设计了一个有效的神经网络模型，将 $\overline{\Gamma_v^r}$ 中的结构属性和 $\overline{S_v^t}$ 中的动作状态结合起来。 神经网络模型的输出是自我用户v的隐藏表示，然后用于预测她的动作状态- $s_v^{t+∆t}$ 。如图2所示，所提出的神经网络模型由网络嵌入层、实例归一化层、输入层、若干图形卷积或图形关注层以及输出层组成。 在本节中，我们逐一介绍这些层，并逐步构建模型。 嵌入层：随着最近出现的表示学习[5]，网络嵌入技术得到了广泛的研究，以发现网络结构属性并将其编码为低维潜在空间。 更正式地，网络嵌入学习嵌入矩阵 $X∈R^{(D×|V|)}$ ，每列对应于网络G中的顶点（用户）的表示。在所提出的模型中，我们使用预训练 嵌入层将用户u映射到她的D维表示 $x_u∈R^D$ ，如图2（b）所示。 实例规范化：实例规范化是最近提出的图像样式转移技术[47]。 我们在社会影响力预测任务中采用这种技术。 如图2（c）所示，对于每个用户 $\overline{\Gamma_v^r}$ ，在从嵌入层检索她的表示 $x_u$ 之后，实例标准化 $y_u$ 由下式给出： $$y_ud=\frac{(x_ud-μ_d)}{\sqrt{σ_d^2+ε}} \tag{3}$$ 对于每个嵌入维度d = 1，···，D，其中 $$μ_d=\frac{1}{n}$$ $$\sum_{u∈\Gamma_v^r}{x_ud}$$ $$σ_d^2=\frac{1}{n}$$ $$\sum_{u∈\Gamma_v^r}{(x_{ud}-μ_d)^2} \tag{4} $$ (令人崩溃的markdown，怎么编辑公式都是不对，下面是截图。) 这里 $μ_d$ 和 $σ_d$ 是平均值和方差，ε是数值稳定性的小数。直观地，这种归一化可以去除特定于实例的均值和方差，这促使下游模型关注用户在潜在嵌入空间中的相对位置而不是其绝对位置。 正如我们稍后将在第5节中看到的那样，实例规范化可以帮助避免在训练期间过度拟合。 输入层：如图2（d）所示，输入层为每个用户构造一个特征向量。 除了归一化的低维嵌入来自上游实例规范化层之外，它还考虑了两个二进制变量。 第一个变量表示用户的动作状态，另一个表示用户是否是自我用户。 此外，输入图层还涵盖了所有其他自定义顶点要素，例如结构要素，内容要素和人口统计要素。 基于GCN的网络编码：图形卷积网络（GCN）是用于图形结构化数据的半监督学习算法。 通过堆叠多个GCN层来构建GCN模型。 每个GCN层的输入是顶点特征矩阵，$H∈R^{(n×F)}$，其中n是顶点的数量，F是特征的数量。 由 $h_i ^ T$ 表示的H的每一行与顶点相关联。 一般来说，GCN层的本质是非线性变换，输出 $H’∈R^{(n×F’)}$ 如下： $$H’=GCN(H)=g(A(G)HW^T+b) \tag{5}$$ 其中 $W∈R^{F’×F’}$ ， $B∈R^{F’}$ 是模型参数，g是非线性激活函数，A（G）是捕获图G的结构信息的n×n矩阵。 GCN将A（G）实例化为与标准化图Laplaican [10]密切相关的静态矩阵： $$A_{GCN}(G)=D^{-\frac{1}{2}} AD^{-\frac{1}{2}} \tag{6}$$ 其中A是G的邻接矩阵，D = diag（A1）是度矩阵。 Multi-head Graph Attention :图注意（GAT）是最近提出的技术，它将注意机制引入GCN。 GAT通过自我关注机制定义矩阵 $A_{GAT}(G)=[a_{ij}]_{n×n}$ 。 更正式地，注意系数 $e_ij$ 首先由注意函数attn计算： $R^{F’}×R^{F’}→R$ ，其测量顶点j对顶点i的重要性： $$e_{ij}=attn(W h_i ,W h_j)$$ 与将计算所有实例对之间的注意系数的传统自注意机制不同，GAT仅评估 $e_ij$ 为 $（i，j）∈E（\overline{G_v ^ r}）$ 或i = j，即（i， j）是边或自循环。 通过这样做，它能够更好地利用和捕获图形结构信息。 之后，为了使顶点之间的系数相当，采用softmax函数来归一化注意系数 $$a_{ij}=softmax(e_{ij})=\frac{exp⁡(e_{ij})}{\sum_{k∈\Gamma_i^1} exp⁡(e_{ik})}$$ 继Velickovic等人之后。 [49]，注意函数用点积和LeakyReLU [31,51]非线性实例化。 对于边或自循环（i，j），在参数c和两个端点- $W h_i$ 和 $W h_j$ 的特征向量的串联之间执行点积，即， $e_ij = LeakyReLU（c^T[ W h_i || W h_j]）$，其中LeakyReLU的负斜率为0.2。 综上所述，归一化注意系数可表示为： $$a_{ij}=\frac{exp⁡(LeakyReLU( c^T [W h_i || W h_j] ))}{\sum_{k∈(\Gamma_i^1)}exp⁡(LeakyReLU( c^T [W h_i || W h_k] ))} \tag{7}$$ || 表示向量连接操作。 一旦获得归一化的注意系数，即aij，我们就可以将 $A_{GAT}(G)=[a_ij]_(n×n)$ 插入方程式。 这完成了单头(single-head)图注意的定义。 此外，我们应用Velickovic等人建议的多头(multi-head)图注意。 [49]和Vaswani等人。[48]。 多头(multi-head)注意机制并行地执行K个独立的单一注意，即，我们具有K个独立参数 $W_1，…，W_K$ 和注意矩阵 $A_1，…，A_K$ 。 多头注意力通过聚合函数将K单个注意力的输出聚合在一起： $$H’=g(Aggregate(A_1 (G)HW_1^T,…,A_K(G)HW_K^T )+b) \tag{8}$$ 我们连接每个单头注意的输出以聚合它们，除了最后一层的平均运算符。 输出层和损失函数:该层（见图2（f））为每个用户输出一个二维表示，我们将自我用户的表示与真值进行比较，然后如公式2所述优化对数似然损失。 小批量学习：当从r-ego网络采样时，我们强制采样的子网络具有固定大小n。 受益于这种同质性，我们可以在这里应用小批量学习进行有效的培训。 如图2（a）所示，在每次迭代中，我们首先将B实例随机抽样为小批量。 然后我们针对采样的小批量优化我们的模型。 这种方法比全批量学习运行得快得多，并且在优化期间仍然引入了足够的噪声。 EXPERIMENT SETUP设置我们使用大规模实际数据集建立实验，以定量评估提出的DeepInf框架。 Datasets OAG Digg Twitter Weibo &#124;V&#124; 953,675 279,630 456,626 1,776,950 &#124;E&#124; 4,151,463 1,548,126 12,508,413 308,489,739 N 499,848 24,428 499,160 779,164 Table1:Summary of datasets.|V|and|E|indicates the number of vertices and edges in graphG = (V,E), while N is the number of social influence locality instances(observations) as described in Section 2. OAG： OAG（开放学术图）数据集是通过链接两个大型学术图表生成的：Microsoft Academic Graph [15]和AMiner [44]。 与[13]中的处理类似，我们从数据挖掘，信息检索，机器学习，自然语言处理，计算机视觉和数据库研究社区中选择了20个热门会议。 社交网络被定义为共同作者网络，社会行为被定义为引用行为 - 研究人员引用了上述会议的论文。 我们对她的合作者如何影响一个人的引用行为感兴趣。 Digg： Digg是一个新闻聚合器，允许人们对网页内容也就是故事进行投票，向上或向下投票。 该数据集包含有关2009年一个月内推广到Digg首页的故事的数据。对于每个故事，它包含所有Digg用户的列表，这些用户在数据收集和每次投票的时间戳之前已经投票选出了故事。投票者的友谊链接也被检索。 Twitter： Twitter数据集是在2012年7月4日宣布发现具有难以捉摸的希格斯玻色子特征的新粒子之前，期间和之后监测Twitter上的传播过程之后建立的。社交网络被定义 成为Twitter友谊网络，社交行为被定义为用户是否转发“希格斯”相关推文。 微博：微博是中国最受欢迎的微博服务。 数据集来自[53]并可在此处下载 (https://www.aminer.cn/influencelocality). 完整数据集包含2012年9月28日至2012年10月29日期间1,776,950位用户的定向跟踪网络和推文（发布日志）。社交行为定义为 微博中的转发行为 - 用户转发（转发）帖子（推文）。 数据准备：我们按照现有工作中的实践处理上述四个数据集[53,54]。更具体地，对于在某个时间戳t受到影响以执行社交动作a的用户v，我们生成肯定的实例。接下来，对于受影响的用户v的每个邻居，如果在我们的观察窗口中从未观察到她是活动的，我们创建一个否定实例。我们的目标是区分积极情况和消极情况。然而，所实现的数据集在两个方面面临数据不平衡问题。第一个来自活跃邻居的数量。正如Zhang等人所观察到的那样，当自我用户具有相对大量的活动邻居时，结构特征与社会影响局部性显着相关。然而，在大多数社会影响数据集中，活动邻居的数量是不平衡的。例如，在微博中，大约80％的实例只有一个活动邻居，活动邻居数量≥3的实例仅占8.57％。因此，当我们在这样的不平衡数据集上训练我们的模型时，模型将由几个活动邻居的观察主导。为了解决不平衡问题并显示我们的模型在捕获局部结构信息方面的优越性，我们过滤掉了几个活跃邻居的观察结果。特别是，在每个数据集中，我们仅考虑自我用户具有≥3个活动邻居的情况。第二个问题来自标签不平衡。例如，在微博数据集中，负实例与正实例之间的比率约为300：1。为了解决这个问题，我们采样了一个更平衡的数据集，其中负数和正数之比为3：1。 Evaluation Metrics为了定量评估我们的框架，我们使用以下性能指标： 预测性能：我们根据曲线下面积（AUC）[8]，精确度（精确度），召回量（Rec。）和F1度量值（F1）来评估DeepInf的预测性能。 参数灵敏度：我们在模型中分析了几个超参数，并测试了不同的超参数选择如何影响预测性能。 案例研究：我们使用案例研究来进一步证明和解释我们提出的框架的有效性。 Name Description Vertex Coreness[4].Pagerank[35].Hub score and authority score[9].Eigenvector Centrality[6].ClusteringCoefficient[50].Rarity(reciprocalofegouser’sdegree)[1]. Embedding Pre-trainednetworkembedding(DeepWalk[36],64-dim). Ego Thenumber/ratio of active neighbors[2].Density of subgnetwork induced by active neighbors[46].#Connected components formed by active neighbors[46]. Table2:List of features used in this work. Comparison Methods我们将DeepInf与几个基线进行比较。Logistic回归（LR）:我们使用逻辑回归（LR）来训练分类模型。 该模型考虑了三类特征：（1）自我用户的顶点特征; （2）针对自我用户的预训练网络嵌入（DeepWalk [36]）; （3）手工制作的网络功能。 我们使用的功能列于表2中。 支持向量机（SVM）:我们还使用支持向量机（SVM）（线性核）作为分类模型。 该模型使用与逻辑回归（LR）相同的特征。 PSCN:当我们将社会影响局部性预测模型化为图分类问题时，我们将我们的框架与最先进的图分类模型PSCN [34]进行比较。对于每个图，PSCN根据用户定义的排名函数（例如，度和中介中心性）选择w个顶点。 然后，对于每个选定的顶点，它根据广度优先搜索顺序组装其邻近的顶部k。 对于每个图，上述过程构造具有F通道的长度为w×k的顶点序列，其中F是每个顶点的特征数。 最后，PSCN在其上应用1维卷积层。 DeepInf及其变体：我们实现了DeepInf的两个变体，分别由DeepInf-GCN和DeepInf-GAT表示。 DeepInfGCN使用图卷积层作为我们框架的构建块，即在公式5中设置 $A(G)=D^{-\frac{1}{2}} AD^{-\frac{1}{2}}$ 。 DeepInf-GAT使用图表注意，如公式7所示。但是，DeepInf和PSCN都只接受顶点级特征。 由于此限制，我们不在这两个模型中使用自我网络功能。 相反，我们希望DeepInf能够自动发现自我网络特征和其他预测信号。 超参数设置和实现细节：对于我们的框架DeepInf，我们首先以重启概率0.8执行随机游走，并且采样子网的大小设置为50.对于嵌入层，64维网络嵌入使用DeepWalk进行预训练[36]。然后我们选择为DeepInf使用三层GCN或GAT结构，第一和第二GCN / GAT层都包含128个隐藏单元，而第三层（输出层）包含2个用于二进制预测的隐藏单元。特别是对于具有多头图关注度的DeepInf，第一层和第二层都由K = 8个注意头组成，每个计算16个隐藏单元（总共8×16 = 128个隐藏单元）。对于详细的模型配置，我们采用指数线性单位（ELU）[11]作为非线性（方程5中的函数д）。所有参数都用Glorot初始化[18]初始化，并使用Adagrad [16]优化器进行训练，学习率为0.1（Digg数据集为0.05），权重衰减为 $5e^{-4}$（Digg数据集为 $1e^{-3}$），辍学率为0.2。我们分别使用75％，12.5％，12.5％的实例进行培训，验证和测试;所有数据集中的小批量大小都设置为1024。至于PSCN，在我们的实验中，我们发现推荐的中介中心性排名函数在预测社会影响方面效果不佳。我们转而使用从自我用户开始的广度优先搜索顺序作为排名函数。当BFS订单不是唯一的时，我们首先通过对活跃用户进行排名来打破关系。我们通过验证选择w = 16和k = 5，然后应用两个1维卷积层。第一个转换层有16个输出通道，步幅为5，内核大小为5.第二个转换层有8个输出通道，步长为1，内核大小为1.第二层的输出则为进入完全连接的层以预测标签。 最后，我们允许PSCN和DeepInf在训练数据上运行最多500个时期，并且通过在验证集上使用损失提前停止来选择最佳模型。 我们在https://github.com/xptree/DeepInf上发布了PSCN和DeepInf的代码，这两个代码都是用PyTorch实现的。 结论在这项工作中，我们研究社会影响局部性问题。 我们从深度学习的角度阐述了这个问题，并通过结合最近开发的网络嵌入，图形卷积和自我关注技术，提出了基于图形的学习框架DeepInf。 我们在四个社交和信息网络-OAG，Digg，Twitter和微博上测试提议的框架。 我们广泛的实验分析表明，DeepInf在预测社会影响局部性方面明显优于具有丰富手工工艺特征的基线。 这项工作探讨了网络表征学习在社会影响力分析中的潜力，并首次尝试解释社会影响力的动态。 提出的DeepInf背后的一般思想可以扩展到许多网络挖掘任务。 我们的DeepInf可以有效地汇总网络中的本地区域。 然后，可以将这样的概括表示馈送到各种下游应用中，例如链路预测，相似性搜索，网络对齐等。因此，我们希望探索这个有希望的方向以用于将来的工作。 另一个激动人心的方向是近邻的采样。 在这项工作中，我们在没有考虑任何辅助信息的情况下执行随机重启。 同时，采样程序与神经网络模型松散耦合。 通过利用强化学习将抽样和学习结合起来也是令人兴奋的。]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>recommendation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[936.Stamping The Sequence（戳印序列）]]></title>
    <url>%2F2018%2F11%2F06%2F936-Stamping-The-Sequence%2F</url>
    <content type="text"><![CDATA[DescriptionYou want to form a target string of lowercase letters. At the beginning, your sequence is target.length ‘?’ marks. You also have a stamp of lowercase letters. On each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp. You can make up to 10 * target.length turns. For example, if the initial sequence is “?????”, and your stamp is “abc”, then you may make “abc??”, “?abc?”, “??abc” in the first turn. (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.) If the sequence is possible to stamp, then return an array of the index of the left-most letter being stamped at each turn. If the sequence is not possible to stamp, return an empty array. For example, if the sequence is “ababc”, and the stamp is “abc”, then we could return the answer [0, 2], corresponding to the moves “?????” -&gt; “abc??” -&gt; “ababc”. Also, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.length moves. Any answers specifying more than this number of moves will not be accepted. 你想要用小写字母组成一个目标字符串 target。 开始的时候，序列由 target.length 个 ‘?’ 记号组成。而你有一个小写字母印章 stamp。 在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length 个回合。 举个例子，如果初始序列为 “?????”，而你的印章 stamp 是 “abc”，那么在第一回合，你可以得到 “abc??”、”?abc?”、”??abc”。（请注意，印章必须完全包含在序列的边界内才能盖下去。） 如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。 例如，如果序列是 “ababc”，印章是 “abc”，那么我们就可以返回与操作 “?????” -&gt; “abc??” -&gt; “ababc” 相对应的答案 [0, 2]； 另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。 题目链接：https://leetcode.com/problems/stamping-the-sequence/ Difficulty: hard Example 1:Input: stamp = &quot;abc&quot;, target = &quot;ababc&quot; Output: [0,2] ([1,0,2] would also be accepted as an answer, as well as some other answers.) Example 2:Input: stamp = &quot;abca&quot;, target = &quot;aabcaca&quot; Output: [3,0,1] Note: 1 &lt;= stamp.length &lt;= target.length &lt;= 1000 stamp and target only contain lowercase letters. 分析 参考代码 updating]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Greedy</tag>
        <tag>Sting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[935.Knight Dialers（骑士拨号器）]]></title>
    <url>%2F2018%2F11%2F06%2F935-Knight-Dialer%2F</url>
    <content type="text"><![CDATA[DescriptionA chess knight can move as indicated in the chess diagram below: This time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops. Each hop must be from one key to another numbered key. Each time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total. How many distinct numbers can you dial in this manner? Since the answer may be large, output the answer modulo 10^9 + 7. 国际象棋中的骑士可以按下图所示进行移动： 这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。 每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。 你能用这种方式拨出多少个不同的号码？ 因为答案可能很大，所以输出答案模 10^9 + 7。 题目链接：https://leetcode.com/problems/knight-dialer/ Difficulty: medium Example 1:Input: 1 Output: 10 Example 2:Input: 2 Output: 20 Example 3:Input: 3 Output: 46 Note: 1 &lt;= N &lt;= 5000 分析 首先可以找到如下规律，1的下一个数字只能是6和8，2的下一个数字只能是7和9，因此对应关系如下：{1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}； 所以第N步为数字6的可能总数是：第N-1步为数字1加上第N-1步为数字7加上第N-1步为数字0； 第一步每个数字的总数都为1； 以此原则，迭代求取每一步之后各个数字的可能总数； 返回总数和。 参考代码class Solution: def knightDialer(self, N): D={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]} s=[1]*10 for i in range(N-1): new_s=[0]*10 for i in range(10): for tar in D[i]: new_s[tar]+=s[i] new_s[tar]%=(10**9+7) s=new_s return sum(s)%(10**9+7)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[934.Shortest Bridge（最短的桥）]]></title>
    <url>%2F2018%2F11%2F06%2F934-Shortest-Bridge%2F</url>
    <content type="text"><![CDATA[DescriptionIn a given 2D binary array A, there are two islands. (An island is a 4-directionally connected group of 1s not connected to any other 1s.) Now, we may change 0s to 1s so as to connect the two islands together to form 1 island. Return the smallest number of 0s that must be flipped. (It is guaranteed that the answer is at least 1.) 在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。） 现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。 返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。） 题目链接：https://leetcode.com/problems/shortest-bridge/ Difficulty: medium Example 1:Input: [[0,1],[1,0]] Output: 1 Example 2:Input: [[0,1,0],[0,0,0],[0,0,1]] Output: 2 Example 3:Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] Output: 1 Note: 1 &lt;= A.length = A[0].length &lt;= 100 A[i][j] == 0 or A[i][j] == 1 分析 每个岛的位置标志都是1，首先将两个岛分开，其中一个岛标1，另外一个标2（上下左右不相连即为两个岛）； 找到一个为1的点作为初始点标为2，存入list，遍历上下左右四个相邻点，若为则加入到list中； 遍历list，重复2（也可以利用队列，每次pop一个元素，我的代码中有index游标遍历list）； 将值为1的点的坐标加到D1中，值为2的点的坐标加到D2中； 直接比较D1和中D2中每个点的距离，返回最小值，时间复杂度为 $O(n^2)$ ,时间会超限； 首先将D1中的点node及其距离d（初始为0）加入到queue中，node放入done中（遍历完的点）； 遍历queue，若node在D2中则返回d（即为最小距离） 反之，将node上下左右相邻四个点中不在done中的点，d+1，加入到queue中； 重复7，8; 因为是多点到多点的最短路径，所以没有采用单点的深度优先遍历。 参考代码class Solution: def shortestBridge(self, A): row,col=len(A),len(A[0]) li=[] x,y=0,0 for i in range(row*col): if(A[i//col][i%col]==1): A[i//col][i%col]=2 li.append((i//col,i%col)) x,y=i//col,i%col break index=0 while(index&lt;len(li)): x,y=li[index] if(x-1&gt;=0 and A[x-1][y]==1): li.append((x-1,y)) A[x-1][y]=2 if(y-1&gt;=0 and A[x][y-1]==1): li.append((x,y-1)) A[x][y-1]=2 if(x+1&lt;row and A[x+1][y]==1): li.append((x+1,y)) A[x+1][y]=2 if(y+1&lt;col and A[x][y+1]==1): li.append((x,y+1)) A[x][y+1]=2 index+=1 D1=set() D2=set() for i in range(row): for j in range(col): if(A[i][j]==1): D1.add((i,j)) elif(A[i][j]==2): D2.add((i,j)) done=set(D1) queue=[[d,0]for d in D1] i=0 while(len(queue[i:])): node,d=queue[i] i+=1 if(node in D2): return d-1 x,y=node if(x-1&gt;=0 and (x-1,y) not in done): queue.append([(x-1,y),d+1]) done.add((x-1,y)) if(y-1&gt;=0 and (x,y-1) not in done): queue.append([(x,y-1),d+1]) done.add((x,y-1)) if(x+1&lt;row and (x+1,y) not in done): queue.append([(x+1,y),d+1]) done.add((x+1,y)) if(y+1&lt;col and (x,y+1) not in done): queue.append([(x,y+1),d+1]) done.add((x,y+1))]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Depth-first Search</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[933.Number of Recent Calls（最近的请求次数）]]></title>
    <url>%2F2018%2F11%2F06%2F933-Number-of-Recent-Calls%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before. 写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。 返回从 3000 毫秒前到现在的 ping 数。 任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。 保证每次对 ping 的调用都使用比之前更大的 t 值。 题目链接：https://leetcode.com/problems/number-of-recent-calls/ Difficulty: easy Example 1:Input: inputs = [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3] Note: Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 &lt;= t &lt;= 10^9. 分析 用list存储所有的t； ping是，删除list中所有小于t-3000的值； 返回list的长度。 参考代码class RecentCounter: def __init__(self): self.li=[] def ping(self, t): self.li.append(t) index=0 while(True): if(self.li[index]&lt;t-3000): index+=1 else: self.li=self.li[index:] break return len(self.li)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[932.Beautiful Array（漂亮数组）]]></title>
    <url>%2F2018%2F10%2F28%2F932-Beautiful-Array%2F</url>
    <content type="text"><![CDATA[DescriptionFor some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, …, N, such that: For every i &lt; j, there is no k with i &lt; k &lt; j such that A[k] * 2 = A[i] + A[j]. Given N, return any beautiful array A. (It is guaranteed that one exists.) 对于某些固定的 N，如果数组 A 是整数 1, 2, …, N 组成的排列，使得： 对于每个 i &lt; j，都不存在 k 满足 i &lt; k &lt; j 使得 A[k] * 2 = A[i] + A[j]。 那么数组 A 是漂亮数组。 给定 N，返回任意漂亮数组 A（保证存在一个）。 题目链接：https://leetcode.com/problems/beautiful-array/ Difficulty: medium Example 1:Input: 4 Output: [2,1,4,3] Example 2:Input: 5 Output: [3,1,2,5,4] Note: 1 &lt;= N &lt;= 1000 分析 updating 参考代码updating]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[931.Minimum Falling Path Sum（下降路径最小和）]]></title>
    <url>%2F2018%2F10%2F28%2F931-Minimum-Falling-Path-Sum%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a square array of integers A, we want the minimum sum of a falling path through A. A falling path starts at any element in the first row, and chooses one element from each row. The next row’s choice must be in a column that is different from the previous row’s column by at most one. 给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。 下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。 题目链接：https://leetcode.com/problems/minimum-falling-path-sum/ Difficulty: medium Example 1:Input: [[1,2,3],[4,5,6],[7,8,9]] Output: 12 Explanation: The possible falling paths are: .[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9] .[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9] .[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9] The falling path with the smallest sum is [1,4,7], so the answer is 12. Note: 1 &lt;= A.length == A[0].length &lt;= 100 -100 &lt;= A[i][j] &lt;= 100 分析 由题意知，从一行的一点到下一行，只有三种情况，当前列、当前列的前一列、当前列的后一列，由此反推，到达下一行的一点的上一点也只有三种情况，故由此可以分步得到以每个点结尾的最小路径和； 定义tar存储每一行每个点结尾的最小路径和，其中长度是A的长度加2，补齐两端是为了在计算两端点路径时，也可以统一计算三个路径的最小值； 返回最后一行对应点的最小路径和。 参考代码class Solution: def minFallingPathSum(self, A): tar=[0]*(len(A[0])+2) tar[0]=10000 tar[-1]=10000 for a in A: t=[0]*(len(A[0])+2) t[0]=10000 t[-1]=10000 for i in range(len(a)): t[i+1]=min(tar[i],tar[i+1],tar[i+2])+a[i] tar=t return min(tar[1:-1])]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[930.Binary Subarrays With Sum（和相同的二元子数组）]]></title>
    <url>%2F2018%2F10%2F28%2F930-Binary-Subarrays-With-Sum%2F</url>
    <content type="text"><![CDATA[DescriptionIn an array A of 0s and 1s, how many non-empty subarrays have sum S? 在由若干 0 和 1 组成的数组 A 中，有多少个和为 S 的非空子数组。 题目链接：https://leetcode.com/problems/binary-subarrays-with-sum/ Difficulty: medium Example 1:Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Note: A.length &lt;= 30000 0 &lt;= S &lt;= A.length A[i] is either 0 or 1. 分析 若是得到每个字串的和，时间复杂度为 $O(n^2)$ ,A的长度是30000，时间会超限； 遍历A得到以每个位置结尾的字串（从头开始）的和，存入字典d中，key：字串和，value：满足key和的字串总数； 遍历的同时计算满足要求的字串，1.当前字串和为S，s（满足要求的字串数目）加一，2.s加上字串和为当前字串和index与S的差值的字串数目； 返回s。 参考代码class Solution: def numSubarraysWithSum(self, A, S): d={} s=0 index=0 for i in range(len(A)): if(A[i]==1): index+=1 if(index==S): s+=1 if((index-S) in d): s+=d[index-S] if(index in d): d[index]+=1 else: d[index]=1 return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[929.Unique Email Addresses（独特的电子邮件地址）]]></title>
    <url>%2F2018%2F10%2F28%2F929-Unique-Email-Addresses%2F</url>
    <content type="text"><![CDATA[DescriptionEvery email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain ‘.’s or ‘+’s. If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, “alice.z@leetcode.com“ and “alicez@leetcode.com“ forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? 每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。 例如，在 alice@leetcode.com中， alice 是本地名称，而 leetcode.com 是域名。 除了小写字母，这些电子邮件还可能包含 ‘,’ 或 ‘+’。 如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（’.’），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，”alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。） 如果在本地名称中添加加号（’+’），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。） 可以同时使用这两个规则。 给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？ 题目链接：https://leetcode.com/problems/unique-email-addresses/ Difficulty: easy Example 1:Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;] Output: 2 Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one ‘@’ character. 分析 每一个email中只包含一个“@”，利用“@”将local name and a domain name分开； 由题意知，每个localname中“.”是可以忽略的，“+”后面的是不需要的，故将localname中的“.”与“+”之后的内容去掉； domain name是不需要修改的，将localname和domainname合并加入到set中； 返回set的长度。 参考代码class Solution: def numUniqueEmails(self, emails): D=set() for tar in emails: n1,n2=tar.split(&apos;@&apos;) n1=n1.split(&apos;+&apos;)[0] n1=n1.replace(&apos;.&apos;,&apos;&apos;) D.add(n1+n2) return len(D)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四则运算表达式求值（利用前缀后缀表达式）]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%EF%BC%88%E5%88%A9%E7%94%A8%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[中缀表达式中缀表达式就是常见的运算表达式，如(3+4)*5-6 前缀表达式前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前 比如:- * + 3 4 5 6 前缀表达式的计算机求值从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时， 弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素）， 并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例子（- * + 3 4 5 6） 从右至左扫描，将6、5、4、3压入堆栈 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈 接下来是*运算符，因此弹出7和5，计算出7×5=35，将35入栈 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 将中缀表达式转换为前缀表达式 初始化两个栈:运算符栈s1，储存中间结果的栈s2 从右至左扫描中缀表达式 遇到操作数时，将其压入s2 遇到运算符时，比较其与s1栈顶运算符的优先级 如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较 遇到括号时 如果是右括号“)”，则直接压入s1 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最左边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式 具体过程例如:1+((2+3)*4)-5具体过程，如下表 扫描到的元素 S2 S1 说明 5 5 空 数字，直接入栈 - 5 - s1为空，运算符直接入栈 ) 5 -) 右括号直接入栈 4 54 -) 数字，直接入栈 * 54 -)* s1栈顶是右括号，直接入栈 ) 54 -)*) 右括号直接入栈 ) 5 4 -)x) 右括号直接入栈 3 5 4 3 -)x) 数字 + 5 4 3 -)x)+ s1栈顶是右括号，直接入栈 2 5 4 3 2 -)x)+ 数字 ( 5 4 3 2 + -)x 左括号，弹出运算符直至遇到右括号 ( 5 4 3 2 + * - 同上 + 5 4 3 2 + * -+ 优先级与-相同，入栈 1 5 4 3 2 + * 1 -+ 数字 到达最左端 5 4 3 2 + * 1 + - 空 s1剩余运算符 结果是:- + 1 × + 2 3 4 5后缀表达式后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 后缀表达式计算机求值与前缀表达式类似，只是顺序是从左至右： 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数， 用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈； 重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例子（3 4 + 5 * 6 -） 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。 将中缀表达式转换为后缀表达式 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）； 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1； 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃； 重复步骤2至5，直到表达式的最右边； 将s1中剩余的运算符依次弹出并压入s2； 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序） 具体过程例如，将中缀表达式“1+((2+3)*4)-5”转换为后缀表达式的过程如下： 扫描到的元素 S2 S1 说明 1 1 空 数字，直接入栈 + 1 + s1为空，运算符直接入栈 ( 1 + ( 左括号，直接入栈 ( 1 + ( ( 同上 2 1 2 + ( ( 数字 + 1 2 + ( ( + s1栈顶为左括号，运算符直接入栈 3 1 2 3 + ( ( + 数字 ) 1 2 3 + + ( 右括号，弹出运算符直至遇到左括号 * 1 2 3 + + ( * s1栈顶为左括号，运算符直接入栈 4 1 2 3 + 4 + ( * 数字 ) 1 2 3 + 4 * + 右括号，弹出运算符直至遇到左括号 - 1 2 3 + 4 * + - -与+优先级相同，因此弹出+，再压入- 5 1 2 3 + 4 * + 5 - 数字 到达最右端 1 2 3 + 4 * + 5 - 空 s1中剩余的运算符 因此结果为“1 2 3 + 4 × + 5 -”备注参考 https://www.cnblogs.com/chensongxian/p/7059802.html 代码是自己有python搞得，transform可以去除空格，一般题目里面有这样的需求。 源代码class Solution: def calculator(self,s): li=self.transform(s) print(&apos;li&apos;,li) forward=self.forward(li) print(&quot;forward&quot;,forward) result1=self.calForward(forward) print(&quot;result1:&quot;,result1) back=self.back(li) print(&quot;back&quot;,back) result2=self.calBack(back) print(&quot;result2:&quot;,result2) def calBack(self,back):#计算后缀表达式 s=[] for i in range(len(back)): if(isinstance(back[i],int)): s.append(back[i]) else: b=s.pop() a=s.pop() s.append(self.cal(a,b,back[i])) if(len(s)==0): return None return s[-1] def back(self,li):#得到后缀表达式 s1=[] s2=[] for i in range(len(li)): if(isinstance(li[i],int)):#li[i]是数字 s2.append(li[i]) elif(li[i] in &apos;+-*/&apos;):#li[i]是运算符 while(True): if(len(s1)==0 or s1[-1]==&apos;(&apos;):#s1为空或栈顶为‘(’，压栈 s1.append(li[i]) break elif(self.get(li[i])&gt;self.get(s1[-1])):#优先级大于等于栈顶，压栈 s1.append(li[i]) break else:#s1的栈顶元素压入s2，重复上述步骤 s2.append(s1.pop()) else: if(li[i]==&apos;(&apos;):#右括号压栈 s1.append(li[i]) else:#左括号，将s1栈顶元素压入s2，直至遇到右括号 tar=s1.pop() while(tar!=&apos;(&apos;): s2.append(tar) tar=s1.pop() while(s1): s2.append(s1.pop()) return s2 def calForward(self,forward):#计算前缀表达式 s=[] for i in range(len(forward)): if(isinstance(forward[i],int)): s.append(forward[i]) else: a=s.pop() b=s.pop() s.append(self.cal(a,b,forward[i])) if(len(s)==0): return None return s[-1] def forward(self,li):#得到前缀表达式 s1=[] s2=[] for i in range(len(li)-1,-1,-1): if(isinstance(li[i],int)):#li[i]是数字 s2.append(li[i]) elif(li[i] in &apos;+-*/&apos;):#li[i]是运算符 while(True): if(len(s1)==0 or s1[-1]==&apos;)&apos;):#s1为空或栈顶为‘）’，压栈 s1.append(li[i]) break elif(self.get(li[i])&gt;=self.get(s1[-1])):#优先级大于等于栈顶，压栈 s1.append(li[i]) break else:#s1的栈顶元素压入s2，重复上述步骤 s2.append(s1.pop()) else: if(li[i]==&apos;)&apos;):#右括号压栈 s1.append(li[i]) else:#左括号，将s1栈顶元素压入s2，直至遇到右括号 tar=s1.pop() while(tar!=&apos;)&apos;): s2.append(tar) tar=s1.pop() while(s1): s2.append(s1.pop()) return s2 def transform(self,s):#转换字符串，得到数字和运算符的链表形式 li=[] judge=False index=0 for tar in s: if(tar==&apos; &apos;): continue elif(tar in &apos;+-*/()&apos;): if(judge): li.append(index) judge=False index=0 li.append(tar) else: index=index*10+int(tar) judge=True if(judge): li.append(index) return li def cal(self,a,b,ch):#计算 if(ch==&apos;+&apos;): return a+b elif(ch==&apos;-&apos;): return a-b elif(ch==&apos;*&apos;): return a*b elif(ch==&apos;/&apos;): return a/b else: return 0 def get(self,ch):#得到优先级 if(ch in &apos;+-&apos;): return 1 elif(ch in &apos;*/&apos;): return 3 else: return 0]]></content>
      <categories>
        <category>whatever</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[928.Minmize Malware Spread II（尽量减少恶意软件的传播 II）]]></title>
    <url>%2F2018%2F10%2F23%2F928-Minmize-Malware-Spread-II%2F</url>
    <content type="text"><![CDATA[Description(This problem is the same as Minimize Malware Spread, with the differences bolded.) In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list, completely removing it and any connections from this node to any other node. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. (这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。) 在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。 我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。 题目链接：https://leetcode.com/problems/minimize-malware-spread-ii/ Difficulty: hard Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0 Example 2:Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] Output: 1 Example 3:Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] Output: 1 Note: 1 &lt; graph.length = graph[0].length &lt;= 300 0 &lt;= graph[i][j] == graph[j][i] &lt;= 1 graph[i][i] = 1 1 &lt;= initial.length &lt; graph.length 0 &lt;= initial[i] &lt; graph.length 分析 定义dfs（index,po）为深度遍历函数，返回新感染的结点总数，self.gra存储每个结点的感染状态（1为感染，0为未感染）po是与Minmize Malware Spread不同的地方，存储了当前去除的感染点，那么后面深度遍历是，所有与他相连的点是忽略的，具体的忽略做法是：index-j的边若包含po，则不进行下一步感染； dfs从初始结点i开始，遍历所有剩下结点j，若graph[i][j]==1(i,j相连)，则j被感染，以j为初始结点，进入下一层深度遍历，直至所有相连结点都被感染； 遍历initial，即去除当前结点i的感染状态，初始化self.gra，遍历除了i结点外initial中所有结点，作为初始结点，深度遍历，返回新感染的结点个数； 得到返回新感染节点个数最小的对应的去除的结点，即使需要得到的结果； 题目中要求返回最小的结点序号，可以对initial排序之后再处理。 参考代码class Solution: def minMalwareSpread(self, graph, initial): length=len(graph[0]) def dfs(index,po): s=0 for j in range(length): if(index != j): if(j != po and graph[index][j]==1 and self.gra[j]==0): self.gra[j]=1 s+=(dfs(j,po)+1) return s index =length initial.sort() target=initial[0] for i in initial: self.gra=[0]*length for tar in initial: if(tar!=i): self.gra[tar]=1 curr=0 for tar in initial: if(tar!=i): curr+=dfs(tar,i) if(curr &lt; index): target=i index=curr return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[927.Three Equal Parts（三等分）]]></title>
    <url>%2F2018%2F10%2F23%2F927-Three-Equal-Parts%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value. If it is possible, return any [i, j] with i+1 &lt; j, such that: A[0], A[1], …, A[i] is the first part; A[i+1], A[i+2], …, A[j-1] is the second part, and A[j], A[j+1], …, A[A.length - 1] is the third part. All three parts have equal binary value. If it is not possible, return [-1, -1]. Note that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value. 给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。 如果可以做到，请返回任何 [i, j]，其中 i+1 &lt; j，这样一来： A[0], A[1], …, A[i] 组成第一部分； A[i+1], A[i+2], …, A[j-1] 作为第二部分； A[j], A[j+1], …, A[A.length - 1] 是第三部分。 这三个部分所表示的二进制值相等。 如果无法做到，就返回 [-1, -1]。 注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。 题目链接：https://leetcode.com/problems/three-equal-parts/ Difficulty: hard Example 1:Input: [1,0,1,0,1] Output: [0,3] Example 2:Input: [1,1,0,1,1] Output: [-1,-1] Note: 3 &lt;= A.length &lt;= 30000 A[i] == 0 or A[i] == 1 分析 i,j将数组分为三个部分a1,a2,a3，通过向后移动i或者向前移动j来判断三部分的值是否相等； 其中移动的i或j的判断依据是移动ij之后对应的a1和a3大小关系，哪个小就移动哪个，我考虑的是移动较小的可以更准确的逼近准确值，相等时，移动i； 直至a1=a2=a3返回[i,j],否则若i+1&lt;j返回[-1,-1]。 参考代码class Solution: def threeEqualParts(self, A): i=0 j=len(A)-1 a1=A[i] a2=0 s=0 s+=a1 for posi in range(1,len(A)-1): a2*=2 if(A[posi]==1): a2+=1 s+=1 a3=A[j] s+=a3 if(s%3!=0): return [-1,-1] index=2 indexP=2**(len(A)-3) while(i+1&lt;j): if(a1==a2==a3): return [i,j] if(a1&gt;a2 or a3&gt;a2): return [-1,-1] if(((a1&lt;&lt;1)+A[i+1]) &gt; (index*A[j-1]+a3)): a3+=index*A[j-1] index=index&lt;&lt;1 a2=a2&gt;&gt;1 indexP=indexP&gt;&gt;1 j-=1 else: a1=(a1&lt;&lt;1)+A[i+1] a2-=(indexP*A[i+1]) indexP=indexP&gt;&gt;1 i+=1 return [-1,-1]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[926.Flip String to Monotone Increasing（将字符串翻转到单调递增）]]></title>
    <url>%2F2018%2F10%2F23%2F926-Flip-String-to-Monotone-Increasing%2F</url>
    <content type="text"><![CDATA[DescriptionA string of ‘0’s and ‘1’s is monotone increasing if it consists of some number of ‘0’s (possibly 0), followed by some number of ‘1’s (also possibly 0.) We are given a string S of ‘0’s and ‘1’s, and we may flip any ‘0’ to a ‘1’ or a ‘1’ to a ‘0’. Return the minimum number of flips to make S monotone increasing. 如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是单调递增的。 我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 S，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。 返回使 S 单调递增的最小翻转次数。 题目链接：https://leetcode.com/problems/flip-string-to-monotone-increasing/ Difficulty: medium Example 1:Input: &quot;00110&quot; Output: 1 Explanation: We flip the last digit to get 00111. Example 2:Input: &quot;010110&quot; Output: 2 Explanation: We flip to get 011111, or alternatively 000111. Example 3:Input: &quot;00011000&quot; Output: 2 Explanation: We flip to get 00000000. Note: 1 &lt;= S.length &lt;= 20000 S only consists of ‘0’ and ‘1’ characters. 分析 由题意知，需要将字符串变为前半部分为0后半部分为1的最小变换次数； 记录所有0和1出现的次数，变换次数初始化为其中的最小值； 定义x为前半部分出现1的次数，y为后半部分出现0的次数，变换次数m等于x+y; 遍历s，若当前位置为1则x+=1，反之y-=1，更新m的最小值； 返回m。 参考代码class Solution: def minFlipsMonoIncr(self, S): s0=0 s1=0 for i in S: if(i==&apos;0&apos;): s0+=1 else: s1+=1 m=min(s0,s1) x1=0 y0=s0 for i in S: m=min(m,x1+y0) if(i==&apos;1&apos;): x1+=1 else: y0-=1 return m]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[925.Long Pressed Name（长按键入）]]></title>
    <url>%2F2018%2F10%2F23%2F925-Long-Pressed-Name%2F</url>
    <content type="text"><![CDATA[DescriptionYour friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. 你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 题目链接：https://leetcode.com/problems/long-pressed-name/ Difficulty: easy Example 1:Input: name = &quot;alex&quot;, typed = &quot;aaleex&quot; Output: true Explanation: &apos;a&apos; and &apos;e&apos; in &apos;alex&apos; were long pressed. Example 2:Input: name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot; Output: false Explanation: &apos;e&apos; must have been pressed twice, but it wasn&apos;t in the typed output. Example 3:Input: name = &quot;leelee&quot;, typed = &quot;lleeelee&quot; Output: true Example 4:Input: name = &quot;laiden&quot;, typed = &quot;laiden&quot; Output: true Explanation: It&apos;s not necessary to long press any character. Note: name.length &lt;= 1000 typed.length &lt;= 1000 The characters of name and typed are lowercase letters. 分析 由题意知，由于长按导致的情况是某一个字母出现的次数变多，且是连续的，定义一个get用于返回连续的字母及其出现的次数，形如get(“aaleex”)-&gt;[(‘a’,2),(‘l’,1),(‘e’,2),(‘x’,1)] 若name和typed都为空则返回True； 若get(name)和get(typed)的长度不一致，返回False； 反之，若每一项中get(typed)的次数大于等于get(name)，则返回True，反之False。 参考代码class Solution: def isLongPressedName(self, name, typed): def get(s): if(len(s)==0): return [] li=[] tar=s[0] index=0 for i in s: if(i!=tar): li.append((tar,index)) index=0 tar=i else: index+=1 return li l1=get(name) l2=get(typed) if(len(l1)==0 and len(l2)==0): return True if(len(l1) == len(l2)): for i in range(len(l1)): if(l1[i][0]==l2[i][0] and l1[i][1]&lt;=l2[i][1]): continue else: return False return True else: return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[924.Minimize Malware Spread（尽量减少恶意软件的传播）]]></title>
    <url>%2F2018%2F10%2F14%2F924-Minimize-Malware-Spread%2F</url>
    <content type="text"><![CDATA[DescriptionIn a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1. Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner. Suppose M(initial) is the final number of nodes infected with malware in the entire network, after the spread of malware stops. We will remove one node from the initial list. Return the node that if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index. Note that if a node was removed from the initial list of infected nodes, it may still be infected later as a result of the malware spread. 在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。 我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。 请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。 题目链接：https://leetcode.com/problems/minimize-malware-spread/description/ Difficulty: hard Example 1:Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] Output: 0 Example 2:Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2] Output: 0 Example 3:Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2] Output: 1 Note: 1 &lt; graph.length = graph[0].length &lt;= 300 0 &lt;= graph[i][j] == graph[j][i] &lt;= 1 graph[i][i] = 1 1 &lt;= initial.length &lt; graph.length 0 &lt;= initial[i] &lt; graph.length 分析 定义dfs（index）为深度遍历函数，返回新感染的结点总数，self.gra存储每个结点的感染状态（1为感染，0为未感染）； dfs从初始结点i开始，遍历所有剩下结点j，若graph[i][j]==1(i,j相连)，则j被感染，以j为初始结点，进入下一层深度遍历，直至所有相连结点都被感染； 遍历initial，即去除当前结点i的感染状态，初始化self.gra，遍历除了i结点外initial中所有结点，作为初始结点，深度遍历，返回新感染的结点个数； 得到返回新感染节点个数最小的对应的去除的结点，即使需要得到的结果； 题目中要求返回最小的结点序号，可以对initial排序之后再处理。 参考代码class Solution: def minMalwareSpread(self, graph, initial): length=len(graph[0]) def dfs(index): s=0 for j in range(length): if(index != j): if(graph[index][j]==1 and self.gra[j]==0): self.gra[j]=1 s+=(dfs(j)+1) return s index =length initial.sort() target=initial[0] for i in initial: self.gra=[0]*length for tar in initial: if(tar!=i): self.gra[tar]=1 curr=0 for tar in initial: if(tar!=i): curr+=dfs(tar) if(curr &lt; index): target=i index=curr return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[923.3Sum With Multiplicity（三数之和的多种可能）]]></title>
    <url>%2F2018%2F10%2F14%2F923-3Sum-With-Multiplicity%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an integer array A, and an integer target, return the number of tuples i, j, k such that i &lt; j &lt; k and A[i] + A[j] + A[k] == target. As the answer can be very large, return it modulo 10^9 + 7. 给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i &lt; j &lt; k 且 A[i] + A[j] + A[k] == target 的元组 i, j, k 的数量。 由于结果会非常大，请返回 结果除以 10^9 + 7 的余数。 题目链接：https://leetcode.com/problems/3sum-with-multiplicity/description/ Difficulty: medium Example 1:Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation: Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times. Example 2:Input: A = [1,1,2,2,2,2], target = 5 Output: 12 Explanation: A[i] = 1, A[j] = A[k] = 2 occurs 12 times: We choose one 1 from [1,1] in 2 ways, and two 2s from [2,2,2,2] in 6 ways. Note: 3 &lt;= A.length &lt;= 3000 0 &lt;= A[i] &lt;= 100 0 &lt;= target &lt;= 300 分析 如果直接在A中选取三个数字，然后计算和是否为target的话，时间复杂度为 $O(n^3)$ 对A进行压缩计数，得到{1:2,2:2,3:3,4:2,5:2}(如例一) 从[1,2,3,4,5]中选取三个数，但是每个数被选中的次数不能超过它在A中出现的次数（在judge函数中实现，judge(a,b)相当于从b个中选取a个的可能性） 三层循环得到三个数字，如和为target，则返回所有数字出现的可能性的乘积，即当前数字的可能的组合个数； 反之，继续； 返回所有满足条件的组合总数。 参考代码class Solution: def threeSumMulti(self, A, target): import collections count=collections.Counter(A) s=0 def judge(a,b): if(a&gt;b): return 0 s=1 for i in range(b,a,-1): s*=i for i in range(2,b-a+1): s//=i return s li=list(count.keys()) for i in range(len(li)): for j in range(i,len(li)): for k in range(j,len(li)): index1=li[i] index2=li[j] index3=li[k] if(index1+index2+index3!=target): continue countIndex=collections.Counter([index1,index2,index3]) curr = 1 for index in countIndex: curr*=judge(countIndex[index],count[index]) s+=curr s%=(10**9+7) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[922.Sort Array By Parity II（按奇偶排序数组 II）]]></title>
    <url>%2F2018%2F10%2F14%2F922-Sort-Array-By-Parity-II%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even. Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even. You may return any answer array that satisfies this condition. 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 题目链接：https://leetcode.com/problems/sort-array-by-parity-ii/description/ Difficulty: easy Example 1:Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Note: 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 分析 由题意知，是为了使得list中每个数与对应的下标的奇偶性一致； 遍历list，如当前位置的数与下标的奇偶性一致，则继续； 反之，往后寻找一个数字的奇偶性与当前下标的奇偶性一致的数，交换两个数的位置； 小改进：往后找的时候，去找数字的奇偶性与它对应的下标奇偶性不一致的数字，减少后续比较的次数，代码中是当时做的时候写的，没有体现这一点，但是也AC了。 参考代码class Solution: def sortArrayByParityII(self, A): for i in range(len(A)): j=i+1 if((A[i]%2)==(i%2)): continue while(j&lt;len(A)): if((A[j]%2)==(i%2)): A[i],A[j]=A[j],A[i] break j+=1 return A]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[921.Minunum Add to Make Parentheses Valid（使括号有效的最少添加）]]></title>
    <url>%2F2018%2F10%2F14%2F921-Minunum-Add-to-Make-Parentheses-Valid%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string S of ‘(‘ and ‘)’ parentheses, we add the minimum number of parentheses ( ‘(‘ or ‘)’, and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. 给定一个由 ‘(‘ 和 ‘)’ 括号组成的字符串 S，我们需要添加最少的括号（ ‘(‘ 或是 ‘)’，可以在任何位置），以使得到的括号字符串有效。 从形式上讲，只有满足下面几点之一，括号字符串才是有效的： 它是一个空字符串，或者 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者 它可以被写作 (A)，其中 A 是有效字符串。 给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。 题目链接：https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/description/ Difficulty: medium Example 1:Input: &quot;())&quot; Output: 1 Example 2:Input: &quot;(((&quot; Output: 3 Example 3:Input: &quot;()&quot; Output: 0 Example 4:Input: &quot;()))((&quot; Output: 4 Note: S.length &lt;= 1000 S only consists of ‘(‘ and ‘)’ characters. 分析 括号匹配问题，如果“（”先出现，则后面后出现的“）”可以将前面的一个“（”抵消； 但是“）”先出现，则无法抵消； 遍历输入字符串，index记录“（”的个数，若出现“）”，index减一，若index等于零，则不合法括号数s加一； 最后返回index+s。 参考代码class Solution: def minAddToMakeValid(self, S): index=0 s=0 for i in range(len(S)): if(S[i]==&apos;(&apos;): index+=1 else: if(index!=0): index-=1 else: s+=1 return s+index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[920.Number of Music Playlists]]></title>
    <url>%2F2018%2F10%2F08%2F920-Number-of-Music-Playlists%2F</url>
    <content type="text"><![CDATA[DescriptionYour music player contains N different songs and she wants to listen to L (not necessarily different) songs during your trip. You create a playlist so that: Every song is played at least once A song can only be played again only if K other songs have been played Return the number of possible playlists. As the answer can be very large, return it modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/number-of-music-playlists/ Difficulty: hard Example 1:Input: N = 3, L = 3, K = 1 Output: 6 Explanation: There are 6 possible playlists. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]. Example 2:Input: N = 2, L = 3, K = 0 Output: 6 Explanation: There are 6 possible playlists. [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], [1, 2, 2] Example 3:Input: N = 2, L = 3, K = 1 Output: 2 Explanation: There are 2 possible playlists. [1, 2, 1], [2, 1, 2] Note: 0 &lt;= K &lt; N &lt;= L &lt;= 100 分析 updating 参考代码from functools import lru_cache class Solution: def numMusicPlaylists(self, N, L, K): @lru_cache(None) def dp(i, j): if i == 0: return +(j == 0) ans = dp(i-1, j-1) * (N-j+1) ans += dp(i-1, j) * max(j-K, 0) return ans % (10**9+7) return dp(L, N)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[919.Complete Binary Tree Inserter]]></title>
    <url>%2F2018%2F10%2F08%2F919-Complete-Binary-Tree-Inserter%2F</url>
    <content type="text"><![CDATA[DescriptionA complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations: CBTInserter(TreeNode root) initializes the data structure on a given tree with head node root; CBTInserter.insert(int v) will insert a TreeNode into the tree with value node.val = v so that the tree remains complete, and returns the value of the parent of the inserted TreeNode; CBTInserter.get_root() will return the head node of the tree. 题目链接：https://leetcode.com/problems/complete-binary-tree-inserter/ Difficulty: medium Example 1:Input: inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]] Output: [null,1,[1,2]] Example 2:Input: inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]] Output: [null,3,4,[1,2,3,4,5,6,7,8]] Note: The initial given tree is complete and contains between 1 and 1000 nodes. CBTInserter.insert is called at most 10000 times per test case. Every value of a given or inserted node is between 0 and 5000. 分析 updating 参考代码class CBTInserter(object): def __init__(self, root): self.deque = collections.deque() self.root = root q = collections.deque([root]) while q: node = q.popleft() if not node.left or not node.right: self.deque.append(node) if node.left: q.append(node.left) if node.right: q.append(node.right) def insert(self, v): node = self.deque[0] self.deque.append(TreeNode(v)) if not node.left: node.left = self.deque[-1] else: node.right = self.deque[-1] self.deque.popleft() return node.val def get_root(self): return self.root]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[918.Maximum Sum Circular Subarray]]></title>
    <url>%2F2018%2F10%2F08%2F918-Maximum-Sum-Circular-Subarray%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C. Here, a circular array means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 &lt;= i &lt; A.length, and C[i+A.length] = C[i] when i &gt;= 0.) Also, a subarray may only include each element of the fixed buffer A at most once. (Formally, for a subarray C[i], C[i+1], …, C[j], there does not exist i &lt;= k1, k2 &lt;= j with k1 % A.length = k2 % A.length.) 题目链接：https://leetcode.com/problems/maximum-sum-circular-subarray/ Difficulty: medium Example 1:Input: [1,-2,3,-2] Output: 3 Explanation: Subarray [3] has maximum sum 3 Example 2:Input: [5,-3,5] Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10 Example 3:Input: [3,-1,2,-1] Output: 4 Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4 Example 4:Input: [3,-2,2,-3] Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3 Example 5:Input: [-2,-3,-1] Output: -1 Explanation: Subarray [-1] has maximum sum -1 Note: -30000 &lt;= A[i] &lt;= 30000 1 &lt;= A.length &lt;= 30000 分析 updating 参考代码class Solution(object): def maxSubarraySumCircular(self, A): N = len(A) ans = cur = None for x in A: cur = x + max(cur, 0) ans = max(ans, cur) # ans is the answer for 1-interval subarrays. # Now, let&apos;s consider all 2-interval subarrays. # For each i, we want to know # the maximum of sum(A[j:]) with j &gt;= i+2 # rightsums[i] = sum(A[i:]) rightsums = [None] * N rightsums[-1] = A[-1] for i in xrange(N-2, -1, -1): rightsums[i] = rightsums[i+1] + A[i] # maxright[i] = max_{j &gt;= i} rightsums[j] maxright = [None] * N maxright[-1] = rightsums[-1] for i in xrange(N-2, -1, -1): maxright[i] = max(maxright[i+1], rightsums[i]) leftsum = 0 for i in xrange(N-2): leftsum += A[i] ans = max(ans, leftsum + maxright[i+2]) return ans]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[917.Reverse Only Letters]]></title>
    <url>%2F2018%2F10%2F08%2F917-Reverse-Only-Letters%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a string S, return the “reversed” string where all characters that are not a letter stay in the same place, and all letters reverse their positions. 题目链接：https://leetcode.com/problems/reverse-only-letters/ Difficulty: easy Example 1:Input: &quot;ab-cd&quot; Output: &quot;dc-ba&quot; Example 2:Input: &quot;a-bC-dEf-ghIj&quot; Output: &quot;j-Ih-gfE-dCba&quot; Example 3:Input: &quot;Test1ng-Leet=code-Q!&quot; Output: &quot;Qedo1ct-eeLg=ntse-T!&quot; Note: S.length &lt;= 100 33 &lt;= S[i].ASCIIcode &lt;= 122 S doesn’t contain \ or “ 分析 updating 参考代码class Solution(object): def reverseOnlyLetters(self, S): letters = [c for c in S if c.isalpha()] ans = [] for c in S: if c.isalpha(): ans.append(letters.pop()) else: ans.append(c) return &quot;&quot;.join(ans)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[916.Word Subsets]]></title>
    <url>%2F2018%2F10%2F01%2F916-Word-Subsets%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given two arrays A and B of words. Each word is a string of lowercase letters. Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity. For example, “wrr” is a subset of “warrior”, but is not a subset of “world”. Now say a word a from A is universal if for every b in B, b is a subset of a. Return a list of all universal words in A. You can return the words in any order. 题目链接：https://leetcode.com/problems/word-subsets/description/ Difficulty: hard Example 1:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;o&quot;] Output: [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;] Example 2:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;l&quot;,&quot;e&quot;] Output: [&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;] Example 3:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;oo&quot;] Output: [&quot;facebook&quot;,&quot;google&quot;] Example 4:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;lo&quot;,&quot;eo&quot;] Output: [&quot;google&quot;,&quot;leetcode&quot;] Example 5:Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;ec&quot;,&quot;oc&quot;,&quot;ceo&quot;] Output: [&quot;facebook&quot;,&quot;leetcode&quot;] Note: 1 &lt;= A.length, B.length &lt;= 10000 1 &lt;= A[i].length, B[i].length &lt;= 10 A[i] and B[i] consist only of lowercase letters. All words in A[i] are unique: there isn’t i != j with A[i] == A[j]. 分析 如题所定义的包含关系可以转化为，字符串A,B，若B中的每一个字母出现的次数都小于等于A中字母出现的次数，则A包含B； 对于B中每一个字符串，统计对应字母出现次数最多的次数，存在dicb中； 对于A中每个字符串a，计算a中每个字母出现的次数，存在dica中； 若dica包含dicb，则a是满足要求的字符串。 参考代码class Solution: def wordSubsets(self, A, B): from collections import defaultdict dicb=defaultdict(lambda:0) for b in B: d=defaultdict(lambda:0) for tar in b: d[tar]+=1 for tar in d: dicb[tar]=max(dicb[tar],d[tar]) li=[] #print(dicb) for a in A: dica=defaultdict(lambda:0) for tar in a: dica[tar]+=1 #print(dica) if(all(dica[c]&gt;=dicb[c] for c in dicb)): li.append(a) return li]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[915.Partition Array into Disjoint Intervals]]></title>
    <url>%2F2018%2F10%2F01%2F915-Partition-Array-into-Disjoint-Intervals%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array A, partition it into two (contiguous) subarrays left and right so that: Every element in left is less than or equal to every element in right. left and right are non-empty. left has the smallest possible size. Return the length of left after such a partitioning. It is guaranteed that such a partitioning exists. 题目链接：https://leetcode.com/problems/partition-array-into-disjoint-intervals/description/ Difficulty: medium Example 1:Input: [5,0,3,8,6] Output: 3 Explanation: left = [5,0,3], right = [8,6] Example 2:Input: [1,1,1,0,6,12] Output: 4 Explanation: left = [1,1,1,0], right = [6,12] Note: 2 &lt;= A.length &lt;= 30000 0 &lt;= A[i] &lt;= 10^6 It is guaranteed there is at least one way to partition A as described. 分析 定义ml为左边序列的最大值，mr为右边序列的最小值，mr初始值min(A)； 循环遍历A，更新ml，mr，其中，若A[i]&gt;mr，则不需要更新mr(这一步不做，会时间超限)，反之，mr=A[i+1:] 若ml&lt;=mr,则返回当前序号。 参考代码class Solution: def partitionDisjoint(self, A): ml=0 index=0 mr=min(A) for i in range(len(A)-1): ml=max(ml,A[i]) if(A[i]==mr): mr=min(A[i+1:]) if(ml&lt;=mr): index=i+1 return index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[914.X of a Kind in a Deck of Cards]]></title>
    <url>%2F2018%2F10%2F01%2F914-X-of-a-Kind-in-a-Deck-of-Cards%2F</url>
    <content type="text"><![CDATA[DescriptionIn a deck of cards, each card has an integer written on it. Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where: Each group has exactly X cards. All the cards in each group have the same integer. 题目链接：https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/description/ Difficulty: easy Example 1:Input: [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4] Example 2:Input: [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition. Example 3:Input: [1] Output: false Explanation: No possible partition. Example 4:Input: [1,1] Output: true Explanation: Possible partition [1,1] Example 5:Input: [1,1,2,2,2,2] Output: true Explanation: Possible partition [1,1],[2,2],[2,2] Note: 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 分析 由题意知，若每个数字出现的次数都大于1，且次数都可以整除某一个数，则返回True，反之False； 找到最小的出现次数m，若小于2，则返回False，能整除的数在[2，m]； 循环，若存在某一个数i（[2，m]）是的每一个数出现的次数都可以整除i，则返回True； 若没有，返回False。 参考代码class Solution: def hasGroupsSizeX(self, deck): dic={} for d in deck: if(d in dic): dic[d]+=1 else: dic[d]=1 m=10000 for d in dic: m=min(dic[d],m) if(dic[d]==1): return False for i in range(2,m+1): for d in dic: if(dic[d]%i!=0): break else: return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[913.Cat and Mouse]]></title>
    <url>%2F2018%2F10%2F01%2F913-Cat-and-Mouse%2F</url>
    <content type="text"><![CDATA[DescriptionA game on an undirected graph is played by two players, Mouse and Cat, who alternate turns. The graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph. Mouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0. During each player’s turn, they must travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it must travel to any node in graph[1]. Additionally, it is not allowed for the Cat to travel to the Hole (node 0.) Then, the game can end in 3 ways: If ever the Cat occupies the same node as the Mouse, the Cat wins. If ever the Mouse reaches the Hole, the Mouse wins. If ever a position is repeated (ie. the players are in the same position as a previous turn, and it is the same player’s turn to move), the game is a draw. Given a graph, and assuming both players play optimally, return 1 if the game is won by Mouse, 2 if the game is won by Cat, and 0 if the game is a draw. 题目链接：https://leetcode.com/problems/cat-and-mouse/description/ Difficulty: hard Example 1:Input: [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]] Output: 0 Explanation: 4---3---1 | | 2---5 \ / 0 Note: 3 &lt;= graph.length &lt;= 50 It is guaranteed that graph[1] is non-empty. It is guaranteed that graph[2] contains a non-zero element. 分析 参考代码 updating…….]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Breadth-first Search</tag>
        <tag>Minimax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder66]机器人的运动范围]]></title>
    <url>%2F2018%2F09%2F22%2Fnowcoder66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 题目链接： https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8 分析 参考代码# -*- coding:utf-8 -*- class Solution: def movingCount(self, threshold, rows, cols): # write code here if(threshold &lt; 0): return 0 ma=[[&apos;0&apos; for j in range(cols)] for i in range(rows)] #ma[0][0]=&apos;#&apos; Sum=self.Find(ma,rows,cols,threshold,0,0) return Sum def Find(self,ma,rows,cols,threshold,i,j): def judge(i,j,threshold): s=0 while(i&gt;0): s+=i%10 i//=10 while(j&gt;0): s+=j%10 j//=10 return bool(s&gt;threshold) if(i&lt;0 or j&lt;0 or i&gt;=rows or j&gt;=cols): return 0 if(ma[i][j]==&apos;#&apos; or judge(i,j,threshold)): return 0 a=b=c=d=0 ma[i][j]=&apos;#&apos; a=self.Find(ma,rows,cols,threshold,i+1,j) b=self.Find(ma,rows,cols,threshold,i-1,j) c=self.Find(ma,rows,cols,threshold,i,j+1) d=self.Find(ma,rows,cols,threshold,i,j-1) return a+b+c+d+1]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder65]矩阵中的路径]]></title>
    <url>%2F2018%2F09%2F22%2Fnowcoder65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 题目链接： https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc 分析 参考代码# -*- coding:utf-8 -*- class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if(len(path)&lt;=0): return True for i in range(rows): for j in range(cols): if(matrix[i*cols+j]==path[0]): if(self.find(list(matrix),rows,cols,path[1:],i,j)): return True return False def find(self,ma,row,col,path,i,j): if(len(path)==0): return True ma[i*col+j]=&apos;#&apos; k=[False,False,False,False] if(j+1&lt;col and ma[i*col+j+1]==path[0]): k[0] = self.find(ma,row,col,path[1:],i,j+1) if(j-1&gt;=0 and ma[i*col+j-1]==path[0]): k[1] = self.find(ma,row,col,path[1:],i,j-1) if(i-1&gt;=0 and ma[(i-1)*col+j]==path[0]): k[2] = self.find(ma,row,col,path[1:],i-1,j) if(i+1&lt;row and ma[(i+1)*col+j]==path[0]): k[3] = self.find(ma,row,col,path[1:],i+1,j) return bool(sum(k))]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder64]滑动窗口的最大值]]></title>
    <url>%2F2018%2F09%2F22%2Fnowcoder64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 题目链接： https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788 分析 参考代码# -*- coding:utf-8 -*- class Solution: def maxInWindows(self, num, size): # write code here if(size&lt;=0 or size&gt;len(num)): return [] m=max(num[:size]) l=[m] for i in range(1,len(num)-size+1): if(num[i+size-1]&gt;=m): m=num[i+size-1] l.append(m) else: if(num[i-1]&lt;m): l.append(m) else: m=max(num[i:i+size]) l.append(m) return l]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder63]数据流中的中位数]]></title>
    <url>%2F2018%2F09%2F22%2Fnowcoder63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 题目链接： https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1 分析 参考代码# -*- coding:utf-8 -*- class Solution: def __init__(self): self.li=[] self.length=0 def Insert(self, num): # write code here for i in range(len(self.li)): if(self.li[i]&gt;num): self.li=self.li[:i]+[num]+self.li[i:] self.length+=1 break else: self.li=self.li+[num] self.length+=1 def GetMedian(self,data): # write code here if(self.length%2==1): return self.li[self.length//2] else: return float(self.li[self.length//2]+self.li[self.length//2-1])/2]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder62]二叉搜索树的第k个结点]]></title>
    <url>%2F2018%2F09%2F22%2Fnowcoder62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 题目链接： https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a 分析 参考代码# -*- coding:utf-8 -*- class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): if(pRoot==None or k&lt;=0): return None li=[pRoot] l=[pRoot.val] while(li): index=li[0] li=li[1:] if(index.left!=None): li.append(index.left) l.append(index.left.val) if(index.right!=None): li.append(index.right) l.append(index.right.val) l.sort() if(k&gt;len(l)): return None target=l[k-1] li=[pRoot] while(li): index=li[0] li=li[1:] if(index.val==target): return index if(index.left!=None): li.append(index.left) if(index.right!=None): li.append(index.right)]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder61]序列化二叉树]]></title>
    <url>%2F2018%2F09%2F15%2Fnowcoder61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述请实现两个函数，分别用来序列化和反序列化二叉树 题目链接： https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84 分析 参考代码-*- coding:utf-8 -*- class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def Serialize(self, root): # write code here s=&apos;&apos; if(root==None): return s li=[root] l=[] st=&apos;&apos; s=str(root.val)+&apos;,&apos; while(li or l): if(not li): li=l if(st): s+=st st=&apos;&apos; l=[] if(not li): continue ro=li[0]; li=li[1:] if(ro.left!=None): l.append(ro.left) st+=str(ro.left.val)+&apos;,&apos; else: st+=&apos;#,&apos; if(ro.right!=None): l.append(ro.right) st+=str(ro.right.val)+&apos;,&apos; else: st+=&apos;#,&apos; return s[:-1] def Deserialize(self, s): if(len(s)==0): return None s=s.split(&apos;,&apos;) head=TreeNode(int(s[0])) q=head li=[q] i=1 length=len(s) while(li and i&lt;length): index=li[0] li=li[1:] if(i&lt;length and s[i]!=&apos;#&apos;): q=TreeNode(int(s[i])) li.append(q) index.left=q i+=1 if(i&lt;length and s[i]!=&apos;#&apos;): q=TreeNode(int(s[i])) li.append(q) index.right=q i+=1 return head]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder60]把二叉树打印成多行]]></title>
    <url>%2F2018%2F09%2F15%2Fnowcoder60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 题目链接： https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288 分析 参考代码-*- coding:utf-8 -*- class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): li=[pRoot] l=[] r_li=[] if(pRoot==None): return r_li r_li.append([pRoot.val]) while(li or l): if(not li): li=l if(l): r_li.append([i.val for i in l]) l=[] if(not li): continue ro=li[0]; li=li[1:] if(ro.left!=None): l.append(ro.left) if(ro.right!=None): l.append(ro.right) return r_li]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder59]按之字形顺序打印二叉树]]></title>
    <url>%2F2018%2F09%2F15%2Fnowcoder59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 题目链接： https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0 分析 参考代码-*- coding:utf-8 -*- class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def Print(self, pRoot): li=[pRoot] l=[] index=0 r_li=[] if(pRoot==None): return r_li r_li.append([pRoot.val]) while(li or l): if(not li): li=l if(l): index+=1 if(index%2==1): l.reverse() r_li.append([i.val for i in l]) l.reverse() else: r_li.append([i.val for i in l]) l=[] if(not li): continue ro=li[0]; li=li[1:] if(ro.left!=None): l.append(ro.left) if(ro.right!=None): l.append(ro.right) return r_li]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder58]对称二叉树]]></title>
    <url>%2F2018%2F09%2F15%2Fnowcoder58-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 题目链接： https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb 分析 参考代码-*- coding:utf-8 -*- class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def isSymmetrical(self, pRoot): # write code here if(pRoot==None): return True li=[pRoot] left_li=[pRoot] right_li=[pRoot] while(li): index=li[0] li=li[1:] if(index==None): continue if(True): li.append(index.left) left_li.append(index.left) if(True): li.append(index.right) left_li.append(index.right) li=[pRoot] l=[] while(li or l): if(not li): li=l l=[] index=li[0] li=li[1:] if(index==None): continue if(True): l.append(index.right) right_li.append(index.right) if(True): l.append(index.left) right_li.append(index.left) for i,j in zip(left_li,right_li): #print(i,j) if(i!=None): if(j==None): return False else: if(i.val!=j.val): return None else: if(j!=None): return False return True]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder57]二叉树的下一个结点]]></title>
    <url>%2F2018%2F09%2F15%2Fnowcoder57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题目链接： https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e 分析 参考代码-*- coding:utf-8 -*- class TreeLinkNode: def __init__(self, x): self.val = x self.left = None self.right = None self.next = None class Solution: def GetNext(self, pNode): # write code here if(pNode.right==None): if(pNode.next==None): return None p=pNode.next if(p.left==pNode): return p else: q=pNode while(p.right==q and p.next!=None): p=p.next q=q.next if(p.left==q): return p return None else: p=pNode.right while(p.left!=None): p=p.left return p]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[903.Valid Permutaions for DI Sequence]]></title>
    <url>%2F2018%2F09%2F10%2F903-Valid-Permutaions-for-DI-Sequence%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given S, a length n string of characters from the set {‘D’, ‘I’}. (These letters stand for “decreasing” and “increasing”.) A valid permutation is a permutation P[0], P[1], …, P[n] of integers {0, 1, …, n}, such that for all i: If S[i] == ‘D’, then P[i] &gt; P[i+1], and; If S[i] == ‘I’, then P[i] &lt; P[i+1]. How many valid permutations are there? Since the answer may be large, return your answer modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/valid-permutations-for-di-sequence/description/ Difficulty: hard Example 1:Input: &quot;DID&quot; Output: 5 Explanation: The 5 valid permutations of (0, 1, 2, 3) are: (1, 0, 3, 2) (2, 0, 3, 1) (2, 1, 3, 0) (3, 0, 2, 1) (3, 1, 2, 0) Note: 1 &lt;= S.length &lt;= 200 S consists only of characters from the set {‘D’, ‘I’}. 分析 题意：每次可以交换第index（小于等于K）个字母到最后一个，可以交换任意次，是的结果为最小字典顺序； 当K&gt;=2时，相当于时间复杂度为$O(n_2)$的排序算法，当然可能小于$O(n_2)$，最后结果一定是字典顺序；大致过程：每次移到最后相当于字符串循环，每次将待排序字符放在第一位，循环后面的字符串，直到待排序字符排好序，加入循环字符串，以此类推； 当K==1时，相当于首尾相连，找到最小字典顺序字串，简单做法：字符串复制两份，遍历一半，截取length长度的字串，找出最小字典顺序字串。 参考代码]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[902.Numbers At Most N Given Digit Set]]></title>
    <url>%2F2018%2F09%2F10%2F902-Numbers-At-Most-N-Given-Digit-Set%2F</url>
    <content type="text"><![CDATA[DescriptionWe have a sorted set of digits D, a non-empty subset of {‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}. (Note that ‘0’ is not included.) Now, we write numbers using these digits, using each digit as many times as we want. For example, if D = {‘1’,’3’,’5’}, we may write numbers such as ‘13’, ‘551’, ‘1351315’. Return the number of positive integers that can be written (using the digits of D) that are less than or equal to N. 题目链接：https://leetcode.com/problems/numbers-at-most-n-given-digit-set/description/ Difficulty: hard Example 1:Input: D = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], N = 100 Output: 20 Explanation: The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. Example 2:Input: D = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], N = 1000000000 Output: 29523 Explanation: We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits of D. Note: D is a subset of digits ‘1’-‘9’ in sorted order. 1 &lt;= N &lt;= 10^9 分析 分为两部分考虑，数字的长度小于N的长度和数字的长度等于N的长度； 第一种：可能的个数是D的长度的（数字的长度）次方，如例1，5+5*5； 第二种：如果最高位取一个小于N最高位的数字，那么，后面的位置可以取任意数字，若等于，后移移位继续3步骤，如大于，则结束； 第二种情况有一个特例，即D的长度为1的时候，如果N中每个数字都小于D[0]则，可能的数字是1，反之是0。 参考代码class Solution: def atMostNGivenDigitSet(self, D, N): s=0 length=len(D) n=10 l=length while(N&gt;=n): s+=l n*=10 l*=length li=[] while(N&gt;0): li=[N%10]+li N//=10 i=0 index=0 judge=True while(judge and i&lt;len(li)): l//=length for d in D: d=int(d) if(d&lt;li[i]): index+=l elif(d==li[i]): i+=1 if(i==len(li)): index+=1 break else: judge=False break else: judge=False if(length==1): index=1 for ind in li: if(ind&lt;int(D[0])): index=0 break elif(ind&gt;int(D[0])): index=1 break return s+index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[901.Online Stock Span]]></title>
    <url>%2F2018%2F09%2F10%2F901-Online-Stock-Span%2F</url>
    <content type="text"><![CDATA[DescriptionWrite a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock’s price for the current day. The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6]. 题目链接：https://leetcode.com/problems/online-stock-span/description/ Difficulty: medium Example 1:Input[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation: First, S = StockSpanner() is initialized. Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6. Note that (for example) S.next(75) returned 4, because the last 4 prices (including today&apos;s price of 75) were less than or equal to today&apos;s price. Note: Calls to StockSpanner.next(int price) will have 1 &lt;= price &lt;= 10^5. There will be at most 10000 calls to StockSpanner.next per test case. There will be at most 150000 calls to StockSpanner.next across all test cases. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages. 分析 由题意知是为了得到以当前价格为结尾的且每个数字都小于等于当前价格的最长序列的长度； 若直接用list存储价格，每次向前遍历得到长度，时间会超限（有note中知，测试数据很大）； 所以动态存储以每个价格结尾的元组（包括价格和对应的长度）； 如果当前价格小于list最后一个价格，则，改价格对应的长度为1； 如果当前价格大于等list中最后一个价格，则，当前价格的长度加上最后一个价格对应的长度，pop出list中最后一个元祖； 重复5，知道，list为空，或当前价格小于最后一个价格； 将当前价格及其长度，加入到list中。 参考代码class StockSpanner: def __init__(self): self.li=[] def next(self, price): s=1 while self.li and self.li[-1][0]&lt;=price: s+=self.li.pop()[1] self.li.append((price,s)) return s]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[900.RLE Iterator]]></title>
    <url>%2F2018%2F09%2F10%2F900-RLE-Iterator%2F</url>
    <content type="text"><![CDATA[DescriptionWrite an iterator that iterates through a run-length encoded sequence. The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence. More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence. The iterator supports one function: next(int n), which exhausts the next n elements (n &gt;= 1) and returns the last element exhausted in this way. If there is no element left to exhaust, next returns -1 instead. For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5]. This is because the sequence can be read as “three eights, zero nines, two fives”. 题目链接：https://leetcode.com/problems/rle-iterator/description/ Difficulty: medium Example 1:Input: [&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]] Output: [null,8,8,5,-1] Explanation: RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]). This maps to the sequence [8,8,8,5,5]. RLEIterator.next is then called 4 times: .next(2) exhausts 2 terms of the sequence, returning 8. The remaining sequence is now [8, 5, 5]. .next(1) exhausts 1 term of the sequence, returning 8. The remaining sequence is now [5, 5]. .next(1) exhausts 1 term of the sequence, returning 5. The remaining sequence is now [5]. .next(2) exhausts 2 terms, returning -1. This is because the first term exhausted was 5, but the second term did not exist. Since the last term exhausted does not exist, we return -1. Note: 0 &lt;= A.length &lt;= 1000 A.length is an even integer. 0 &lt;= A[i] &lt;= 10^9 There are at most 1000 calls to RLEIterator.next(int n) per test case. Each call to RLEIterator.next(int n) will have 1 &lt;= n &lt;= 10^9. 分析 已知A存储的是每个数字及其对应出现的次数，其中0 &lt;= A[i] &lt;= 10^9，所以若把A还原成字符串(如[8,8,8,5,5])，这样取next是很方便，但是可能内存或者时间超限； 故定义index指向当前数据对，初始为0，position是遍历到当前数据对的位置，初始为0； 如果index超出A的长度，则返回-1； 如果n大于当前数据对剩余长度（当前数据对长度减去position），则index后移，n减去剩余长度，position置零； 反之，返回当前index对应的数字，position加n。 参考代码class RLEIterator: def __init__(self, A): self.li=A self.index=0 self.position=0 def next(self, n): while(self.index&lt;len(self.li)): if(self.position + n&gt;self.li[self.index]): n-=(self.li[self.index]-self.position) self.position=0 self.index+=2 else: self.position+=n return self.li[self.index+1] return -1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder56]删除链表中重复的结点]]></title>
    <url>%2F2018%2F09%2F08%2Fnowcoder56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 题目链接： https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef 分析 参考代码-*- coding:utf-8 -*- class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def deleteDuplication(self, pHead): # write code here d=set() single=set() p=pHead while(p!=None): if(p.val not in d): d.add(p.val) single.add(p.val) else: if(p.val in single): single.remove(p.val) p=p.next p=pHead realHead=None real=None i=0 while(p): i+=1 if(p.val in single): if(realHead==None): realHead=p real=p else: real.next=p real=p p=p.next if(real!=None): real.next=None return realHead]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder55]链表中环的入口结点]]></title>
    <url>%2F2018%2F09%2F08%2Fnowcoder55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 题目链接： https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4 分析 参考代码 -*- coding:utf-8 -*- class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def EntryNodeOfLoop(self, pHead): # write code here if(not pHead or not pHead.next): return None p1=pHead p2=pHead while(p2!=None and p2.next!=None): p1=p1.next p2=p2.next.next if(p2==p1): p1=pHead while(p1!=p2): p1=p1.next p2=p2.next return p1 return None]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder54]字符流中第一个不重复的字符]]></title>
    <url>%2F2018%2F09%2F08%2Fnowcoder54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 题目链接： https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720 输出描述 如果当前字符流没有存在出现一次的字符，返回#字符。 分析 参考代码# -*- coding:utf-8 -*- class Solution: # 返回对应char def __init__(self): self.li=[] self.d=set() self.single=[] def FirstAppearingOnce(self): # write code here for index in self.li[-1]: if(index in self.d): if(index in self.single): self.single.remove(index) else: self.d.add(index) self.single.append(index) if(self.single): return self.single[0] else: return &apos;#&apos; def Insert(self, char): # write code here self.li.append(char)]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder53]表示数值的字符串]]></title>
    <url>%2F2018%2F09%2F08%2Fnowcoder53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 题目链接： https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2 分析 参考代码# -*- coding:utf-8 -*- class Solution: # s字符串 def isNumeric(self, s): # write code here if(len(s)==0): return False ii=0 li=[str(x) for x in range(10)] if(s[0] in [&apos;+&apos;,&apos;-&apos;]): ii=1 judge=0 for i in range(ii,len(s)): if(s[i]==&apos;.&apos;): if(not judge): judge=1 else: return False elif(s[i] in [&apos;e&apos;,&apos;E&apos;]): i+=1 if(i&lt;len(s)): if(s[i] in [&apos;+&apos;,&apos;-&apos;]+li): i+=1 while(i&lt;len(s)): if(s[i] not in li): return False i+=1 break break else: return False elif(s[i] not in li): return False return True]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder52]正则表达式匹配]]></title>
    <url>%2F2018%2F09%2F08%2Fnowcoder52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 题目链接： https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c 分析 参考代码# -*- coding:utf-8 -*- class Solution: # s, pattern都是字符串 def match(self, s, pattern): # write code here if(len(s)==0 and len(pattern)==0): return True if(len(s)!=0 and len(pattern)==0): return False if(len(pattern)&gt;=2 and pattern[1]==&apos;*&apos;): judge=False if(len(s)&gt;0 and (s[0]==pattern[0] or pattern[0]==&apos;.&apos;)): judge=self.match(s[1:],pattern) return judge or self.match(s,pattern[2:]) else:#pattern第二个字符不是‘*’ if(len(s)&gt;0 and (s[0]==pattern[0] or pattern[0]==&apos;.&apos;)):#当前字符匹配 return self.match(s[1:],pattern[1:]) else: return False]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[899.Orderly Queue]]></title>
    <url>%2F2018%2F09%2F02%2F899-Orderly-Queue%2F</url>
    <content type="text"><![CDATA[DescriptionA string S of lowercase letters is given. Then, we may make any number of moves. In each move, we choose one of the first K letters (starting from the left), remove it, and place it at the end of the string. Return the lexicographically smallest string we could have after any number of moves. 题目链接：https://leetcode.com/problems/orderly-queue/description/ Difficulty: hard Example 1:Input: S = &quot;cba&quot;, K = 1 Output: &quot;acb&quot; Explanation: In the first move, we move the 1st character (&quot;c&quot;) to the end, obtaining the string &quot;bac&quot;. In the second move, we move the 1st character (&quot;b&quot;) to the end, obtaining the final result &quot;acb&quot;. Example 2:Input: S = &quot;baaca&quot;, K = 3 Output: &quot;aaabc&quot; Explanation: In the first move, we move the 1st character (&quot;b&quot;) to the end, obtaining the string &quot;aacab&quot;. In the second move, we move the 3rd character (&quot;c&quot;) to the end, obtaining the final result &quot;aaabc&quot;. Note: 1 &lt;= K &lt;= S.length &lt;= 1000 S consists of lowercase letters only. 分析 题意：每次可以交换第index（小于等于K）个字母到最后一个，可以交换任意次，是的结果为最小字典顺序； 当K&gt;=2时，相当于时间复杂度为$O(n_2)$的排序算法，当然可能小于$O(n_2)$，最后结果一定是字典顺序；大致过程：每次移到最后相当于字符串循环，每次将待排序字符放在第一位，循环后面的字符串，直到待排序字符排好序，加入循环字符串，以此类推； 当K==1时，相当于首尾相连，找到最小字典顺序字串，简单做法：字符串复制两份，遍历一半，截取length长度的字串，找出最小字典顺序字串。 参考代码class Solution: def orderlyQueue(self, S, K): if(K&gt;1): return &apos;&apos;.join(sorted(S)) s=S+S target=S for i in range(1,len(S)+1): if(s[i:i+len(S)]&lt;target): target=s[i:i+len(S)] return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[898.Bitwise ORs of Subarrays]]></title>
    <url>%2F2018%2F09%2F02%2F898-Bitwise-ORs-of-Subarrays%2F</url>
    <content type="text"><![CDATA[DescriptionWe have an array A of non-negative integers. For every (contiguous) subarray B = [A[i], A[i+1], …, A[j]] (with i &lt;= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | … | A[j]. Return the number of possible results. (Results that occur more than once are only counted once in the final answer.) 题目链接：https://leetcode.com/problems/bitwise-ors-of-subarrays/description/ Difficulty: medium Example 1:Input: [0] Output: 1 Explanation: There is only one possible result: 0. Example 2:Input: [1,1,2] Output: 3 Explanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2]. These yield the results 1, 1, 2, 1, 3, 3. There are 3 unique values, so the answer is 3. Example 3:Input: [1,2,4] Output: 6 Explanation: The possible results are 1, 2, 3, 4, 6, and 7. Note: 1 &lt;= A.length &lt;= 50000 0 &lt;= A[i] &lt;= 10^9 分析 动态规划：遍历数组，记录以每一个数为结尾的子数组的结果，存在set中； 将当前数与前一个数的结果的取或和本身，存储aSet（set）中； aSet的长度即使所有结果的可能数。 参考代码class Solution: def subarrayBitwiseORs(self, A): index =A[0] aSet=set() judge=set() judge.add(index) aSet.add(index) for i in range(1,len(A)): _judge=set() for j in judge: aSet.add(A[i]) _judge.add(A[i]) aSet.add(j | A[i]) _judge.add(j | A[i]) judge=_judge return len(aSet) 83 / 83 test cases passed. Runtime: 1712 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[897.Increasing Order Search Tree]]></title>
    <url>%2F2018%2F09%2F02%2F897-Increasing-Order-Search-Tree%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child. 题目链接：https://leetcode.com/problems/increasing-order-search-tree/description/ Difficulty: easy Example 1:Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9 Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8 \ 9 Note: The number of nodes in the given tree will be between 1 and 100. Each node will have a unique integer value from 0 to 1000. 分析 题意：将二叉搜索树变为只有右结点的二叉搜索树； 遍历得到原二叉搜索树的中序遍历序列； 根据中序遍历序列，遍历构建只有右结点的二叉搜索树，返回根结点； 做到第二题的时候精神有点恍惚，感觉自己的代码不够pythonic。 参考代码Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def increasingBST(self, root): def _inter(ro): if(ro==None): return None left=[] if(ro.left!=None): left=_inter(ro.left) right=[] if(ro.right!=None): right=_inter(ro.right) return left + [ro.val] + right li=_inter(root) if(len(li) ==0 ): return None head=TreeNode(li[0]) p=head for i in range(1,len(li)): q=TreeNode(li[i]) p.right=q p=q return head 2156 / 2156 test cases passed. Runtime: 160 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Depth-first Search</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[896.Monotonic Array]]></title>
    <url>%2F2018%2F09%2F02%2F896-Monotonic-Array%2F</url>
    <content type="text"><![CDATA[DescriptionAn array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j]. An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j]. Return true if and only if the given array A is monotonic. 题目链接：https://leetcode.com/problems/monotonic-array/description/ Difficulty: easy Example 1:Input: [1,2,2,3] Output: true Example 2:Input: [6,5,4,4] Output: true Example 3:Input: [1,3,2] Output: false Example 4:Input: [1,2,4,5] Output: true Example 5:Input: [1,1,1] Output: true Note: 1 &lt;= A.length &lt;= 50000 100000 &lt;= A[i] &lt;= 100000 分析 判断数组是否是递增或者递减的，定义判断量judge，judge=0初始化，judge=1递增，judge=-1递减，遍历数组； 如果judge=0：当前数大于前一个数，judge=1，如果当前数小于前一个数，judge=-1； 如果judge=1：如果当前数小于前一个数，返回False； 如果judge=-1：如果当前数大于前一个数，返回False； 遍历结束，返回True。 参考代码class Solution: def isMonotonic(self, A): index = A[0] judge=0 for i in range(1,len(A)): if(judge==0): if(A[i]&gt;index): judge=1 if(A[i]&lt;index): judge=-1 index=A[i] elif(judge==1): if(A[i]&lt;index): return False index=A[i] else: if(A[i]&gt;index): return False index=A[i] return True 366 / 366 test cases passed. Runtime: 160 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder51]构建乘积数组]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 题目链接： https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46 分析 如下表格所示，第i行即需要返回B[i]； 故做两次循环，计算上下半角，得到最后的结果。 1 A[1] A[2] A[3] A[0] 1 A[2] A[3] A[0] A[1] 1 A[3] A[0] A[1] A[2] 1 参考代码# -*- coding:utf-8 -*- class Solution: def multiply(self, A): # write code here length=len(A) B=[1]*length for i in range(1,length): B[i]=B[i-1]*A[i-1] temp=1 for i in range(length-2,-1,-1): temp*=A[i+1] B[i]*=temp return B 运行时间： 24 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder50]数组中重复的数字]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 题目链接： https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8 分析 遍历numbers，若当前数字存在d（元组）中，则说明之前出现过这个数字，duplication[0]=number，返回True； 反之，将number加入到中； 返回False。 参考代码# -*- coding:utf-8 -*- class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here d=set() for number in numbers: if(number in d): duplication[0] = number return True else: d.add(number) return False 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder49]把字符串转换成整数]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder49-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 题目链接： https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e 输入描述 输入一个字符串,包括数字字母符号,可以为空 输出描述 如果是合法的数值表达则返回该数字，否则返回0 示例1输入 +2147483647 1a33 输出 2147483647 0 分析 judge用于存储数字的正负； digit存储0-9的数字； 遍历s（若s[0]为“+”或者“-”，则从第二个位置开始遍历），若出现不是数字的字符，返回零，反之存入index； 返回index的整数表示形式； 备注：磁体没有考虑“e”，如1e2=0.01。 参考代码# -*- coding:utf-8 -*- class Solution: def StrToInt(self, s): # write code here judge=1 index=&apos;&apos; ii=0 s=s.lstrip() if(len(s)==0): return 0 digit=[str(i) for i in range(10)] if(s[0]==&apos;+&apos;): judge=1 ii=1 elif(s[0]==&apos;-&apos;): judge=-1 ii=1 for i in range(ii,len(s)): if(s[i] in digit): index+=s[i] else: return 0 if(index==&apos;&apos;): return 0 return judge*int(index) 运行时间： 26 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder48]不用加减乘除做加法]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 题目链接： https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215 分析 额额额额，就这样吧。 参考代码# -*- coding:utf-8 -*- class Solution: def Add(self, num1, num2): # write code here s=[num1,num2] return sum(s) 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder47]求1+2+3+...+n]]></title>
    <url>%2F2018%2F09%2F01%2Fnowcoder47-%E6%B1%821-2-3-n%2F</url>
    <content type="text"><![CDATA[题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 题目链接： https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1 分析 小学问题，额额额额。 参考代码# -*- coding:utf-8 -*- class Solution: def Sum_Solution(self, n): # write code here return n*(1+n)/2 运行时间： 24 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[895.Maximum Frequency Stack]]></title>
    <url>%2F2018%2F08%2F27%2F895-Maximum-Frequency-Stack%2F</url>
    <content type="text"><![CDATA[DescriptionImplement FreqStack, a class which simulates the operation of a stack-like data structure. FreqStack has two functions: push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack.If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned. 题目链接：https://leetcode.com/problems/maximum-frequency-stack/description/ Difficulty: hard Example 1:Input: [&quot;FreqStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;],[[],[5],[7],[5],[7],[4],[5],[],[],[],[]] Output: [null,null,null,null,null,null,null,5,7,5,4] Explanation:After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top. Then: pop() -&gt; returns 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4]. pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4]. pop() -&gt; returns 5. The stack becomes [5,7,4]. pop() -&gt; returns 4. The stack becomes [5,7]. Note: Calls to FreqStack.push(int x) will be such that 0 &lt;= x &lt;= 10^9. It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements. The total number of FreqStack.push calls will not exceed 10000 in a single test case. The total number of FreqStack.pop calls will not exceed 10000 in a single test case. The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases. 分析 因为每次pop都是返回一个出现频率最大的数字，首先想到的是每次push保存下频率最大的数字，但是pop之后可能就会变化，这是如果去遍历所有push的数字时间会超限； 考虑把所有出现相同次数的数字放在同一个list中，然后把所有的list放入字典中，形如{1: [7, 5, 4], 2: [7, 5]}，代表至少出现一次的是：7，4，5，至少出现两次的是：7，5，题目要求需要在频率相同的情况下pop出最后push进去的，在构建的时候按照push顺序加入到字典中； 在构建一个字典存储每个数字出现的次数，形如：{7: 2, 5: 2, 4: 1} 代码如下 参考代码class FreqStack: def __init__(self): self.count = {} self.group = {} self.max = 0 def push(self, x): if(x in self.count): self.count[x]+=1 else: self.count[x]=1 f=self.count[x] if(f in self.group): self.group[f].append(x) else: self.group[f]=[x] if(f&gt;self.max): self.max=f def pop(self): x=self.group[self.max].pop() self.count[x]-=1 if(not self.group[self.max]): self.max-=1 return x]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
        <tag>Hash table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[894.All Possible Full Binary Trees]]></title>
    <url>%2F2018%2F08%2F27%2F894-All-Possible-Full-Binary-Trees%2F</url>
    <content type="text"><![CDATA[DescriptionA full binary tree is a binary tree where each node has exactly 0 or 2 children. Return a list of all possible full binary trees with N nodes. Each element of the answer is the root node of one possible tree. Each node of each tree in the answer must have node.val = 0. You may return the final list of trees in any order. 题目链接：https://leetcode.com/problems/all-possible-full-binary-trees/description/ Difficulty: medium Example 1:Input: 7 Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] Explanation: Note: 1 &lt;= N &lt;= 20 分析 对任意一个节点只有两个子节点或者0个，那么每个节点的左右子树的节点个数只能为奇数； 依据1，对于每个节点，其左右子树是剩余分成的两份（两份奇数个节点）； 2便是递归的步骤，以此递推。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def allPossibleFBT(self, N): if(N==0): return [None] if(N==1): return [TreeNode(0)] left=[] right=[] root=[] for i in range(1,N-1,2): print(i,N-1-i) left=self.allPossibleFBT(i) right=self.allPossibleFBT(N-1-i) for l in left: for r in right: ro=TreeNode(0) ro.left=l ro.right=r root.append(ro) return root 20 / 20 test cases passed. Runtime: 284 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[893.Groups of Special-Equivalent Strings]]></title>
    <url>%2F2018%2F08%2F27%2F893-Groups-of-Special-Equivalent-Strings%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given an array A of strings. Two strings S and T are special-equivalent if after any number of moves, S == T. A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j]. Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S. Return the number of groups of special-equivalent strings from A. 题目链接：https://leetcode.com/problems/groups-of-special-equivalent-strings/description/ Difficulty: easy Example 1:Input: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;] Output: 3 Explanation: 3 groups [&quot;a&quot;,&quot;a&quot;], [&quot;b&quot;], [&quot;c&quot;,&quot;c&quot;,&quot;c&quot;] Example 2:Input: [&quot;aa&quot;,&quot;bb&quot;,&quot;ab&quot;,&quot;ba&quot;] Output: 4 Explanation: 4 groups [&quot;aa&quot;], [&quot;bb&quot;], [&quot;ab&quot;], [&quot;ba&quot;] Example 3:Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;] Output: 3 Explanation: 3 groups [&quot;abc&quot;,&quot;cba&quot;], [&quot;acb&quot;,&quot;bca&quot;], [&quot;bac&quot;,&quot;cab&quot;] Example 4:Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] Output: 1 Explanation: 1 group [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;] Note 1 &lt;= A.length &lt;= 1000 1 &lt;= A[i].length &lt;= 20 All A[i] have the same length. All A[i] consist of only lowercase letters. 分析 两个字符串special-equivalent，代表着一个字符串的奇数位置的字符经过任意次换位置和偶数位置的字符经过任意次换位置，两个字符串相等 经过任意次变换相等，也就是在奇数和偶数位置上的字符总和一直，那么一定可以经过任意次互换位置便可以字符串相等。 考虑包含奇数和偶数位置上的字符的特殊编码，即相应字符的个数（a-z,A-Z）,编码个数即groups数 参考代码def count(A): ans = [0] * 52 for i, letter in enumerate(A): ans[ord(letter) - ord(&apos;a&apos;) + 26 * (i%2)] += 1 return tuple(ans) return len({count(word) for word in A}) 34 / 34 test cases passed. Runtime: 52 ms 错误分析刚开始做这道题的时候，也是类似于编码，但是返回的是两个set def judge(s1): a1=set() a2=set() for i in range(len(s1)): if(i%2==0): a1.add(s1[i]) else: a2.add(s1[i]) return [a1,a2] 但是没有像Solution中的那样返回一个元祖，可以在后面把结果放在dict中，导致的结果就是时间超限。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[892.Surface Area of 3D Shapes]]></title>
    <url>%2F2018%2F08%2F27%2F892-Surface-Area-of-3D-Shapes%2F</url>
    <content type="text"><![CDATA[DescriptionOn a N N grid, we place some 1 1 * 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Return the total surface area of the resulting shapes. 题目链接：https://leetcode.com/problems/surface-area-of-3d-shapes/description/ Difficulty: easy Example 1:Input: [[2]] Output: 10 Example 2:Input: [[1,2],[3,4]] Output: 34 Example 3:Input: [[1,0],[0,2]] Output: 16 Example 4:Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 32 Example 5:Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 46 Note 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 分析 对于每一个立方体，由六个面，在整个立方体集合中贡献最大表面积为6； 如果上面有立方体则减一，如果下面有立方体则减一，以此类推（包含上下左右前后六个面）； 因为N和grid[i][j]都不是很大，所以便利所以立方体便可以得到表面积 参考代码def surfaceArea(self, grid): row=len(grid) s=0 for i in range(row): for j in range(len(grid[i])): for index in range(grid[i][j]): current=6 if(i-1&gt;=0): if(grid[i-1][j]&gt;=index+1): current-=1 if(i+1&lt;row): if(grid[i+1][j]&gt;=index+1): current-=1 if(j-1&gt;=0): if(grid[i][j-1]&gt;=index+1): current-=1 if(j+1&lt;len(grid[i])): if(grid[i][j+1]&gt;=index+1): current-=1 if(index&gt;0): current-=1 if(index &lt; grid[i][j]-1): current-=1 s+=current return s 90 / 90 test cases passed. Runtime: 496 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lda2vev:Mixing Dirichlet Topic Models and Word Embeddings to Make lda2vec]]></title>
    <url>%2F2018%2F08%2F27%2Flda2vev-Mixing-Dirichlet-Topic-Models-and-Word-Embeddings-to-Make-lda2vec%2F</url>
    <content type="text"><![CDATA[结合主题信息和词潜入，生成包含主题信息的向量化表示lda2vec. 论文地址:https://arxiv.org/abs/1605.02019 ABSTRACT 已经证明分布式密集词向量在捕捉语言中的标记级语义和句法规则方面是有效的，而主题模型可以在文档上形成可解释的表示。在这项工作中，我们描述了lda2vec，它是一个与Dirichlet分布的主题向量的潜在文档级别混合学习密集词向量的模型。与连续密集的文档表示形式相反，该表达式通过非负单纯形约束产生稀疏的，可解释的文档混合。我们的方法很容易整合到现有的自动分化框架中，并允许无人监督的文档表示适合科学家使用，同时学习单词向量及它们之间的线性关系。 Introduction主题模型因其能够将文档集合组织为一组较小的突出主题而受到欢迎。 与密集的分布式表示形式相反，这些文档和主题表示通常可以被人类访问，并且更容易被解释。 这种解释性提供了额外的选项来突出我们的文档系统中的模式和结构。 例如，使用潜在狄利克雷分配（LDA）主题模型可以揭示文档中的词汇集合（Blei et al。，2003），强调时间趋势（Charlin et al。，2015），并推断补充产品的网络（McAuley et al。 。，2015）。 见Blei等人。 （2010年），概述计算机视觉，遗传标记，调查数据和社交网络数据等领域的主题建模。 图1：lda2vec通过将word2vec的skip gram体系结构与Dirichlet优化的稀疏主题混合体相结合，在单词和文档上构建表示。 文中描述了图中出现的各种组件和转换。 对于构建文档表示的密集向量方法也存在：Le和Mikolov（2014）提出了可以预测段落中词袋的段落向量，Kiros et al（2015）构建了在给定句子之前和之后重构句子序列的向量，并且Ghosh等人 （2016）构建了预测后续句子特征的语境LSTMs。 概率主题模型倾向于将文档形成为主题的稀疏混合成员，而神经网络模型倾向于将文档建模为密集向量。 由于其稀疏性和低维性，来自前者的陈述更容易检查，并且更直接地产生关于基础系统的高层次直觉（尽管不是没有危害，参见Chang等人（2009））。 本文探讨混合稀疏文档表示密集词和主题向量的混合方法。 不幸的是，制定一个新的概率主题模型需要得到一个新的近似值，这个过程需要大量的专业知识，并且必须根据每个模型进行定制。 因此，原型开发非常耗时，必须仔细考虑对模型体系结构的更改。 但是，使用现代自动分化框架，从业者可以将开发时间集中在模型设计上，而不是模型近似值。 这加快了评估哪些模型特征相关的过程。 这项工作利用Chainer（Tokui等，2015）框架来快速开发模型，同时使我们能够利用GPU来显着提高计算速度。 最后，文本上的传统主题模型没有利用分布式词语表示方面的最新进展，它可以捕捉令牌之间语义上有意义的规则。对词语共现的考察已被证明是一个富有成效的研究范式。例如，Mikolov等人（2013）利用Skipgram负抽样（Skipgram NegativeSampling，SGNS）利用跨越文本语料库的窗口形成的单词上下文对来训练单词嵌入。这些向量表示最终编码显着的线性，如king-man+woman=queen。事实上，Levy和Goldberg（2014c）证明，这隐含地分解了点阵互信息（PMI）矩阵的变体，该矩阵强调预测罕见群体的频繁共现。与PMI矩阵密切相关，Pennington 等人（2014）将大型全球字数共生矩阵分解以产生比SGNS更高效且性能稍高的计算嵌入。一旦创建，这些表示就可用于信息检索（Manning等，2009）和解析任务（Levy和Goldberg，2014a）。在这项工作中，我们将利用word级表示来建立文档级抽象。 本文通过包含可解释文档表示来扩展分布式词语表示，并证明模型推理可以在自动分化框架内执行和扩展。 Model本节介绍lda2vec的模型。 我们有兴趣修改（Mikolov et al。，2013）中的Skipgram负采样（SGNS）目标，以利用文档范围的特征向量，同时学习连续的文档权重加载到主题向量。 网络架构如图1所示。在（1）中的总损失项$\iota$是Skiggram负采样损失（SGNs）$\iota_{ij}^{neg}$的总和，并且在文档权重上增加了Dirichlet似然项，$\iota^d$将在后面讨论。使用上下文向量($\overrightarrow{c_j}$)、支点字向量($\overrightarrow{w_j}$)、目标词向量($\overrightarrow{w_i}$)和负采样词向量($\overrightarrow{w_l}$)进行损失。 $$ \iota =\iota^d +\sum_{ij}\iota_{ij}^{neg} \tag{1}$$ $$\iota_{ij}^{neg} = \log_\sigma(\overrightarrow{c_j}\cdot\overrightarrow{w_l})+\sum_{l=0}^n\log_\sigma(-\overrightarrow{c_j}\cdot\overrightarrow{w_l}) \tag{2}$$ Word Representation如在Mikolov等人（2013），当它们在移动的窗口中共同出现在整个语料库中时，提取枢轴词和目标词对（j，i）。在我们的实验中，窗口在枢轴标记之前和之后包含5个标记。对于每个枢轴目标字对，枢轴字用于预测附近的目标字。每个单词用固定长度的密集分布表示向量表示，但与Mikolov等人（2013年）不同，相同的单词向量用于枢轴和目标表示。2）中所示的SGNS损失试图区分出出现在语料库中的上下文词对，从而随机抽取 “negative”词汇池。当观察到的词与边缘分布完全分离时，该损失最小化。从中得出令牌的分布是$u^β$，其中u表示由总语料库大小归一化的整体词频。除非另有说明，否则，如Mikolov等人(2013)所述，负采样功率β设为3/4，负样本数固定为n = 15。请注意，$u^0.0$的分布会从词汇中绘制负标记而没有受欢迎的概念，而与$u^1.0$成比例的分布则取自经验单字分布。与单字分布相比，$u^{3/4}$的选择稍微强调为负样本选择不常用单词。与优化softmax交叉熵（其需要对每个令牌的总体流行度进行建模）相反，负面抽样侧重于通过从语料库中的每个令牌的边际流行度中抽取负样本来有条件地学习词向量。 Document Representationslda2vec将单词和文档向量嵌入同一个空间并同时训练两个表示。通过将枢轴和文档向量相加，两个空间都可以有效地结合在一起。 Mikolov等人（2013）提供了直觉，词向量可以汇总在一起形成两个词的语义上有意义的组合。例如，Germany+airline的载体表示与Lufthansa的载体相似。我们想利用单词向量的加性来构造一个有意义的单词和文档向量。例如，如果lda2vec正在扫描文档，第j个单词是德国，则预测相邻单词如法国，西班牙和奥地利相似。但是，如果文档特别是关于航空公司，那么我们希望构建一个类似于航空公司的单词向量的文档向量。然后，不是单独预测类似于德国的令牌，而是可以对文档和主要词汇进行类似的预测，例如：Lufthansa，Condor Flugdienst和Aero Lloyd。由有意义的词向量的总和驱动，在LDA2VEC中，上下文向量被明确地设计为文档向量和词向量的总和，如（3）： $$\overrightarrow{c_j}=\overrightarrow{w_j}+\overrightarrow{d_j} \tag{3}$$ 这通过保留文档中所有单词上下文对的($\overrightarrow{d_j}$)来模拟文档范围的关系，同时仍然利用由枢轴词向量($\overrightarrow{w_j}$)和目标词($\overrightarrow{w_i}$)之间的相互作用产生的局部词间关系。文档和单词向量被汇总在一起形成一个上下文向量，分别直观地捕捉长期和短期主题。为了防止共同适应，我们也对非规范化文档向量($\overrightarrow{d_j}$)和枢轴词向量($\overrightarrow{w_j}$)进行dropout（Hinton et al。，2012）。 Document Mixtures如果我们只包含到目前为止的结构，模型将为每个文档生成一个密集的向量。 然而，lda2vec致力于形成可解释的表示，并且这样做会施加额外的约束，使得文档表示与传统的LDA模型中的相似。我们的目标是从混合主题向量生成一个文档向量，为此，我们首先约束文档向量($d_j$),投影到一组潜在的主题向量($\overrightarrow{t_0}$),($\overrightarrow{t_1}),⋯,($\overrightarrow{t_k}$): $$\overrightarrow{d_j}=p_{j0}\cdot\overrightarrow{t_0}+p_{j2}\cdot\overrightarrow{t_2}+\cdots+p_{jk}\cdot\overrightarrow{t_k}+\cdots+p_{jn}\cdot\overrightarrow{t_n} \tag{4}$$ 每个权重0≤$p_{jk}$≤1是表示主题k中文档j的隶属度的分数。 例如，稍后描述的Twenty Newsgroups 模型具有11313个文档并且k = 20个主题，所以j = 0 … 11312，k = 0 … 19。 当单词向量维数设置为300时，假设文档向量($\overrightarrow{d_j}$)，单词向量($\overrightarrow{w_i}$)和主题向量($\overrightarrow{t_k}$)都具有维度300.注意，主题向量($\overrightarrow{t_k}$)是共享的 并且是所有文档的共同组成部分，但其强度由文档权重p_jk调整。为了有助于可解释性，文档成员资格被设计为非负面的，并且归结为统一。 为了实现这个约束，softmax变换将在R^300中初始化的潜在向量映射到由$p_{jk}$定义的单纯形中。softmax变换自然会强制约束$\sum_k p_{jk} = 1$，并允许我们将成員資格解釋为百分比而非无限权重。 将（4）中的混合作为总和来保证主题向量($\overrightarrow{t_k}$)，文档向量($\overrightarrow{d_j}$)和词向量($\overrightarrow{w_i}$)在相同的空间中操作。因此，可以直接计算哪些字($\overrightarrow{w_i}$)最类似于任何给定的主题向量($\overrightarrow{t_k}$)。尽管每个主题不是字面上語料庫中存在的标记，但与其他标记的相似性是有意义的并且可以被测量。此外，通过检查最相似的单词列表，可以尝试解释该主题所代表的内容。例如，通过计算与任何主题向量（例如argma$x_i(\overrightarrow{t_0}\cdot\overrightarrow{w_i})$最相似的标记，人们可以发现第一个主题向量($\overrightarrow{t_0}$)与标记pitching，catcher和Braves相似，而第二个主题向量($\overrightarrow{t_1}$)可能与Jesus，God和faith相似。这为我们提供了将第一个主题解释为baseball主题的选项，因此每个文档比例$p_{j0}$中的第一个分量指示文档j在棒球主题中的数量。同样，第二个主题可能被解释为基督教，任何文档比例的第二个组成部分$p_{j1}$表示该文件在基督教主题中的成员身份。 Sparse Memberships最后，通过对具有低浓度参数α的Dirichlet似然优化文档权重，使文档权重$p_{ij}$被稀疏化： $$\iota^d=\lambda\sum_{jk}(\alpha-1)\log p_{jk} \tag{5}$$ 5）中的总体目标衡量文档j在主题k中概括所有可用文档的可能性。该项的强度由调整参数λ调整。当α＜1时，每一个主题中的文档比例耦合都是稀疏的，当α＞1时，这种简单的可能性会促使文档的比例耦合。为了提高可解释性，我们有兴趣寻找稀疏成员，并设置α=n^(-1)，其中n是主题。我们还发现将Dirichlet优化的整体强度设置为λ= 200的效果很好。文档比例被初始化为相对均匀，但随着时间的推移，$\iota^d$鼓励文档比例向量随着时间的推移变得更加集中（例如稀疏）。在没有这个稀疏诱导项的实验中（或者当α= 1时），文档权重$p_{ij}$倾向于在所有元素之间展开概率质量。如果没有任何稀疏性引入术语，那么许多非零权重的存在使解释文档向量变得困难。此外，我们发现话题基础也受到强烈影响，话题变得不連貫。 # of topics β Topic Coherences 20 0.75 0.567 30 0.75 0.555 40 0.75 0.553 50 0.75 0.547 20 1.00 0.563 30 1.00 0.564 40 1.00 0.552 50 1.00 0.558 图2：给出了在Twenty Newsgroups数据集中由lda2vec发现的平均主题一致性。 主题一致性已被证明与主题模型的人类评估相关（Roder等，2015）。 给出了所选主题的数量，以及负抽样指数参数β。 与β= 1.00相比，β= 0.75将更多的稀有词作为负样本。 在模型n = 20个主题和β= 0.75中找到最好的主题相关性。 Preprocessing and Training1）中的目标是一次在单独的小批量中进行训练，同时使用Adam优化器（Kingma和Ba，2014）在整个数据集中处理两百个时期。Dirichlet似然项$\iota^d$通常是在所有文档上计算的，因此在将目标修改为小批量时，我们调整术语的损失与小批量大小除以总语料库的大小成比例。我们的软件是开源的，可在线获得，记录和单元测试。最后，将给定主题中前十个最有可能的单词提交给在线Palmetto主题质量测量工具，并记录相干性测量$C_v$。在评估多个替代方案后，$C_v$是Roder等人（2015）推荐的一致性度量。此度量对外部语料库上大小为110的滑动窗口内的每对单词的归一化点互信息（NPMI）进行平均，并返回提交的单词集的NPMI平均值。使用3COSMUL度量来评估令牌到词的相似度（Levy和Goldberg，2014b）。 Topic Label “Space” “Encryption” “X Windows” “Middle East” Top tokens Astronomical Astronomy Satellite Planetary telescope Encryption Wiretap Encrypt Escrow Clipper Mydisplay Xlib,Window Cursor pixmap Armenian Lebanese Muslim Turk sy Topic Coherence 0.712 0.675 0.472 0.615 图3：由Twenty Newsgroups数据集中的lda2vec发现的主题。 推断的主题标签显示在第一行。 与该主题相似度最高的令牌将在下面显示。请注意,Twenty Newsgroups语料库包含相应的新闻组，如sci.space，sci.crypt，comp.windows.x和talk.politics.mideast。 ExperimentsTwenty Newsgroups本节详细介绍了发现二十新闻组数据集中显着主题的实验，这是一种流行的文本机器学习语料库。语料库中的每个文档都发布到二十个可能的新闻组中的一个。尽管每篇文章的文本都可用于lda2vec, 但每个新闻组分区并未显示给算法，但对于发现的主题的事后定性评估仍然有用。使用Scikit-learn（Pedregosaetal，2012）中提供的数据加载器预处理语料库，使用SpaCy解析器（Honnibal and Johnson，2015）识别令牌。单词被词组化以将多个入口组合为单个令牌。在语料库中发生少于十次的令牌被删除，标记看起来像是URL，数字或在其正文形式中包含特殊符号。预处理之后，数据集包含11,313个文档中的8946个独特标记的180万个观察值。字向量被初始化为Mikolov等人（2013）的预训练值，但在训练时允许更新这些向量。 通过改变主题数量n∈20,30,40,50和负取样指数β∈0.75,1.0来评估一系列lda2vec参数。 图2总结了n = 20个话题和负抽样功率β= 0.75的最佳话题相关性。我们简要地试验了dropout率的变化，但我们没有观察到任何实质性差异。 图3列出了在Twenty Newsgroups数据集中发现的四个示例主题。每个主题与与训练的单词向量相同的空间中存在的主题向量相关联，并且列出的是与每个主题向量最相似的词。所显示的第一个主题与令牌astronomical, Astronomy, satellite, planetary, and telescope有很高的相似性，因此可能是与’sci.space’新闻组类似的’Space’相关主题。第二个示例主题类似于语义上与’Encryption’相关的单词，例如Clipper和encrypt，并且可能与’sci.crypt’新闻组相关。第三和四个示例主题是“X Windows”和“Middle East”，可能属于“comp.windows.x”和“talk.politics.mideast”新闻组。 Hacker News Comments corpus这部分评估lda2vec在一个非常大的黑客新闻评论语料库上。黑客新闻是社交内容投票网站和社区，主要关注技术和创业。在这个语料库中，单个文档由发布到单个文章的所有评论中的所有单词组成。只包含超过10条评论的报道，并且仅包含评论超过10条的用户的评论。我们忽略其他元数据，如投票，时间戳和作者身份。原始数据集4可在线下载。语料库几乎是二十新闻组语料库的大小，足以学习专业词汇。为了利用这个丰富的语料库，我们使用SpaCy来一次标记整个名词短语和实体（Honnibal and Johnson，2015）。特定的标记过程也可以在线获得，预处理的数据集结果也是如此。这使我们能够捕捉诸如community policing measure等短语以及像Steve Jobs这样的突出数据作为单一的令牌。然而，这种标记化过程会生成一个与Palmetto主题一致性工具中可用的词汇完全不同的词汇，因此我们不会在此语料库上报告主题一致性。经过预处理，该语料库包含75万个令牌，在66万个文档中有11万个独特的令牌。与Twenty Newsgroups分析不同，词向量是随机初始化的，而不是使用预训练向量库。 “Housing Issues” “Internet Portals” “Bitcoin” “Compensation” “Gadget Hardware” more housing basic income new housing house prices short-term rentals DDG. Bing Google+ DDG iGoogle Btc Bitcoins Mt. Gox MtGox Gox current salary more equity vesting equity vesting schedule the Surface Pro HDMI glossy screens Mac Pro Thunderbolt 图4：Hacker News评论数据集中由lda2vec发现的主题。 推断的主题标签显示在第一行。 我们从名词短语中形成令牌，以捕捉这个专用语料库的独特词汇。 Artiﬁcial sweeteners Black holes Comic Sans Functional Programming San Francisco Glucose Fructose sugars sugar Soylent Paleo diet diet carbohydrates Particles Consciousness quantum mechanics universe dark matter Big Bang Planets entanglement Typeface Arial Times New Roman Font new logo Anonymous Pro Baskerville serif font FP Haskell functional languages monads Lisp Clojure category theory OO New York Palo Alto New York City SF Mountain View Seattle Los Angeles Boston 图5：给出顶行中的示例标记，报告Hacker News评论语料库中最相似的单词。 我们使用40个主题和256个隐藏单元来训练lda2vec模型，并报告学习的主题，以演示语料库中存在的主题。 此外，我们证明了向这个语料库指定的词向量和语义关系是学习到的。 在图4中列出了Hacker News语料库中lda2vec发现的示例主题。这些主题表明，语料库的主要主题以与LDA类似的方式在学习的主题向量中得以再现和表示（Blei et al。，2003）。第一个是我们对Housing Issues(房屋问题)的标签，其中涉及到住房政策问题，如住房供应（例如more housing）和成本（如basic income 和 house prices）。另一个主题列出了主要的internet portals（互联网门户），例如隐私意识搜索引擎“Duck Duck Go”（在语料库中缩写为DDG），以及其他主要搜索引擎（例如Bing）和主页（例如Google+和iGoogle）。第三个话题是流行的在线货币和支付系统Bitcoin（比特币），货币btc的缩写形式以及现已解散的比特币交易平台Mt. GOX。第四个主题是考虑薪酬和compensation，包括current salary(当前的薪水)，more equity(更多的股权)和vesting(归属)，以及雇员从其雇主那里获得股票的过程。第五个示例主题是HDMI和glossy screens等技术硬件(hardware)，并且包含诸如Surface Pro和Mac Pro等设备。 图5表明，标记的相似性以与SGNS类似的方式学习（Mikolov et al。，2013），但专门用于Hacker News语料库。与令牌人Artiﬁcial sweeteners类似的令牌包括其他与sugar有关的令牌，如fructose和与食物相关的令牌，如古饮食。与Black holes相似的标记包括物理相关的概念，如星系和暗物质。黑客新闻语料库将大量文本用于字体和设计，最类似于comic Sans的单词是其他流行字体（例如Times New Roman和Helvetica）以及与字体相关的概念，如Typeface和serif font。与Functional Programming类似的令牌与其他计算机科学相关的令牌相似，而类似于San Francisco的令牌包括其他大型美国城市以及位于旧金山(San Francisco)湾区的小城市。 Query Result California + technology Silicon Valley digital + currency Bitcoin Javascript - browser + server Node.js Mark Zuckerberg - Facebook + Amazon Jeff Bezos NLP - text + image computer vision Snowden - United States + Sweden Assange Surface Pro - Microsoft + Amazon Kindle 图6：Hacker News评论数据集中由lda2vec发现的示例线性关系。 第一列表示示例输入查询，第二列表示与输入最相似的标记。 图6表明，除了学习文档的主题以及与词语标记的相似之外，词汇之间的线性规律也被学习到。 “Query”列列出了一系列令牌，这些令牌在组合时会产生与“Result”列中显示的令牌最接近的令牌向量。字面上对矢量的减法和增加进行评估，而是利用3COSMUL目标（Levy和Goldberg，2014b）。结果表明，令牌向量之间存在与黑客新闻社区重要的令牌之间的关系。例如，Silicon Valley(硅谷)的向量与California（加利福尼亚）和Technical（技术）类似，Bitcoin（比特币）确实是一种digital currency（数字货币），Node.js是一种能够在server（服务器）上运行Javascript而不是在客户端browsers（浏览器）上运行Javascript的技术，Jeff Bezos和Mark Zuckerber分别是Amazon（亚马逊）和Facebook的首席执行官，NLP和compute vision（计算机视觉）分别是机器学习研究领域，主要分别处理Text(文本)和Images(图像)，Edward Snowden(爱德华斯诺登)和Julian Assange(朱利安阿桑奇)都是举报者，他们主要位于United states(美国)和Sweden(瑞典)，最终Kindle和Surface Pro都是平板电脑分别由Amazon(亚马逊)和Microsoft(微软)制造。在上述示例中，令牌之间的语义关系对属性和特征进行编码，包括：位置，货币，服务器v.s.客户，领导力数据，机器学习领域，政治数据，国籍，公司和硬件。 Conclusion这项工作演示了一个简单的模型lda2vec，它扩展了SGNS（Mikolov et al。，2013），以构建无监督的文档表示，从而产生连贯的主题。将词，主题和文档向量联合训练并嵌入到共同表示空间中，该空间保留学习词向量之间的语义规则性，同时仍然以LDA的风格产生稀疏且可解释的文档 - 主题比例（Blei等，2003 ）。。在Twenty Newsgroups语料库中形成的主题产生了高度的平均主题一致性，这些主题一致性已被证明与人类主题评估相关（Roder等，2015）。当应用到Hacker News comments语料库时，lda2vec发现了该社区内的显着话题，并且学习了单词之间的线性关系，从而可以在该语料库的专业词汇表中解决单词类比问题。最后，我们注意到，我们的方法在自动微分框架中实现是简单的，并且可以导致更容易解释的无监督表示。]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>recommendation</tag>
        <tag>clustering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DKN:Deep Knowledge-Aware Network for News Recommendation]]></title>
    <url>%2F2018%2F08%2F27%2FDKN-Deep-Knowledge-Aware-Network-for-News-Recommendation%2F</url>
    <content type="text"><![CDATA[用知识图谱表示，结合CNN，利用attention module帮助识别用户的多兴趣，进行新闻推荐 论文地址:https://arxiv.org/abs/1801.08284 参考：Qiu Fengyu ABSTRACT在线新闻推荐系统主要解决新闻信息过载的问题，同时尽可能提升用户的使用体验，注重个性化。一般来说，新闻的语言是高度凝练的，有许多命名实体，并且包含了很多的常识。目前现有的一些推荐算法不关注、或者说无法理解新闻中的一些“知识”以及我们所了解的常识，仅仅通过一些简单的模式匹配、主题相关进行机械的推荐，不具有理论上的扩展性。此外，新闻具有时效性的特征，用户的口味也会 随着时间变化，为解决这些问题，本文提出了 DKN 模型，将知识图谱表示融入新闻推荐中。DKN 是一个预测点击率的基于内容的深度推荐模型。DKN 的核心是一个多通道、命名实体对齐的、融合了知识的卷积神经网络（KCNN），从语义和知识层面上来表示新闻。KCNN 把新闻中的词和实体作为通道（channel），并且在卷积过程中显式地监督两者的对齐关系。为了处理用户喜好的多样性，加入了 Attention 动态地对用户阅读历史进行加权，选择候选新闻。在大量的相关实验中，取得了最好的结果。 KEYWORDS新闻推荐，知识图谱表示，深度神经网络，注意力模型 INTRODUCTION随着网络的发展，现在人们阅读新闻的习惯已经从传统的纸媒、电视转向网络，如Google News和Bing News在线新闻网站，收集各种各样的新闻资源提供给读者。网络新闻平台的一个常见问题是，文章的数量可能会被淹没，从而减轻信息过载的影响，从而帮助读者获取阅读兴趣并提出个性化建议。 总的来说，新闻推荐更为突出的主要有以下三个挑战： 跟电影和酒店相比，新闻具有很强的时间敏感性，容易过期，过时的新闻很快就会被更新的新闻所取代。从而传统基于 ID 的协同过滤方法就很有限了； 用户在阅读新闻的时候是话题敏感的，通常对多个话题都具有倾向性。如何从多种多样的阅读记录中，对用户的多种主题偏好信息进行动态表示，是新闻推荐系统做好的关键； 新闻文本语言高度凝练，还包含了大量的知识实体和常识。 如图1所示，一个用户点击一个标题为“Boris Johnson Has Warned Donald Trump To Stick To The Iran Nuclear Deal”的新闻，其中包含四个实体：“Boris Johnson”,“Donald Trump”, “Iran” and “Nuclear”，事实上，该用户对另外一个新闻（“North Korean EMP Attack Would Cause Mass U.S. Starvation, Says Congressional Report”）也感兴趣，跟上一个联系跟紧密是因为常识。经典的语义模型或者主题模型，都是从词的共现信息或词聚类结构上挖掘新闻之间的关系，仅仅抓住了语义信息，从而给用户的新闻推荐就会变窄，局限在一个话题中。而本文提出的 DKN 能够从中挖掘新闻之间的潜在知识层面上的联系，引入知识图谱中的信息，是一种十分合理的扩展。 为了提取新闻之间深度逻辑关系，将知识图谱引入新闻推荐很有必要。知识图是一种有向异构图，其中节点对应于实体，边对应于关系。 最近，研究人员已经提出了一些学术知识图谱，如NELL,DBpedia,Google Knowledge Graph 和Microsoft Satori.这些知识图谱都成功的应用于机器阅读，文本分类和词嵌入。 考虑到之前提到的新闻推荐的挑战以及知识图谱的广泛成功应用，本文我们提出利用知识图谱做新闻推荐的新的框架（deep knowledge-awarenetwork， DKN）与传统的协同过滤方法不同的是，DKN 是一种基于内容的 CTR（点击率）预测模型：给定一个候选新闻和用户之前的浏览历史，预测用户点击候选新闻的概率。在 DKN 中的主要步骤： 对新闻中的每个词都在知识图谱中找到对应的实体来扩展它的信息，使用他的邻居实体来增强新闻的知识层面的信息。 设计DKN的关键部分knowledge-aware convolutional neural networks (KCNN), 把新闻词和知识层次的信息表示为知识感知嵌入向量。 KCNN 是多个通道的，新闻输入与图像的 RGB 通道类似，这里的通道包含了新闻中词的嵌入（embedding），实体的嵌入及相关实体的嵌入； 词语-实体对齐信息，把一个词和对应的实体在多个通道内进行对齐，通过某种转换函数（映射）来消除词向量和实体向量空间的异构性。或者可以这样理解，KCNN 保证了多个通道内词语的表示的一致性，并且显式地减少不同 embedding 空间的隔阂。 通过 KCNN，得到的新闻知识感知表示向量，候选新闻与用户点击过的新闻通过 attention，加权一个用户的历史新闻得到用户的嵌入表示。用户的嵌入表示和候选新闻的嵌入表示最后通过 DNN 来计算候选新闻被用户点击的概率。 最终，本文提出的 DKN 模型在 Bing News 推荐上得到了显著的性能提升。DKN显著优于基线在F1上的2.8%到17%和AUC的2.6%到16.1%，显著水平为0.1。 提出的注意力机制也可以带来3.5%和1.4%的提高。 PRELIMINARIES这部分介绍本文相关的概念和模型，包括知识图谱嵌入和句子表示的卷积神经网络。 Konowledge Graph Embedding]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>recommendation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[891.Sum of Subsequence Widths]]></title>
    <url>%2F2018%2F08%2F20%2F891-Sum-of-Subsequence-Widths%2F</url>
    <content type="text"><![CDATA[DescriptionGiven an array of integers A, consider all non-empty subsequences of A. For any sequence S, let the width of S be the difference between themaximum and minimum element of S. Return the sum of the widths of all subsequences of A. As the answer may be very large, return the answer modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/sum-of-subsequence-widths/description/ Difficulty: hard Example 1:Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3]. The corresponding widths are 0, 0, 0, 1, 1, 2, 2. The sum of these widths is 6. Note: 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= 20000 分析 将integers A排序 n=3时，形如A=[1,2,3],index=(4-1)*(3-1)=6 n=4时，形如A=[1,2,3,4],index=(8-1)(4-1)+(4-2)(3-2)=23 n=5时，形如A=[1,2,3,4,5],index=(16-1)(5-1)+(8-2)(4-2)=72 总结规律如下 $$index=\sum_{i=0}^{length/2}{(2^{length-1-i}-2^i)*(A[length-1]-A[i])}$$ 参考代码class Solution: def sumSubseqWidths(self, A): length=len(A) if(length==1): return 0 if(length==2): return abs(A[0]-A[1]) p1=length-1 p2=0 P1=2**(length-1) P2=2**0 index=0 A.sort() mod=10**9+7 while(p1&gt;p2): index+=((P1-P2)*(A[p1]-A[p2])) index%=mod p1-=1 p2+=1 P1//=2 P2*=2 return index 64 / 64 test cases passed. Runtime: 1224 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[890.Find and Replace Pattern]]></title>
    <url>%2F2018%2F08%2F20%2F890-Find-and-Replace-Pattern%2F</url>
    <content type="text"><![CDATA[DescriptionYou have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern. You may return the answer in any order. 题目链接：https://leetcode.com/problems/find-and-replace-pattern/description/ Difficulty: medium Example 1:Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot; Output: [&quot;mee&quot;,&quot;aqq&quot;] Explanation: &quot;mee&quot; matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}. &quot;ccc&quot; does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation, since a and b map to the same letter. Note: 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 分析 word与pattern匹配就是一种特殊的相等关系，每个字母是唯一的对应关系； 注意，每个字母只能对应一个，所以，定义两个字典，分别存储key-value和value-key的对应； 定义比较函数judge(a,b)，a=’mee’,b=’aqq’,生成两个字典，{m:a,e:q}和{a:m,q:e},如果相等返回True，反之False。 参考代码class Solution: def findAndReplacePattern(self, words, pattern): def judge(a,b): db={} da={} for i in range(len(a)): if(b[i] in db): if(db[b[i]]!=a[i]): return False else: db[b[i]] = a[i] if(a[i] in da): if(da[a[i]]!=b[i]): return False else: da[a[i]]=b[i] return True li=[] for word in words: if(judge(word,pattern)): li.append(word) return li 46 / 46 test cases passed. Runtime: 60 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[889.Construct Binary Tree from Preorder and Postorder Traversal]]></title>
    <url>%2F2018%2F08%2F20%2F889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[DescriptionReturn any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. 题目链接：https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/ Difficulty: medium Example 1:Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1] Output: [1,2,3,4,5,6,7] Note: 1 &lt;= pre.length == post.length &lt;= 30 pre[] and post[] are both permutations of 1, 2, …, pre.length. It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. 分析 根据先序遍历pre和后续遍历post构建二叉树，常规递归方法； 递归的结束条件是：pre长度为0返回None，长度为1，返回TreeNode(pre[0]) pre[0]作为当前过程的根节点，pre[1:indexof(pre[1])+2]作为左子树先序，post[:indexof(pre[1])+1]作为左子树后序，pre[indexof(pre[1])+2:]作为右子树先序，post[indexof(pre[1])+1：-1]作为右子树后序； 如例：{[2,4,5],[4,5,2]}为左子树，{[3，6，7],[6,7,3]}为右子树，indexof(pre[1])为pre[1] (2)在post中的位置，为：2 以此类推 参考代码#Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def constructFromPrePost(self, pre, post): if(len(pre)==0): return None if(len(pre)==1): return TreeNode(pre[0]) head=TreeNode(pre[0]) index=post.index(pre[1]) left=self.constructFromPrePost(pre[1:2+index], post[:index+1]) right=self.constructFromPrePost(pre[2+index:], post[index+1:-1]) head.left=left head.right=right return head 306 / 306 test cases passed. Runtime: 56 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[888.Fair candy Swap]]></title>
    <url>%2F2018%2F08%2F20%2F888-Fair-candy-Swap%2F</url>
    <content type="text"><![CDATA[DescriptionAlice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has. Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy. (The total amount of candy a person has is the sum of the sizes of candy bars they have.) Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed an answer exists. 题目链接：https://leetcode.com/problems/fair-candy-swap/description/ Difficulty: easy Example 1:Input: A = [1,1], B = [2,2] Output: [1,2] Example 2:Input: A = [1,2], B = [2,3] Output: [1,2] Example 3:Input: A = [2], B = [1,3] Output: [2,3] Example 4:Input: A = [1,2,5], B = [2,4] Output: [5,4] Note: 1 &lt;= A.length &lt;= 10000 1 &lt;= B.length &lt;= 10000 1 &lt;= A[i] &lt;= 100000 1 &lt;= B[i] &lt;= 100000 It is guaranteed that Alice and Bob have different total amounts of candy. It is guaranteed there exists an answer. 分析 交换一个candy使得两个人的candy总数相等，只需要交换的两个candy的差值为两个人的candy的总和的差值的一半（index）即可； 遍历A，存入set，为了搜索快； 遍历B，每一项加上index在set中，即使所需交换的两个candy。 参考代码class Solution: def fairCandySwap(self, A, B): sumA=sum(A) sumB=sum(B) index=(sumB-sumA)//2 bSet=set() for b in B: bSet.add(b) for i in A: if(i+index in bSet): return [i,i+index] return [0,0] 75 / 75 test cases passed. Runtime: 76 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[887.Super Egg Drop]]></title>
    <url>%2F2018%2F08%2F13%2F887-Super-Egg-Drop%2F</url>
    <content type="text"><![CDATA[DescriptionYou are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &lt;= F &lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break. Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 &lt;= X &lt;= N). Your goal is to know with certainty what the value of F is. What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F? 题目链接：https://leetcode.com/problems/super-egg-drop/description/ Difficulty: hard Example 1:Input: K = 1, N = 2 Output: 2 Explanation: Drop the egg from floor 1. If it breaks, we know with certainty that F = 0. Otherwise, drop the egg from floor 2. If it breaks, we know with certainty that F = 1. If it didn&apos;t break, then we know with certainty F = 2. Hence, we needed 2 moves in the worst case to know what F is with certainty. Example 2:Input: K = 2, N = 6 Output: 3 Example 3:Input: K = 3, N = 14 Output: 4 Note: 1 &lt;= K &lt;= 100 1 &lt;= N &lt;= 10000 分析 定义dp[i][j]表示j个鸡蛋i个move对应的楼层，若当前鸡蛋没破，对应的前一步是dp[i-1][j],若破了，对应的是dp[i-1][j-1],故dp[i][j]=dp[i-1][j-1]+dp[i-1][j]+1; 初始化，dp[i][j]=0; 动态计算dp[i][j]，直到dp[i][j]&gt;=N,返回i。 参考代码class Solution: def superEggDrop(self, K, N): dp=[[0]*(K+1) for i in range(N+1)] dp[0][0]=0 for i in range(1,N+1): dp[i][0]=0 for j in range(1,K+1): dp[i][j] = dp[i-1][j]+dp[i-1][j-1]+1 if(dp[i][j]&gt;=N): return i return N]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[886.Possible Bipartition]]></title>
    <url>%2F2018%2F08%2F13%2F886-Possible-Bipartition%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a set of N people (numbered 1, 2, …, N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way. 题目链接：https://leetcode.com/problems/possible-bipartition/description/ Difficulty: medium Example 1:Input: N = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4], group2 [2,3] Example 2:Input: N = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false Example 3:Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false Note: 1 &lt;= N &lt;= 2000 0 &lt;= dislikes.length &lt;= 10000 1 &lt;= dislikes[i][j] &lt;= N A dislikes[i][0] &lt; dislikes[i][1] There does not exist i != j for which dislikes[i] == dislikes[j]. 分析 对每一个[u,v]存储到graph中，代表每个人不喜欢的人的集合； 定义字典color存储每个人的类别，0，1两类； 深度搜索dfs对于每一个node，如果存在于color中，则返回对应值是否等于当前c值；反之，将当前c值存到color，并对所有不喜欢的人dfs，c取反（对1去异或） 对所与人dfs，有false则返回false，反之true。 参考代码class Solution: def possibleBipartition(self, N, dislikes): import collections graph = collections.defaultdict(list) for u, v in dislikes: graph[u].append(v) graph[v].append(u) color = {} def dfs(node, c = 0): if node in color: return color[node] == c color[node] = c return all(dfs(nei, c ^ 1) for nei in graph[node]) return all(dfs(node) for node in range(1, N+1) if node not in color)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[885.Spiral Matrix III]]></title>
    <url>%2F2018%2F08%2F13%2F885-Spiral-Matrix-III%2F</url>
    <content type="text"><![CDATA[DescriptionOn a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid. Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited. 题目链接：https://leetcode.com/problems/spiral-matrix-iii/description/ Difficulty: medium Example 1:Input: R = 1, C = 4, r0 = 0, c0 = 0 Output: [[0,0],[0,1],[0,2],[0,3]] Example 2:Input: R = 5, C = 6, r0 = 1, c0 = 4 Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]] Note: 1 &lt;= R &lt;= 100 1 &lt;= C &lt;= 100 0 &lt;= r0 &lt; R 0 &lt;= c0 &lt; C 分析 由例子可知，从给定点开始，分别向有，向下，向左，向上遍历，初始长度为1，每一圈从向左开始增加1，最后得到遍历二维数组的结果； 定义judge判断某一点是否出界，s是当前遍历的长度； 定义index存储遍历得到的总和，用于结束while； 定义li存储当前满足的结果。 参考代码class Solution: def spiralMatrixIII(self, R, C, r0, c0): index=1 li=[] s=0 r,c=r0,c0 li.append([r,c]) def judge(x,y): if(x&gt;=0 and x&lt;R and y&gt;=0 and y &lt;C): return True return False while(index &lt; R*C): s+=1 for i in range(s): c+=1 if(judge(r,c)): li.append([r,c]) index+=1 for i in range(s): r+=1 if(judge(r,c)): li.append([r,c]) index+=1 s+=1 for i in range(s): c-=1 if(judge(r,c)): li.append([r,c]) index+=1 for i in range(s): r-=1 if(judge(r,c)): li.append([r,c]) index+=1 return li]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[884.Uncommon Words from Two Sentences]]></title>
    <url>%2F2018%2F08%2F13%2F884-Uncommon-Words-from-Two-Sentences%2F</url>
    <content type="text"><![CDATA[DescriptionWe are given two sentences A and B. (A sentence is a string of space separated words. Each word consists only of lowercase letters.) A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Return a list of all uncommon words. You may return the list in any order. 题目链接：https://leetcode.com/problems/uncommon-words-from-two-sentences/description/ Difficulty: easy Example 1:Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot; Output: [&quot;sweet&quot;,&quot;sour&quot;] Example 2:Input: A = &quot;apple apple&quot;, B = &quot;banana&quot; Output: [&quot;banana&quot;] Note: 0 &lt;= A.length &lt;= 200 0 &lt;= B.length &lt;= 200 0 &lt;= A[i] &lt;= 10^9 A and B both contain only spaces and lowercase letters. 分析 如果有一项出现两次或以上，那么一定不是Uncommon Words； 遍历A+B，定义一个set存储遍历结果，若该项已经存在于set中，说明出现不止一次，从list中移出。 参考代码class Solution: def uncommonFromSentences(self, A, B): d=set() li=[] a=A.split()+B.split() for index in a: if(index in d): if(index in li): li.remove(index) else: d.add(index) li.append(index) return li]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[883.Projection Area of 3D Shapes]]></title>
    <url>%2F2018%2F08%2F06%2F883-Projection-Area-of-3D-Shapes%2F</url>
    <content type="text"><![CDATA[DescriptionOn a N N grid, we place some 1 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side. Return the total area of all three projections. 题目链接：https://leetcode.com/problems/projection-area-of-3d-shapes/description/ Difficulty: easy Example 1:Input: [[2]] Output: 5 Example 2:Input: [[1,2],[3,4]] Output: 17 Explanation: Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane. Example 3:Input: [[1,0],[0,2]] Output: 8 Example 4:Input: [[1,1,1],[1,0,1],[1,1,1]] Output: 14 Example 5:Input: [[2,2,2],[2,1,2],[2,2,2]] Output: 21 Note: 1 &lt;= grid.length = grid[0].length &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 分析 updating 参考代码class Solution: def projectionArea(self, grid): row=len(grid) col=len(grid[0]) index=0 for i in range(row): index+=max(grid[i]) for j in range(col): ii=0 for i in range(row): if(grid[i][j]!=0): index+=1 ii=max(ii,grid[i][j]) index+=ii return index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[882.Reachable Nodes In Subdivided Graph]]></title>
    <url>%2F2018%2F08%2F06%2F882-Reachable-Nodes-In-Subdivided-Graph%2F</url>
    <content type="text"><![CDATA[DescriptionStarting with an undirected graph (the “original graph”) with nodes from 0 to N-1, subdivisions are made to some of the edges. The graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph, and n is the total number of new nodes on that edge. Then, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, …, x_n) are added to the original graph, and n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), …, (x_{n-1}, x_n), (x_n, j) are added to the original graph. Now, you start at node 0 from the original graph, and in each move, you travel along one edge. Return how many nodes you can reach in at most M moves. 题目链接：https://leetcode.com/problems/reachable-nodes-in-subdivided-graph/description/ Difficulty: hard Example 1:Input: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3 Output: 13 Explanation: The nodes that are reachable in the final graph after M = 6 moves are indicated below. Example 2:Input: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4 Output: 23 Note: 0 &lt;= edges.length &lt;= 10000 0 &lt;= edges[i][0] &lt; edges[i][1] &lt; N There does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1]. The original graph has no parallel edges. 0 &lt;= edges[i][2] &lt;= 10000 0 &lt;= M &lt;= 10^9 1 &lt;= N &lt;= 3000 A reachable node is a node that can be travelled to using at most M moves starting from node 0. 分析 updating 参考代码updating]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[881.Boats to Save People]]></title>
    <url>%2F2018%2F08%2F06%2F881-Boats-to-Save-People%2F</url>
    <content type="text"><![CDATA[DescriptionThe i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) 题目链接：https://leetcode.com/problems/boats-to-save-people/description/ Difficulty: medium Example 1:Input: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2) Example 2:Input: people = [3,2,2,1], limit = 3 Output: 3 Explanation: 3 boats (1, 2), (2) and (3) Example 3:Input: people = [3,5,3,4], limit = 5 Output: 4 Explanation: 4 boats (3), (3), (4), (5) Note: 1 &lt;= people.length &lt;= 50000 1 &lt;= people[i] &lt;= limit &lt;= 30000 分析 updating 参考代码class Solution: def numRescueBoats(self, people, limit): peo=sorted(people) length=len(peo) index=0 i,j=0,length-1 while(i&lt;=j): index+=1 if(peo[i]+peo[j]&lt;=limit): i+=1 j-=1 return index]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Two Pointers</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[880.Decoded String at Index]]></title>
    <url>%2F2018%2F08%2F06%2F880-Decoded-String-at-Index%2F</url>
    <content type="text"><![CDATA[DescriptionAn encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken: If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape isrepeatedly written d-1 more times in total. Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string. 题目链接：https://leetcode.com/problems/decoded-string-at-index/description/ Difficulty: medium Example 1:Input: S = &quot;leet2code3&quot;, K = 10 Output: &quot;o&quot; Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;. The 10th letter in the string is &quot;o&quot;. Example 2:Input: S = &quot;ha22&quot;, K = 5 Output: &quot;h&quot; Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;. Example 3:Input: S = &quot;a2345678999999999999999&quot;, K = 1 Output: &quot;a&quot; Explanation: The decoded string is &quot;a&quot; repeated 8301530446056247680 times. The 1st letter is &quot;a&quot;. Note: 2 &lt;= S.length &lt;= 100 S will only contain lowercase letters and digits 2 through 9. S starts with a letter. 1 &lt;= K &lt;= 10^9 The decoded string is guaranteed to have less than 2^63 letters. 分析 updating 参考代码class Solution: def decodeAtIndex(self, S, K): size=0 for i in S: if(i.isdigit()): size*=int(i) else: size+=1 for index in reversed(S): K %= size if(K==0 and index.isalpha()): return index if(index.isdigit()): size/=int(index) else: size-=1 return]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]孩子们的游戏（圆圈中最后剩下的数）]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%AD%A9%E5%AD%90%E4%BB%AC%E7%9A%84%E6%B8%B8%E6%88%8F%EF%BC%88%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 题目链接： https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6 分析 用list存储小朋友的编号； 模拟报数，每次将list中报数为m的小盆友的编号移出，同时记录当前位置； 直至剩下最后一个小朋友； 可能是程序的测试用例很小，最直接的办法竟然没有时间超限，应该有更pythonic的方法。 参考代码class Solution: def LastRemaining_Solution(self, n, m): # write code here li=[i for i in range(n)] index=0 if(not n or not m): return -1 while(len(li)&gt;1): index=(index+m-1)%len(li) li.remove(li[index]) return li[0] 运行时间： 64 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]扑克牌顺子]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 题目链接： https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4 分析 首先对numbers进行排序，统计大小王的个数； 定义judge代表已经排好序的牌的最大值，judge==0代表还没有排序； 遍历所有牌，如果有牌大于judge+大小王的个数，则返回False； 反之用大小王替代当前牌与之前牌的差值。 参考代码class Solution: def IsContinuous(self, numbers): # write code here index=0 numbers.sort() judge=0 if(not numbers): return False for i in numbers: if(i==0): index+=1 else: if(judge==0): judge=i else: if(i==judge+1): judge=i else: while(index): judge+=1 index-=1 if(judge+1==i): break if(judge+1!=i): return False judge+=1 return True 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]翻转单词顺序列]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 题目链接： https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3 分析 如下参考代码是遍历字符串的每个字符，遇到空格代表一个新的word，加入到new_s的前面，最后返回即可; 也可以用split()更简单一些，直接将字符串按空格分割。 参考代码class Solution: def ReverseSentence(self, s): # write code here new_s=&apos;&apos; index=&apos;&apos; if(s.strip()==&apos;&apos;): return s for i in s: if(i==&apos; &apos;): if(new_s): new_s = index+&apos; &apos;+new_s else: new_s = &apos;&apos;+index index=&apos;&apos; else: index+=i if(index): if(new_s): new_s = index+&apos; &apos;+new_s else: new_s = index return new_s 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]左旋转字符串]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 题目链接： https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec 分析 只需将移动位置的左右两部分呼唤位置即可，如下参考代码，很大的s，对len(s)取余； 也可以两个s拼接，直接取移动位置后长度为len(s)的字符串。 参考代码class Solution: def LeftRotateString(self, s, n): # write code here if(len(s)==0): return s n=n%len(s) if(n==0): return s else: return s[n:]+s[:n] 运行时间： 29 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]和为S的两个数字]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 题目链接： https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b 输出描述 对应每个测试案例，输出两个数，小的先输出。 分析 两个数的和相等乘积最小，只需要差值最大，类比同周长的矩形和正方形面积，遍历数组，第一个满足的即是最小乘积； i，j指向数字首尾，如果两个数和大于tsum，向左移动j； 如果和为tsum，返回结果； 反之i，j均向右移动； 循环2，3，4。 参考代码class Solution: def FindNumbersWithSum(self, array, tsum): # write code here j=len(array)-1 i=0 while(i&lt;=j): while(array[i]+array[j]&gt;tsum): j-=1 if(array[i]+array[j]==tsum): return [array[i],array[j]] else: j+=1 i+=1 return [] 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]和为S的连续正数序列]]></title>
    <url>%2F2018%2F08%2F04%2Fnowcoder-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 题目链接： https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe 输出描述 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 分析 连续序列（start-end）的和为（end+start）*（end-start+1）/2=sum; 所以end=(pow(1-4(index-index**2-2sum),0.5)-1)/2； 且start的值小于sum/2。 参考代码class Solution: def FindContinuousSequence(self, tsum): # write code here li=[] index=1 while(index&lt;=tsum//2): end=(pow(1-4*(index-index**2-2*tsum),0.5)-1)/2 if(int(end)==end): end=int(end) li.append([i for i in range(index,end+1)]) index+=1 return li 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数组中只出现一次的数字]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 题目链接： https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811 分析 遍历数组，用dict存储每个数字及其出现的次数； 遍历dict，返回所有出现一次的数字。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here d={} for index in array: if(index in d): d[index]+=1 else: d[index]=1 l=[] for index in d: if(d[index]%2==1): l.append(index) return l 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]平衡二叉树]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 题目链接： https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222 分析 递归：如果当前结点为空，返回平衡判断True以及深度0； 如果左右平衡判断出现False，则返回False； 如果左右子树的深度差值大于1，则返回False； 否则返回平衡判断True以及深度（左右子树最大深度+1） 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def IsBalanced_Solution(self, pRoot): # write code here def judge(root): if(not root): return [True,0] left_judge,left=judge(root.left) right_judge,right=judge(root.right) if(not left_judge or not right_judge): return [False,0] if(abs(left-right)&gt;1): return [False,0] return [True,max(left,right)+1] [bo,dep]=judge(pRoot) return bo 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树的深度]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 题目链接： https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b 分析 递归：如果当前结点为空，返回0，否则返回左右子树最大深度+1. 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def TreeDepth(self, pRoot): # write code here if(not pRoot): return 0 left=self.TreeDepth(pRoot.left) right=self.TreeDepth(pRoot.right) return max(left,right)+1 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数字在排序数组中出现的次数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述统计一个数字在排序数组中出现的次数。 题目链接： https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2 分析 遍历找到数组中等于k的数字（代码中是二分查找）； i，j分别向左右移动，知道，对应的下一个值不等于k； 返回j-i+1 参考代码class Solution: def GetNumberOfK(self, data, k): # write code here i,j=0,len(data)-1 mid=(i+j)//2 while(i&lt;=j and data[mid]!=k): if(k&gt;data[mid]): i=mid+1 mid=(i+j)//2 elif(k==data[mid]): break else: j=mid-1 mid=(i+j)//2 if(i&gt;j): return 0 i=j=mid while(i&gt;0): if(data[i-1]==k): i-=1 else: break while(j&lt;len(data)-1): if(data[j+1]==k): j+=1 else: break return j-i+1 运行时间： 20 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]两个链表的第一个公共结点]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入两个链表，找出它们的第一个公共结点。 题目链接： https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46 分析 相当于寻找两个数组的第一个相同数； 遍历两个链表，比较每个结点的val值，相同则返回； 遍历结束返回None。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # write code here p=pHead1 q=pHead2 if(not pHead1 or not pHead2): return None while(p!=None): q=pHead2 while(q): if(p.val==q.val): return q q=q.next p=p.next return None 运行时间： 29 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数组中的逆序对]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题目链接： https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5 输入描述 题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例1输入： 1,2,3,4,5,6,7,0 输出： 7 分析 如果直接两边遍历比较，时间复杂度为$O(n^2)$,时间会超限； 考虑利用时间复杂度为O(nlogn)的归并排序解决，归并排序的子步骤是将两部分的排好序的序列合并，且归并排序是稳定的不会导致计数重复； 每次两部分合并时，若把后面的部分归并时，则该数字比前半部分的剩余序列都小，即逆序对数； 复现归并排序算法，加入计算逆序部分，返回逆序对总数。 参考代码class Solution: def _inter(self,temp,data,low,high): if(low&gt;=high): temp[low]=data[low] return 0 mid=(low+high)//2 left=self._inter(data,temp,low,mid) right=self._inter(data,temp,mid+1,high) count=0 i,j=low,mid+1 index=low while(i&lt;=mid and j &lt;=high): if(data[i]&lt;=data[j]): temp[index]=data[i] i+=1 else: temp[index]=data[j] j+=1 count+=(mid-i+1) index+=1 while(i&lt;=mid): temp[index]=data[i] i+=1 index+=1 while(j&lt;=high): temp[index]=data[j] j+=1 index+=1 return count+left+right def InversePairs(self, data): # write code here if(not data): return 0 import copy temp = [i for i in data] return self._inter(temp,data,0,len(data)-1)%1000000007 运行时间： 2179 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]第一次只出现一次的字符]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 题目链接： https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c 分析 用dict存储字符以及出现的位置；若重复出现，赋值为-1； 用list存储只出现一次的字符，若重复出现，将字符移出； 返回list中第一个字符。 参考代码class Solution: def FirstNotRepeatingChar(self, s): # write code here li=[] d={} for i in range(len(s)): if(s[i] in d): if(d[s[i]]!=-1): li.remove(d[s[i]]) d[s[i]]=-1 else: li.append(i) d[s[i]]=i if(li): return li[0] return -1 运行时间： 41 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]丑数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 题目链接： https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b 分析 由于丑数是只包含质因子2、3和5的数，所以每个数都是由若干个2，3，5相乘得来的； 故循环计算list存储的数分别乘以2，3，5，将最小的数append到list中，同时，该数字对应的在list中的位置后移； 返回最后一个数 参考代码class Solution: def GetUglyNumber_Solution(self, index): # write code here li=[1] index2,index3,index5=0,0,0 if(index&lt;=0): return 0 while(index-1): m=min(li[index2]*2,li[index3]*3,li[index5]*5) li.append(m) if(m%2==0): index2+=1 if(m%3==0): index3+=1 if(m%5==0): index5+=1 index-=1 return li[-1] 运行时间： 27 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]把数组排成最小的数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 题目链接： https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993 分析 定义一个新的比较函数，返回a+b拼接的数字与b+a拼接的数字的差值； 按题意，放在前面是的组合数字更小的数字应该放在前面，所以将新定义的函数传入sorted作为cmp参数，直接调用sorted排序； 主义，sorted的cmp参数在python3中已经不可以使用了。 参考代码class Solution: def PrintMinNumber(self, numbers): # write code here def judge(a,b):#a&lt;=b return int(str(a)+str(b))-int(str(b)+str(a)) numbers=sorted(numbers,cmp=judge) index=&apos;&apos; for i in numbers: index+=str(i) return index 运行时间： 21 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]整数1出现的次数（从1到n整数中1出现的次数）]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B4%E6%95%B01%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 题目链接： https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6 分析 1-10之间1出现10次，11-100之间1出现了19次（个位九次，十位九次，百位一次），一次类推； 但是本题的测试用例比较小，如下暴力解法，也通过了，直接计算每个数中1的个数； 建议总结上面的规律。 参考代码class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here s=0 for index in range(1,n+1): while(index&gt;0): if(index%10==1): s+=1 index/=10 return s 运行时间： 36 ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]连续子数组的最大和]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 题目链接： https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484 分析 动态规划问题，遍历数组，每一步根据以前一个数字为结尾的字串的最大和，以及当前数字，计算以当前数字为结尾的字串的最大和； 得到所有字串的最大和。 参考代码class Solution: def FindGreatestSumOfSubArray(self, array): # write code here index=0 ans=array[0] for i in array: index=max(0,index)+i if(index&gt;ans): ans=index return ans 运行时间： 27ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]最小的k个数]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 题目链接： https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf 分析 排序，返回最后k个数。 参考代码class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here tinput.sort() if(k&gt;len(tinput) or k&lt;=0): return [] return tinput[:k] 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数组中出现次数超过一半的数字]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 题目链接： https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163 分析 遍历数组，将数组中的数字及其相应的出现次数保存到dict中； 返回dict中出现次数大于一般的数字，反之返回0； 参考代码class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here d={} length=len(numbers) for index in numbers: if(index not in d): d[index]=1 else: d[index]+=1 for index in d: if(d[index]&gt;(length/2)): return index return 0 运行时间： 27ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]字符串的排列]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 题目链接： https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7 输入描述 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 分析 递归，每一步选取s中的一个字母加在list中； 终止条件：len(s)==0，则把list加入到全局变量dic（如果dic中不存在）中； 返回dic 参考代码class Solution: def Permutation(self, ss): # write code here ss=list(ss) dic=[] if(len(ss)==0): return dic def _inter(li,s): if(len(s)==0): li=&apos;&apos;.join(li) if(li not in dic): dic.append(li) return for i in s: import copy S=copy.copy(s) S.remove(i) _inter(li+[i],S) _inter([],ss) return dic 运行时间： 30ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉搜索树与双向链表]]></title>
    <url>%2F2018%2F08%2F02%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 题目链接： https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5 分析 递归，递归过程中把root结点的左子树的最右结点与root结点相连，把root结点的右子树的最左结点与root相连； 最后返回root的最左结点，既是根节点。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def Convert(self, pRootOfTree): # write code here if(pRootOfTree==None): return self.Convert(pRootOfTree.left) left=pRootOfTree.left if(left): while(left.right): left=left.right pRootOfTree.left,left.right=left,pRootOfTree self.Convert(pRootOfTree.right) right=pRootOfTree.right if(right): while(right.left): right=right.left pRootOfTree.right,right.left=right,pRootOfTree while(pRootOfTree.left): pRootOfTree=pRootOfTree.left return pRootOfTree 运行时间： 28ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]复杂链表的复制]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 题目链接： https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba 分析 遍历链表可以复制next，但是random指向不一定，所以不能立刻复制，故用dict存储原链表中每个结点的id值（每个结点的id是唯一的）与新结点； 遍历中，复制结点和next指向，random指向原结点的random； 遍历结束后，利用dict重新调整random； 返回p_Head 参考代码class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None class Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here head=pHead p_Head=None new_Head=None dict1={} while(head): node=RandomListNode(head.label) node.random=head.random dict1[id(head)]=node head=head.next if(p_Head): new_Head.next=node new_Head=node else: new_Head=node p_Head=node new_Head=p_Head while(new_Head): if(new_Head.random!=None): new_Head.random=dict1[id(new_Head.random)] new_Head=new_Head.next return p_Head 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树中和为某一值的路径]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 题目链接： https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca 分析 递归，每一次递归的和为expectNumber-root.val; 终止条件：如果root为空返回空list，如果root为叶结点且值为expectNumber，则返回[root.val]; 返回root的值加左右结点返回的list。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here li=[] if(not root): return [] if(root and not root.left and not root.right and root.val==expectNumber): return [[root.val]] left=self.FindPath(root.left,expectNumber-root.val) right=self.FindPath(root.right,expectNumber-root.val) for index in left+right: li.append([root.val]+index) return li 运行时间： 31ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉搜索树的后序遍历序列]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 题目链接： https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd 分析 二叉搜索树是根结点大于左子树的所有结点，小于右子树的所有结点； 根据后续遍历序列，根结点为最后一个数字，去除前面小于根结点的序列，如果后面都大于根结点，则继续下一层，否则返回False； 最后返回True 参考代码class Solution: def VerifySquenceOfBST(self, sequence): # write code here def _inter(se): if(len(se)&lt;=2): return 1 else: index=se[-1] i=0 while(se[i]&lt;index): i+=1 judge=i while(judge&lt;len(se)-1): if(se[judge]&lt;index): return 0 judge+=1 print(se[:i]) print(se[i:-1]) return _inter(se[:i])*_inter(se[i:-1]) if(not sequence): return False if(_inter(sequence)): return True else: return False 运行时间： 33ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]从上往下打印二叉树]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 题目链接： https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701 分析 将根节点压入list，每次取出list第一个TreeNode，将该TreeNode的非空左/右结点压入list； li存储所有压入过list的TreeNode，li即是二叉树的层次遍历序列。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if(not root): return [] lay=[root] li=[root.val] while(len(lay)): ro=lay[0] lay=lay[1:] if(ro.left): li.append(ro.left.val) lay.append(ro.left) if(ro.right): li.append(ro.right.val) lay.append(ro.right) return li 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]栈的的压入、弹出序列]]></title>
    <url>%2F2018%2F07%2F31%2Fnowcoder-%E6%A0%88%E7%9A%84%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 题目链接： https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106 分析 用list存储栈中的数字，遍历压栈序列，记录压栈序列和出栈序列遍历位置； 如果当前压栈数字等于出栈数字，压栈出栈位置后移；否则：如果list最后一个等于出栈数字，list pop出最后一个数字，出栈位置后移，反之，出栈数字压入list，出栈位置后移； 直到遍历完压栈序列，判断list的逆序与出栈剩余序列是否一致，是则返回True，反之False。 参考代码class Solution: def IsPopOrder(self, pushV, popV): # write code here index=0 li=[] length=len(pushV) i=0 while(index &lt; length): if(pushV[index]==popV[i]): index+=1 i+=1 else: if(len(li) and li[-1] == popV[i]): i+=1 li.pop() else: li.append(pushV[index]) index+=1 while(i&lt;length): if(li[-1] == popV[i]): li.pop() i+=1 else: return False return True 运行时间： 25ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[879.Profitable Schemes]]></title>
    <url>%2F2018%2F07%2F30%2F879-Profitable-Schemes%2F</url>
    <content type="text"><![CDATA[DescriptionThere are G people in a gang, and a list of various crimes they could commit. The i-th crime generates a profit[i] and requires group[i] gang members to participate. If a gang member participates in one crime, that member can’t participate in another crime. Let’s call a profitable scheme any subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G. How many schemes can be chosen? Since the answer may be very large, return it modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/profitable-schemes/ Difficulty: hard Example 1:Input: G = 5, P = 3, group = [2,2], profit = [2,3] Output: 2 Explanation: To make a profit of at least 3, the gang could either commit crimes 0 and 1, or just crime 1. In total, there are 2 schemes. Example 2:Input: G = 10, P = 5, group = [2,3,5], profit = [6,7,8] Output: 7 Explanation: To make a profit of at least 5, the gang could commit any crimes, as long as they commit one. There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2). Note: 1 &lt;= G &lt;= 100 0 &lt;= P &lt;= 100 1 &lt;= group[i] &lt;= 100 0 &lt;= profit[i] &lt;= 100 1 &lt;= group.length = profit.length &lt;= 100 分析 反面教材-&gt;递归,updating 参考代码class Solution: def profitableSchemes(self, G, P, group, profit): length=len(group) target=0 def _inter(index,sumG,sumP): if(sumG+group[index]&lt;=G and sumP+profit[index]&gt;=P): nonlocal target target+=1 if(index+1&lt;length): _inter(index+1,sumG,sumP) if(sumG+group[index]&lt;=G): _inter(index+1,sumG+group[index],sumP+profit[index]) _inter(0,0,0) return target]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[878.Nth Magical Number]]></title>
    <url>%2F2018%2F07%2F30%2F878-Nth-Magical-Number%2F</url>
    <content type="text"><![CDATA[DescriptionA positive integer is magical if it is divisible by either A or B. Return the N-th magical number. Since the answer may be very large, return it modulo 10^9 + 7. 题目链接：https://leetcode.com/problems/nth-magical-number/ Difficulty: hard Example 1:Input: N = 1, A = 2, B = 3 Output: 2 Example 2:Input: N = 4, A = 2, B = 3 Output: 6 Example 3:Input: N = 5, A = 2, B = 4 Output: 10 Example 4:Input: N = 3, A = 6, B = 4 Output: 8 Note: 1 &lt;= N &lt;= 10^9 2 &lt;= A &lt;= 40000 2 &lt;= B &lt;= 40000 分析 updating 参考代码class Solution: def nthMagicalNumber(self, N, A, B): def getMiniMul(x,y): a=b=min(x,y) while(True): if(a%x==0 and a%y==0): return a a+=b if(A==B): return (A*N)%(10**9+7) M=getMiniMul(A,B) length=int(M/A+M/B-(M%A==0 and M%B==0)) index=(N-1)%length+1 a=int(index*B/(A+B)) b=int(index*A/(A+B)) target=min(A*(a+1),B*(b+1)) index=(N-1)//length*M+target return index if index &lt; (10**9+7) else index%(10**9+7)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[877.Stone Game]]></title>
    <url>%2F2018%2F07%2F30%2F877-Stone-Game%2F</url>
    <content type="text"><![CDATA[DescriptionAlex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i]. The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties. Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins. Assuming Alex and Lee play optimally, return True if and only if Alex wins the game. 题目链接：https://leetcode.com/problems/stone-game/ Difficulty: medium Example 1:Input: [5,3,4,5] Output: true Explanation: Alex starts first, and can only take the first 5 or the last 5. Say he takes the first 5, so that the row becomes [3, 4, 5]. If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points. If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points. This demonstrated that taking the first 5 was a winning move for Alex, so we return true. Note: 2 &lt;= piles.length &lt;= 500 piles.length is even. 1 &lt;= piles[i] &lt;= 500 sum(piles) is odd. 分析 updating 参考代码class Solution: def stoneGame(self, piles): index=piles[0] for pile in piles: if(index!=pile): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[876.Middle of the Linked List]]></title>
    <url>%2F2018%2F07%2F30%2F876-Middle-of-the-Linked-List%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. 题目链接：https://leetcode.com/problems/middle-of-the-linked-list/ Difficulty: easy Example 1:Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge&apos;s serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2:Input: [1,2,3,4,5,6] Output: Node 4 from this list (Serialization: [4,5,6]) Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100. 分析 updating 参考代码Definition for singly-linked list. class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def middleNode(self, head): a=head b=head b=b.next while(b!=None): a=a.next b=b.next if(b!=None): b=b.next return a]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]包含min函数的栈]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 题目链接： https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49 分析 用list代替栈，append代替栈的push操作，pop代替栈的pop操作，定义m为最小值 push：将m更新为m和node之间的最小值 pop：pop出最后一个数，如果pop出的是最小值，则重新更新m top：返回list最后一个数 min：返回m note要求时间复杂度应为O（1），但其实测试用例没有这么大，leetcode上有一题上是要返回频率最大的数字，可以借鉴上面的方法，参考代码：https://redtongue.coding.me/2018/08/27/895-Maximum-Frequency-Stack/ 参考代码class Solution: def __init__(self): self.stack=[] self.m=None def push(self, node): # write code here self.stack.append(node) if(self.m==None): self.m=node else: self.m=min(self.m,node) def pop(self): # write code here self.stack.pop() if(self.stack): self.m=min(self.stack) else: self.m=None def top(self): return self.stack[-1] # write code here def min(self): # write code here return self.m 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]顺时针打印矩阵]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 题目链接： https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a 分析 定义y_i,y_j,x_i,x_j为左右上下的边界，没输出一条边，便更新边界值，直到不满足{x_i&lt;=x_j and y_i&lt;=y_j}； 定义index为方向，0为向左，1为向下，2为向右，3为向上。 返回遍历值。 note递归应该也是可以做的 输入 ‘a’ ‘b’ ‘c’ ‘d’ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输出 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 参考代码class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here y_i,y_j,x_i,x_j=0,len(matrix[0])-1,0,len(matrix)-1 index=0 x,y=0,0 li=[] li.append(matrix[x][y]) while(x_i&lt;=x_j and y_i&lt;=y_j): if(index==0): while(y+1&lt;=y_j): y+=1 li.append(matrix[x][y]) x_i+=1 elif(index==1): while(x+1&lt;=x_j): x+=1 li.append(matrix[x][y]) y_j-=1 elif(index==2): while(y-1&gt;=y_i): y-=1 li.append(matrix[x][y]) x_j-=1 else: while(x-1&gt;=x_i): x-=1 li.append(matrix[x][y]) y_i+=1 index=(index+1)%4 return li 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二叉树的镜像]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 题目链接： https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011 分析 二叉树镜像，即把每个结点的左右子树互换； 递归最方便，每次递归过程如下：如果当前结点不为空，左右子树互换，左右子结点进入下一轮递归。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if(root): index=root.left root.left=root.right root.right=index self.Mirror(root.left) self.Mirror(root.right) return root 运行时间： 27ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]树的子结构]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 题目链接： https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88 分析 首先定义一个函数judge判断两颗树是否为包含关系，递归的每一步，判断当前结点是否都不为空且值相同，否则不是包含关系， 判断两个子结点是否为空，空则返回true，反之进入下一轮迭代； 最后，遍历pRoot1，比较每个结点和pRoot2是否为包含关系，是返回true，否则，遍历结束，返回False。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here def judge(p1,p2): if(p1 and p2 and p1.val==p2.val): index=1 else: return 0 if(p2.left): a=judge(p1.left,p2.left) else: a=1 if(p2.right): b=judge(p1.right,p2.right) else: b=1 return index*a*b if(not pRoot2): return False l=[pRoot1] if(not pRoot1): return False while(len(l)!=0): p=pRoot2 if(judge(l[0],pRoot2)): return True else: if(l[0].left): l.append(l[0].left) if(l[0].right): l.append(l[0].right) l=l[1:] return False 运行时间： 28ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]合并两个排序的链表]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 题目链接： https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337 分析 首先比较两个链表的表头，较小的当作新链表的表头； 同时遍历两个链表，一次将较小的结点加入到新链表中，知道有一个链表遍历结束； 将另外一个没有遍历完的链表的剩余部分直接加入到新链表的尾部。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # write code here head=None if(pHead1!=None and pHead2!=None): if(pHead1.val &lt; pHead2.val): head=pHead1 pHead1=pHead1.next else: head=pHead2 pHead2=pHead2.next elif(pHead1!=None): head=pHead1 pHead1=pHead1.next elif(pHead2!=None): head=pHead2 pHead2=pHead2.next h=head while(pHead1!=None and pHead2!=None): if(pHead1.val &lt; pHead2.val): h.next=pHead1 h=pHead1 pHead1=pHead1.next else: h.next=pHead2 h=pHead2 pHead2=pHead2.next if(pHead1!=None): h.next=pHead1 if(pHead2!=None): h.next=pHead2 return head 运行时间： 22ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]反转链表]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，反转链表后，输出新链表的表头。 题目链接： https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca 分析 遍历每个结点，首先保存该结点的next，再将该结点指向前一个结点； 知道遍历到最后一个结点（next为None），将该结点指向前一个结点，并返回该结点。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if(pHead==None or pHead.next==None): return pHead ne=None p=pHead while(p): index=p.next p.next=ne ne=p p=index return ne 运行时间： 21ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]链表中倒数第k个结点]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，输出该链表中倒数第k个结点。 题目链接： https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a 分析 遍历链表，将所有结点放在list中； 返回list[-k]。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: def FindKthToTail(self, head, k): # write code here h=head l=[] while(h): l.append(h) h=h.next if(k&gt;len(l) or k&lt;=0): return return l[-k] 运行时间： 24ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]调整数组顺序使得奇数在偶数前面]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%BE%97%E5%A5%87%E6%95%B0%E5%9C%A8%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 题目链接： https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593 分析 因为需要保持相对位置不变，遍历将奇数和偶数分别放在list中； 组合返回即可。 参考代码class Solution: def reOrderArray(self, array): # write code here s1=[] s2=[] for index in array: if(index%2==0): s2.append(index) else: s1.append(index) return s1+s2 运行时间： 25ms]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]数值的整数次方]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 题目链接： https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00 分析 如果指数exponent是负数，只是将正数次幂的结果取倒数； 结果为result=1乘以base指数exponent次。 参考代码class Solution: def Power(self, base, exponent): # write code here judge=0 if(exponent&lt;0): judge=1 exponent*=(-1) result=1 while(exponent): result*=base exponent-=1 if(judge): return 1/result else: return result 运行时间： 21ms 占用内存： 5852k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二进制中1的个数]]></title>
    <url>%2F2018%2F07%2F29%2Fnowcoder-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 题目链接： https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8 分析 首先用list存储整数的二进制形式； 如果为正数，返回list的和； 否则，list中{0，1}取反，再加一。 参考代码class Solution: def NumberOf1(self, n): # write code here index=abs(n) li=[0]*32 i=-1 while(index&gt;0): li[i]=index%2 index//=2 i-=1 if(n&gt;0): return sum(li) else: l=[0 if ii else 1 for ii in li] left=1 for i in range(len(l)-1,-1,-1): if(not left): break if(l[i]): if(left): l[i]=0 else: if(left): l[i] = 1 left=0 return sum(l) 运行时间： 21ms 占用内存： 5736k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]矩形覆盖]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 题目链接： https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6 分析 这几题可能是跟斐波那契数列杠上了，同样的分治思想，设F(n)为覆盖2n的大矩形的方法总数，因为都是21的小矩形，所以F(n-1)和F(n-2)可以把F(n)的所有可能性覆盖，虽然F(n-2)到F(n)之间的2*2的剩余有两种覆盖方法，但是其中一种是F(n-1)中已经包含的； 代码也就显而易见了。 参考代码class Solution: def rectCover(self, number): # write code here if(number==0): return 0 a,b=1,1 while(number): a,b=b,a+b number-=1 return a 运行时间： 21ms 占用内存： 5732k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]变态跳台阶]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题目链接： https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387 在跳台阶中的错误代码中考虑可能会有比较厉害的青蛙，万万没想到，来了个变态。 分析 在跳台阶中，青蛙一次只能跳一级或跳两级,用分治的思想的来想，那么青蛙的最后一跳也只能是一个台阶或两个台阶，设F(n)为n级的台阶总共的跳法总数，那么F(n)=F(n-1)+F(n-2)； 同理，虽然变态，但是$F(n) = \sum_{i=0}^{n-1}{F(i)}$，其中F(0)=1 这个规律是显而易见的，但是我们列出来几项方便看的更清楚，{1，2，4，8，16，……} 虽然变态，但是代码很溜。 参考代码class Solution: def jumpFloorII(self, number): # write code here return 2**(number-1) 运行时间： 22ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]跳台阶]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E8%B7%B3%E5%8F%B0%E9%98%B6%2F</url>
    <content type="text"><![CDATA[题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目链接： https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4 分析 刚看到这个题目我想的是用递归来做，可惜失败了，时间超限； 后来想一想青蛙一次只能跳一级或跳两级，他每一步选择只有两个，用递归确实浪费了； 用分治的思想的来想，那么青蛙的最后一跳也只能是一个台阶或两个台阶，设F(n)为n级的台阶总共的跳法总数，那么F(n)=F(n-1)+F(n-2)。 参考代码class Solution: def jumpFloor(self, number): # write code here a,b=1,1 while(number): a,b=b,a+b number-=1 return a 运行时间： 21ms 占用内存： 5732k 递归代码好吧，这是错误代码，但是万一下一次青蛙比较厉害，可以很多台阶，就可以借鉴了。 class Solution: def jumpFloor(self, number): if(n==0): return 1 else: #如果青蛙比较厉害，下面就需要相应修改了 if(n&gt;1): a=self.jumpFloor(n-1) a+=self.jumpFloor(n-2) else: a=self.jumpFloor(n-1) return a return _inter(number)]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]斐波那契数列]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 题目链接： https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3 分析 斐波那契数列如：1，1，2，3，5，8…… ，即F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2） 额外增加一个0，a=0,b=1代表前两个数字，每次只需将b赋值给a，a+b赋值给b，循环次数即斐波那契数列项数。 参考代码class Solution: def Fibonacci(self, n): # write code here a,b=0,1 while(n): a,b=b,a+b n-=1 return a 运行时间： 30ms 占用内存： 5644k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]旋转数组的最小数字]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 题目链接： https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba 分析 输入是一个非减排序的数组，如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，所以最小数字就是第一个小于前面数字的数字。 如果数组长度为0，返回0。 参考代码class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if(len(rotateArray)==0): return 0 index=rotateArray[0] for i in rotateArray: if i &lt; index: return i 运行时间： 549ms 占用内存： 5860k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]用两个栈实现队列]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题目链接： https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6 分析 栈是先进后出，队列是先进先出，用list的append代表栈的push操作，list的pop代表栈的pop操作； 用s1存储队列push的数据，s2存储队列需要pop的数据； 如果s2为空则将s1的所有数据pop出来后append到s2中，以此将数据反转； 用s2的pop替代队列的pop操作。 参考代码class Solution: def __init__(self): self.s1=[] self.s2=[] def push(self, node): # write code here self.s1.append(node) def pop(self): # return xx if(not self.s2): while(self.s1): self.s2.append(self.s1.pop()) return self.s2.pop() 运行时间： 28ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]重建二叉树]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目链接： https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6 分析 如题目中所给的例子，前序：{1,2,4,7,3,5,6,8}，中序：{4,7,2,1,5,3,8,6}； 前序是“根左右”，中序是“左根右”，所以{1}是根节点，左子树的前序是{2,4,7}，左子树的中序是{4,7,2}，右子树的前序{3,5,6,8}，右子树的中序是{5,3,8,6}，这是一次迭代过程； 以此类推，返回根节点。 参考代码class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): root=None if(len(pre) != 0 and len(tin)!=0): root=TreeNode(pre[0]) index=tin.index(pre[0]) root.left=self.reConstructBinaryTree(pre[1:index+1],tin[:index]) root.right=self.reConstructBinaryTree(pre[index+1:],tin[index+1:]) return root 运行时间： 45ms 占用内存： 5856k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]从尾到头打印链表]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 题目链接： https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035 分析 从头指针开支遍历链表，将每个节点的值（ListNode.val）存储到list中，要求是从尾到头，所以每次添加到list中时用list=[ListNode.val]+list。 参考代码class ListNode: def __init__(self, x): self.val = x self.next = None class Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here li=[] node=listNode while(node!=None): li=[node.val]+li node=node.next return li 运行时间： 22ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]替换空格]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 题目链接： https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423 分析 用一个新变量存储需返回的字符串newStr，逐个遍历源字符串，遇到空格newStr+=’%20’。 参考代码class Solution: # s 源字符串 def replaceSpace(self, s): newStr=&apos;&apos; for i in s: if(i==&apos; &apos;): newStr+=&apos;%20&apos; else: newStr+=i return newStr 运行时间： 23ms 占用内存： 5728k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[nowcoder]二维数组中的查找]]></title>
    <url>%2F2018%2F07%2F28%2Fnowcoder-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目链接： https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e 分析 每一行都按照从左到右递增，每一列都按照从上到下递增，所以每一行最大数是最后一个 比较每一行的最后一个数字与target的大小，如果target大，则目标在下一行，否则，目标在这一行中，将这一行的数字逐个与target比较。 如果到最后一行也没有与target相等的数，返回False 参考代码class Solution: # array 二维列表 def Find(self, target, array): for row in array: if(len(row)&gt;0 and target&gt;row[-1]): continue else: for i in row: if(i==target): return True return False 运行时间： 184ms 占用内存： 5724k]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>剑指Offer</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[875.Koko EAting Bananas]]></title>
    <url>%2F2018%2F07%2F23%2F875-Koko-EAting-Bananas%2F</url>
    <content type="text"><![CDATA[DescriptionKoko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours. 题目链接：https://leetcode.com/problems/koko-eating-bananas/ Difficulty: medium Example 1:Input: piles = [3,6,7,11], H = 8 Output: 4 Example 2:Input: piles = [30,11,23,4,20], H = 5 Output: 30 Example 3:Input: piles = [30,11,23,4,20], H = 6 Output: 23 Note: 1 &lt;= piles.length &lt;= 10^4 piles.length &lt;= H &lt;= 10^9 1 &lt;= piles[i] &lt;= 10^9 分析 updating 参考代码class Solution: def minEatingSpeed(self, piles, H): def judge(index): return sum((p-1)//index +1 for p in piles) &lt;=H l,h=1,max(piles) while(l&lt;h): middle=(l+h)//2 if(not judge(middle)): l=middle+1 else: h=middle return h]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[874.Walking Robot Simulation]]></title>
    <url>%2F2018%2F07%2F23%2F874-Walking-Robot-Simulation%2F</url>
    <content type="text"><![CDATA[DescriptionA robot on an infinite grid starts at point (0, 0) and faces north. The robot can receive one of three possible types of commands: -2: turn left 90 degrees -1: turn right 90 degrees 1 &lt;= x &lt;= 9: move forward x units Some of the grid squares are obstacles. The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1]) If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.) Return the square of the maximum Euclidean distance that the robot will be from the origin. 题目链接：https://leetcode.com/problems/walking-robot-simulation/ Difficulty: easy Example 1:Input: commands = [4,-1,3], obstacles = [] Output: 25 Explanation: robot will go to (3, 4) Example 2:Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]] Output: 65 Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8) Note: 0 &lt;= commands.length &lt;= 10000 0 &lt;= obstacles.length &lt;= 10000 -30000 &lt;= obstacle[i][0] &lt;= 30000 -30000 &lt;= obstacle[i][1] &lt;= 30000 The answer is guaranteed to be less than 2 ^ 31. 分析 updating 参考代码class Solution: def robotSim(self, commands, obstacles): direction=0 positionx=0 positiony=0 Max=0 d={} for i,j in obstacles: if(i in d): d[i]=d[i]+[j] else: d[i] = [j] for com in commands: if(com==-1): direction=(direction+1)%4 elif(com==-2): direction=(direction-1)%4 else: x=positionx y=positiony for index in range(com): if(direction==0): y+=1 elif(direction==1): x+=1 elif(direction==2): y-=1 else: x-=1 if(x in d and y in d[x]): break else: positionx=x positiony=y Max=max(Max,positionx**2+positiony**2) return Max]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[873.Length of Longest Fibonacci Subsequence]]></title>
    <url>%2F2018%2F07%2F23%2F873-Length-of-Longest-Fibonacci-Subsequence%2F</url>
    <content type="text"><![CDATA[DescriptionA sequence X_1, X_2, …, X_n is fibonacci-like if: n &gt;= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 &lt;= n Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A. If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].) 题目链接：https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/ Difficulty: medium Example 1:Input: [1,2,3,4,5,6,7,8] Output: 5 Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8]. Example 2:Input: [1,3,7,11,12,14,18] Output: 3 Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]. Note: 3 &lt;= A.length &lt;= 1000 1 &lt;= A[0] &lt; A[1] &lt; … &lt; A[A.length - 1] &lt;= 10^9 (The time limit has been reduced by 50% for submissions in Java, C, and C++.) 分析 updating 参考代码class Solution: def lenLongestFibSubseq(self, A): length=len(A) S=0 index=set(A) for i in range(length-1): for j in range(i+1,length): a=A[i] b=A[j] s=2 while a+b in index: ii=a+b a=b b=ii s+=1 S=max(S,s) return S if S&gt;2 else 0]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[872.Leaf-Similar Trees]]></title>
    <url>%2F2018%2F07%2F23%2F872-Leaf-Similar-Trees%2F</url>
    <content type="text"><![CDATA[DescriptionConsider all the leaves of a binary tree. From left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar. 题目链接：https://leetcode.com/problems/leaf-similar-trees/ Difficulty: easy Note: Both of the given trees will have between 1 and 100 nodes. 分析 updating 参考代码Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def leafSimilar(self, root1, root2): li1=[] li2=[] def _int(root): if(root==None): return else: if(root.left == None): if(root.right == None): li1.append(root.val) return else: _int(root.right) else: _int(root.left) if(root.right != None): _int(root.right) def _int2(root): if(root==None): return else: if(root.left == None): if(root.right == None): li2.append(root.val) return else: _int2(root.right) else: _int2(root.left) if(root.right != None): _int2(root.right) _int(root1) _int2(root2) print(&apos;li1&apos;,li1) print(&apos;li2&apos;,li2) if(li1 == li2): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[871.Minimum Number of Refueling Stops]]></title>
    <url>%2F2018%2F07%2F16%2F871-Minimum-Number-of-Refueling-Stops%2F</url>
    <content type="text"><![CDATA[DescriptionA car travels from a starting position to a destination which is target miles east of the starting position. Along the way, there are gas stations. Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas. The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses 1 liter of gas per 1 mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car. What is the least number of refueling stops the car must make in order to reach its destination? If it cannot reach the destination, return -1. Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived. 题目链接：https://leetcode.com/problems/minimum-number-of-refueling-stops/ Difficulty: hard Example 1:Input: target = 1, startFuel = 1, stations = [] Output: 0 Explanation: We can reach the target without refueling. Example 2:Input: target = 100, startFuel = 1, stations = [[10,100]] Output: -1 Explanation: We can&apos;t reach the target (or even the first gas station). Example 3:Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]] Output: 2 Explanation: We start with 10 liters of fuel. We drive to position 10, expending 10 liters of fuel. We refuel from 0 liters to 60 liters of gas. Then, we drive from position 10 to position 60 (expending 50 liters of fuel), and refuel from 10 liters to 50 liters of gas. We then drive to and reach the target. We made 2 refueling stops along the way, so we return 2. Note: 1 &lt;= target, startFuel, stations[i][1] &lt;= 10^9 0 &lt;= stations.length &lt;= 500 0 &lt; stations[0][0] &lt; stations[1][0] &lt; … &lt; stations[stations.length-1][0] &lt; target 分析 updating 参考代码class Solution: def minRefuelStops(self, target, startFuel, stations): def _inter(fuel,stations,index): if(len(stations)==0): if(fuel&gt;=target): return index else: return -1 else: position,fu=stations[0] if(fuel &lt; position): return -1 else: x1=_inter(fuel+fu,stations[1:],index+1) x2=_inter(fuel,stations[1:],index) if(x1 != -1): if(x2!=-1): return min(x1,x2) else: return x1 else: return x2 return _inter(startFuel,stations,0)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Dynamic Programming</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[870.Advantage Shuffle]]></title>
    <url>%2F2018%2F07%2F16%2F870-Advantage-Shuffle%2F</url>
    <content type="text"><![CDATA[DescriptionGiven two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] &gt; B[i]. Return any permutation of A that maximizes its advantage with respect to B. 题目链接：https://leetcode.com/problems/advantage-shuffle/ Difficulty: medium Example 1:Input: A = [2,7,11,15], B = [1,10,4,11] Output: [2,11,7,15] Example 2:Input: A = [12,24,8,32], B = [13,25,32,11] Output: [24,32,8,12] Note: 1 &lt;= A.length = B.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^9 0 &lt;= B[i] &lt;= 10^9 分析 updating 参考代码class Solution: def advantageCount(self, A, B): s_a=sorted(A) s_b=sorted(B) assigned={b:[] for b in B} li=[] j=0 for a in s_a: if(a &gt; s_b[j]): assigned[s_b[j]].append(a) j += 1 else: li.append(a) return [assigned[b].pop() if assigned[b] else li.pop() for b in B]]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Array</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[869.Reordered Power of 2]]></title>
    <url>%2F2018%2F07%2F16%2F869-Reordered-Power-of-2%2F</url>
    <content type="text"><![CDATA[DescriptionStarting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this in a way such that the resulting number is a power of 2. 题目链接：https://leetcode.com/problems/reordered-power-of-2/ Difficulty: medium Example 1:Input: 1 Output: true Example 2:Input: 10 Output: false Example 3:Input: 16 Output: true Example 4:Input: 24 Output: false Example 5:Input: 46 Output: true Note: 1 &lt;= N &lt;= 10^9 分析 updating 参考代码class Solution: def reorderedPowerOf2(self, N): li=[] for i in range(30): li.append(str(2**i)) def judge(a,b): if(len(a) == len(b)): A=list(a) B=list(b) for index in A: if(index in B): B.remove(index) else: return False return True return False for i in range(len(li)): if(judge(li[i],str(N))): return True return False]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[868.Binary Gap]]></title>
    <url>%2F2018%2F07%2F16%2F868-Binary-Gap%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N. If there aren’t two consecutive 1’s, return 0. 题目链接：https://leetcode.com/problems/binary-gap/ Difficulty: easy Example 1:Input: 22 Output: 2 Explanation: 22 in binary is 0b10110. In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s. The first consecutive pair of 1&apos;s have distance 2. The second consecutive pair of 1&apos;s have distance 1. The answer is the largest of these two distances, which is 2. Example 2:Input: 5 Output: 2 Explanation: 5 in binary is 0b101. Example 3:Input: 6 Output: 1 Explanation: 6 in binary is 0b110. Example 4:Input: 8 Output: 0 Explanation: 8 in binary is 0b1000. There aren&apos;t any consecutive pairs of 1&apos;s in the binary representation of 8, so we return 0. Note: 1 &lt;= N &lt;= 10^9 分析 updating 参考代码class Solution: def binaryGap(self, N): judge=False index=0 Max=0 while(N &gt; 0): if(N%2==1): if(judge): Max=max(Max,index+1) index=0 judge=True else: index += 1 N = N//2 return Max]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Math</tag>
      </tags>
  </entry>
</search>
